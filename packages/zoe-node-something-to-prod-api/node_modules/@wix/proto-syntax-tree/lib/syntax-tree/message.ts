import {OptionType, Message, ProtoFile, Reserved, TypeName} from '../api';
import {BaseType} from './base-type';
import {SyntaxTreeImpl} from './index';
import {EnumImpl} from './enum';
import {OneofImpl} from './one-of';
import {FieldImpl, FieldsImpl} from './field';
import {MessageDescriptorPath} from './descriptor-paths';
import {OptionsImpl} from './options';
import {PathInfo, pInfo, SourceCodeIndex} from './source-code-index';
import {DetailedSourceCode, initDetailedSourceCode} from './source-code-details';
import {DescriptorProto} from '../descriptor';
import {ReservedWithExclusiveRange} from './reserved';

export class MessageImpl extends BaseType implements Message {
  readonly typeName = TypeName.Message;
  readonly detailedSourceCode: DetailedSourceCode<'name'>;
  private readonly descriptor: DescriptorProto;

  constructor(
    readonly st: SyntaxTreeImpl,
    descriptor: DescriptorProto,
    parent: ProtoFile | Message,
    pathInfo: PathInfo,
    sourceIdx: SourceCodeIndex,
  ) {
    super(descriptor, parent);
    this.descriptor = descriptor;
    this.parent = parent;
    this.reserved = new ReservedWithExclusiveRange(descriptor);
    this.options = new OptionsImpl(st, {options: descriptor.options, optionType: OptionType.MessageOptions}, this,
      pInfo(pathInfo, MessageDescriptorPath.options), sourceIdx);

    this.detailedSourceCode = initDetailedSourceCode(pathInfo, sourceIdx, this, {
      'name': MessageDescriptorPath.name,
    });

    st.addType(this);

    this.enums = [];
    let i = 0;
    for (const enumDescriptor of descriptor.enumTypeList) {
      const anEnum = new EnumImpl(st, enumDescriptor, this, pInfo(pathInfo, MessageDescriptorPath.enum, i++), sourceIdx);
      this.enums.push(anEnum);
    }

    this.messages = [];
    i = 0;
    for (const nestedDescriptor of descriptor.nestedTypeList) {
      const nested = new MessageImpl(st, nestedDescriptor, this, pInfo(pathInfo, MessageDescriptorPath.message, i++), sourceIdx);
      this.messages.push(nested);
    }

    this.oneofs = [];
    i = 0;
    for (const oneofDescriptor of descriptor.oneofDeclList) {
      const oneof = new OneofImpl(st, oneofDescriptor, this, pInfo(pathInfo, MessageDescriptorPath.oneof, i++), sourceIdx);
      this.oneofs.push(oneof);
    }

    this.fields = new FieldsImpl();
    i = 0;
    for (const fieldDescriptor of descriptor.fieldList) {
      const field = new FieldImpl(st, fieldDescriptor, this, pInfo(pathInfo, MessageDescriptorPath.field, i++), sourceIdx);
      this.fields.push(field);
    }
  }

  get isMapEntry(): boolean {
    return this.descriptor.options?.mapEntry === true;
  }

  get file() {
    return this.parent.file;
  }

  toJSON() {
    return {
      typeName: this.typeName,
      name: this.name,
      options: this.options.allOptions,
      fields: this.fields,
      oneofs: this.oneofs,
      messages: this.messages,
      enums: this.enums,
      isMapEntry: this.isMapEntry,
    };
  }

  readonly enums: EnumImpl[];
  readonly messages: MessageImpl[];
  readonly fields: FieldsImpl;
  readonly oneofs: OneofImpl[];
  readonly parent: ProtoFile | Message;
  readonly reserved: Reserved;
  readonly options: OptionsImpl<OptionType.MessageOptions>;
}
