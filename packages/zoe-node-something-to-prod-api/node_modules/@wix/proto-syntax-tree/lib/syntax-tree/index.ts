import {Enum, EnumValue, Extension, OptionType, Field, Message, Method, Oneof, ProtoFile, Service, SyntaxTree, Type, TypeName} from '../api';
import {FileInfo, ProtoFileImpl} from './proto-file';
import {FileDescriptorSet} from '../descriptor';
import assert from 'assert';

export class SyntaxTreeError extends Error {

}

export class SyntaxTreeImpl implements SyntaxTree {
  readonly files: ProtoFile[] = [];
  private readonly types: Map<string, Type> = new Map<string, Type>();
  private readonly options: Map<OptionType, {[key: number]: Extension}> = new Map<OptionType, {[p: number]: Extension}>();

  toJSON() {
    return {
      files: this.files
    };
  }

  addType(type: Type) {
    this.types.set(type.fqn, type);
    if (type.fqn.startsWith('.')) {
      this.types.set(type.fqn.slice(1), type);
    }
  }

  addOption(ext: Extension) {
    if (ext.optionType) {
      let options = this.options.get(ext.optionType);
      if (!options) {
        options = {};
        this.options.set(ext.optionType, options);
      }
      options[ext.number] = ext;
    }
  }

  getOptionByNumber(optionType: OptionType, optionNumber: number): Extension {
    const options = this.options.get(optionType);
    assert(options, 'option not found');
    return options[optionNumber];
  }

  getType(fqn: string): Type {
    const type = this.findType(fqn);
    if (!type) {
      throw new SyntaxTreeError(`Type not found: ${fqn}`);
    }
    return type;
  }

  findType(fqn: string): Type | undefined {
    return this.types.get(fqn);
  }

  private getAndValidateType<T extends Type>(fqn: string, typeName: TypeName): T {
    const type = this.getType(fqn);
    if (type.typeName === typeName) {
      return type as T;
    }
    throw new SyntaxTreeError(`Expected ${fqn} to be a ${typeName} but it is a ${type.typeName}`);
  }

  getFile(fqn: string): ProtoFile {
    return this.getAndValidateType(fqn, TypeName.File);
  }

  getService(fqn: string): Service {
    return this.getAndValidateType(fqn, TypeName.Service);
  }

  getMethod(fqn: string): Method {
    return this.getAndValidateType(fqn, TypeName.Method);
  }

  getMessage(fqn: string): Message {
    return this.getAndValidateType(fqn, TypeName.Message);
  }

  getExtension(fqn: string): Extension {
    return this.getAndValidateType(fqn, TypeName.Extension);
  }

  getEnum(fqn: string): Enum {
    return this.getAndValidateType(fqn, TypeName.Enum);
  }

  getField(fqn: string): Field {
    return this.getAndValidateType(fqn, TypeName.Field);
  }

  getOneof(fqn: string): Oneof {
    return this.getAndValidateType(fqn, TypeName.Oneof);
  }

  getEnumValue(fqn: string): EnumValue {
    return this.getAndValidateType(fqn, TypeName.EnumValue);
  }
}

export type GetFileInfo = (protoFileName: string) => FileInfo;

export interface SyntaxTreeOptions {
  getFileInfo: GetFileInfo;
}

export function buildSyntaxTree(fileDescriptorSets: FileDescriptorSet[], opts: SyntaxTreeOptions): SyntaxTree {
  const st = new SyntaxTreeImpl();
  for (const fileDescriptorSet of fileDescriptorSets) {
    for (const fileDescriptor of fileDescriptorSet.fileList) {
      const fileInfo = opts.getFileInfo(fileDescriptor.name);
      const file = new ProtoFileImpl(st, fileDescriptor, fileInfo);
      st.files.push(file);
    }
  }

  return st;
}
