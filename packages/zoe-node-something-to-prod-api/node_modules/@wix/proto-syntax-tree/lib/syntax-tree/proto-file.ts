import {OptionType, ProtoFile, ProtoFolderType, TypeName} from '../api';
import {BaseType} from './base-type';
import {SyntaxTreeImpl} from './index';
import {MessageImpl} from './message';
import {ServiceImpl} from './service';
import {EnumImpl} from './enum';
import {FileDescriptorPath} from './descriptor-paths';
import {ExtensionImpl} from './extension';
import {OptionsImpl} from './options';
import {newSourceCodeIndex, pInfo, rootPathInfo, SourceCodeIndex} from './source-code-index';
import {DetailedSourceCode, initDetailedSourceCode} from './source-code-details';
import {FileDescriptorProto} from '../descriptor';

export interface FileInfo {
  path: string;
  fromInclude: boolean;
}

export class ProtoFileImpl extends BaseType implements ProtoFile {
  readonly typeName = TypeName.File;
  private readonly scIndex: SourceCodeIndex;

  readonly detailedSourceCode: DetailedSourceCode<'package' | 'syntax'>;

  constructor(
    readonly st: SyntaxTreeImpl,
    descriptor: FileDescriptorProto,
    fileInfo: FileInfo
  ) {
    super(descriptor, null);
    this.package = descriptor.package;
    this.path = fileInfo.path;
    this.protoFolder = fileInfo.fromInclude ? ProtoFolderType.IncludeProtoFolder : ProtoFolderType.MainProtoFolder;
    this.scIndex = newSourceCodeIndex(this, descriptor);
    const pathInfo = rootPathInfo();
    this.detailedSourceCode = initDetailedSourceCode(pathInfo, this.scIndex, this, {
      'package': FileDescriptorPath.package,
      'syntax': FileDescriptorPath.syntax,
    });

    st.addType(this);

    this.extensions = [];
    let i = 0;
    for (const fieldDescriptor of descriptor.extensionList) {
      const extension = new ExtensionImpl(st, fieldDescriptor, this, pInfo(pathInfo, FileDescriptorPath.extensions, i++), this.scIndex);
      this.extensions.push(extension);
    }

    this.options = new OptionsImpl(st, {options: descriptor.options, optionType: OptionType.FileOptions},
      this, pInfo(pathInfo, FileDescriptorPath.options), this.scIndex);

    this.enums = [];
    i = 0;
    for (const enumDescriptor of descriptor.enumTypeList) {
      const anEnum = new EnumImpl(st, enumDescriptor, this, pInfo(pathInfo, FileDescriptorPath.enum, i++), this.scIndex);
      this.enums.push(anEnum);
    }

    this.messages = [];
    i = 0;
    for (const messageDescriptor of descriptor.messageTypeList) {
      const message = new MessageImpl(st, messageDescriptor, this, pInfo(pathInfo, FileDescriptorPath.message, i++), this.scIndex);
      this.messages.push(message);
    }

    this.services = [];
    i = 0;
    for (const serviceDescriptor of descriptor.serviceList) {
      const service = new ServiceImpl(st, serviceDescriptor, this, pInfo(pathInfo, FileDescriptorPath.service, i++), this.scIndex);
      this.services.push(service);
    }
  }

  get file(): ProtoFileImpl {
    return this;
  }

  toJSON() {
    return {
      typeName: this.typeName,
      name: this.name,
      options: this.options.allOptions,
      package: this.package,
      path: this.path,
      enums: this.enums,
      messages: this.messages,
      services: this.services,
      extensions: this.extensions,
      protoFolder: ProtoFolderType[this.protoFolder],
    };
  }

  readonly package: string;
  readonly path: string;
  readonly enums: EnumImpl[];
  readonly messages: MessageImpl[];
  readonly services: ServiceImpl[];
  readonly extensions: ExtensionImpl[];
  readonly options: OptionsImpl<OptionType.FileOptions>;
  readonly protoFolder: ProtoFolderType;
}

