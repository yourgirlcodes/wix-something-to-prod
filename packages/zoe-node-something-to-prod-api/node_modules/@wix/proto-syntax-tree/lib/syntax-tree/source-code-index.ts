import {ProtoFile, SourceCodeContainer, SourceCodeInfo} from '../api';
import {SourceCodeInfoImpl} from './source-code-info';
import {FileDescriptorProto, SourceCodeInfo as ScInfo} from '../descriptor';

export interface PathInfo {
  fullPath: number[];
}

class PathInfoImpl implements PathInfo {
  private _calculated?: number[];

  constructor(
    private readonly path: number,
    private readonly parent: PathInfo,
    private readonly index?: number) {
  }

  private calcFullPath(): number[] {
    if (this.index !== undefined) {
      return this.parent.fullPath.concat(this.path, this.index);
    } else {
      return this.parent.fullPath.concat(this.path);
    }
  }

  get fullPath(): number[] {
    if (!this._calculated) {
      this._calculated = this.calcFullPath();
    }
    return this._calculated;
  }
}

export interface SourceCodeIndex {
  getSourceCodeInfoByPath(pathInfo: PathInfo, container: SourceCodeContainer): SourceCodeInfo;
  getSourceCodeInfoBySubPath(pathInfo: PathInfo, container: SourceCodeContainer, name: string, subPath: number): SourceCodeInfo;
  getSourceCodeInfoBySubPaths(pathInfo: PathInfo, container: SourceCodeContainer, name: string, subPaths: number[]): SourceCodeInfo;
  getSourceCodeInfoByPathPrefix(pathInfo: PathInfo, container: SourceCodeContainer): SourceCodeInfo;
}

export function rootPathInfo(): PathInfo {
  return {fullPath: []};
}

export function pInfo(parent: PathInfo, path: number, index?: number): PathInfo {
  return new PathInfoImpl(path, parent, index);
}

export function newSourceCodeIndex(file: ProtoFile, descriptor: FileDescriptorProto): SourceCodeIndex {
  const sourceCodeInfo = descriptor.sourceCodeInfo;
  if (sourceCodeInfo) {
    return new SourceCodeIndexImpl(file, sourceCodeInfo);
  }
  return new NoSourceCodeIndex();
}

class SourceCodeIndexImpl implements SourceCodeIndex {
  private readonly index;

  constructor(
    private readonly file: ProtoFile,
    sourceCodeInfo: ScInfo) {
    this.index = new LocationIndex(Array.from(sourceCodeInfo.locationList));
  }

  getSourceCodeInfoByPath(pathInfo: PathInfo, container: SourceCodeContainer): SourceCodeInfo {
    const actualPath = pathInfo.fullPath;
    const location = this.index.findByPath(actualPath);
    if (location) {
      return new SourceCodeInfoImpl(location, container);
    }
    throw new Error('no source code info found');
  }

  getSourceCodeInfoByPathPrefix(pathInfo: PathInfo, container: SourceCodeContainer): SourceCodeInfo {
    const actualPath = pathInfo.fullPath;
    const location = this.index.findByPathPrefix(actualPath);
    if (location) {
      return new SourceCodeInfoImpl(location, container);
    }
    throw new Error('no source code info found');
  }

  getSourceCodeInfoBySubPath(pathInfo: PathInfo, container: SourceCodeContainer, name: string, subPath: number): SourceCodeInfo {
    const actualPath = pathInfo.fullPath.concat(subPath);
    const location = this.index.findByPath(actualPath);
    if (location) {
      return new SourceCodeInfoImpl(location, container, name);
    }
    throw new Error('no source code info found');
  }

  getSourceCodeInfoBySubPaths(pathInfo: PathInfo, container: SourceCodeContainer, name: string, subPaths: number[]): SourceCodeInfo {
    const actualPath = pathInfo.fullPath;
    const location = this.index.findByPathPrefixAndLastElements(actualPath, subPaths);
    if (location) {
      return new SourceCodeInfoImpl(location, container, name);
    }
    throw new Error('no source code info found');
  }

}

interface Location {
  pathList: number[];
}

export class LocationIndex<T extends Location> {
  constructor(private readonly locations: T[]) {
  }

  findByPath(actualPath: number[]) {
    return this.locations.find(location => {
      const path = location.pathList;
      return (path.length === actualPath.length && actualPath.every((value, i) => value === path[i]));
    });
  }

  findByPathPrefix(actualPath: number[]) {
    return this.locations.find(location => {
      const path = location.pathList;
      return (path.length >= actualPath.length && actualPath.every((value, i) => value === path[i]));
    });
  }

  findByPathPrefixAndLastElements(actualPath: number[], lastElements: number[]) {
    return this.locations.find(location => {
      const path = location.pathList;
      const expectedLength = actualPath.length + 1;
      if (path.length === expectedLength && actualPath.every((value, i) => value === path[i])) {
        const lastPathElem = path[path.length - 1];
        return lastElements.some(lastElem => lastElem === lastPathElem);
      }
      return false;
    });
  }

}

class NoSourceCodeIndex implements SourceCodeIndex {
  getSourceCodeInfoByPath(): SourceCodeInfo {
    throw new Error('no source code info provided');
  }

  getSourceCodeInfoByPathPrefix(): SourceCodeInfo {
    throw new Error('no source code info provided');
  }

  getSourceCodeInfoBySubPath(): SourceCodeInfo {
    throw new Error('no source code info provided');
  }

  getSourceCodeInfoBySubPaths(): SourceCodeInfo {
    throw new Error('no source code info provided');
  }
}
