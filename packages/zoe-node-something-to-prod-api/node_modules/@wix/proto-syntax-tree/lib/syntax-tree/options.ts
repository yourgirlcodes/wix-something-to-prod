import {Extension, OptionType, Option, Options, ProtoFile, RepeatedTypedOption, SourceCodeInfo, Type, TypedOption, TypeName} from '../api';
import {SyntaxTreeImpl} from './index';
import {PathInfo, pInfo, SourceCodeIndex} from './source-code-index';
import assert from 'assert';
import {CustomOptionsContainer} from '../descriptor';

interface DescriptorOptions<OT extends OptionType> {
  options?: CustomOptionsContainer;
  optionType: OT;
}

export class OptionsImpl<OT extends OptionType> implements Options<OT> {
  private readonly descOptions: DescriptorOptions<OT>;
  private readonly optionByNum = new Map<number, {value: readonly OptionImpl<any>[] | OptionImpl<any> | undefined}>();

  constructor(
    private readonly st: SyntaxTreeImpl,
    descOptions: DescriptorOptions<OT>,
    private readonly parent: Type,
    private readonly pathInfo: PathInfo,
    private readonly sourceIdx: SourceCodeIndex,
  ) {
    this.descOptions = descOptions;
  }

  get allOptions(): Option[] {
    const result = [];

    const customOptions = this.descOptions.options?.customOptions;
    if (customOptions) {
      for (const fieldNumber in customOptions) {
        const opt = this.getOptionByNumber(Number.parseInt(fieldNumber));
        if (opt) {
          result.push(opt);
        }
      }
    }
    return result.flat();
  }

  getOptions(extensionType: string): readonly OptionImpl<any>[] {
    const extension = this.st.findType(extensionType);
    if (extension && extension.typeName === TypeName.Extension && extension.optionType === this.descOptions.optionType) {
      const result = this.getOptionByNumber(extension.number);
      if (result !== undefined) {
        if (isArray(result)) {
          return result;
        } else {
          return Object.freeze([result]);
        }
      }
    }
    return Object.freeze([]);
  }

  getTypedOption<T>(option: TypedOption<OT, T>): Option<T> | undefined;
  getTypedOption<T>(option: RepeatedTypedOption<OT, T>): readonly Option<T>[];
  getTypedOption<T>(option: TypedOption<OT, T> | RepeatedTypedOption<OT, T>): Option<T> | undefined | readonly Option<T>[] {
    assert(option.optionType === this.descOptions.optionType, 'invalid extension type');

    const result = this.getOptionByNumber<T>(option.extensionNumber);
    if (result === undefined && option.repeated) {
      return Object.freeze([]);
    }
    return result;
  }

  private getOptionByNumber<T>(extensionNumber: number): OptionImpl<T> | readonly OptionImpl<T>[] | undefined {
    let cached = this.optionByNum.get(extensionNumber);
    if (!cached) {
      cached = {value: this.getOptionByNumberInternal(extensionNumber)};
      this.optionByNum.set(extensionNumber, cached);
    }
    return cached.value;
  }

  private getOptionByNumberInternal<T>(extensionNumber: number): OptionImpl<T> | readonly OptionImpl<T>[] | undefined {
    if (this.descOptions.options) {
      const value: T | T[] | undefined = this.descOptions.options.customOptions[extensionNumber];
      if (value !== undefined) {
        if (Array.isArray(value)) {
          return Object.freeze(value.map((val, idx) => new OptionImpl(this.st, extensionNumber, this.descOptions.optionType, val, this.parent,
            this.pathInfo, this.sourceIdx!, idx)));
        } else {
          return new OptionImpl(this.st, extensionNumber, this.descOptions.optionType, value, this.parent,
            this.pathInfo, this.sourceIdx!);
        }
      }
    }
  }
}

class OptionImpl<T> implements Option<T> {
  private readonly _parent: Type;
  private readonly pathInfo: PathInfo;
  private readonly _value: T;

  constructor(
    private readonly st: SyntaxTreeImpl,
    private readonly extensionNumber: number,
    private readonly optionType: OptionType,
    value: T,
    parent: Type,
    pathInfo: PathInfo,
    private readonly sourceIdx: SourceCodeIndex,
    private readonly idx?: number,
  ) {
    this._value = deepFreeze(value);
    this._parent = parent;
    this.pathInfo = pInfo(pathInfo, extensionNumber, idx);
  }

  get sourceCode(): SourceCodeInfo {
    return this.sourceIdx.getSourceCodeInfoByPathPrefix(this.pathInfo, this);
  }

  get file(): ProtoFile {
    return this._parent.file;
  }

  get extension(): Extension {
    return this.st.getOptionByNumber(this.optionType, this.extensionNumber);
  }

  get value(): T {
    return this._value;
  }

  get fqn() {
    let result = `${this._parent.fqn}[${this.extension.fqn}]`;
    if (this.idx !== undefined) {
      result += `.${this.idx}`;
    }
    return result;
  }

  toJSON() {
    return {
      name: this.extension.fqn,
      value: this.value,
    };
  }

}

function deepFreeze<T>(obj: T): T {
  const object = obj as Record<string, any>;
  const propNames = Object.getOwnPropertyNames(object);

  for (const name of propNames) {
    const value = object[name];

    if (value && typeof value === 'object') {
      deepFreeze(value);
    }
  }

  return Object.freeze(obj);
}

//This is needed because of TS bug with Array.isArray on readonly arrays: https://github.com/microsoft/TypeScript/issues/17002
function isArray<T>(value: readonly T[] | T): value is readonly T[] {
  return Array.isArray(value);
}
