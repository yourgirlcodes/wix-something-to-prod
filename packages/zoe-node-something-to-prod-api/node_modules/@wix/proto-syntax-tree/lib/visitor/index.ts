import {Enum, EnumValue, Extension, Field, Message, Method, Oneof, ProtoFile, Service, Type} from '../api';

export {visitSyntaxTree, visitSyntaxTreeFrom} from './iterator';
export {skip} from './skipper';

export interface Visitor {
  visitFile?(file: ProtoFile): boolean | void;
  visitService?(service: Service): boolean | void;
  visitMessage?(message: Message): boolean | void;
  visitEnum?(enm: Enum): boolean | void;
  visitMethod?(method: Method): void;
  visitField?(field: Field): void;
  visitOneof?(oneof: Oneof): void;
  visitEnumValue?(enumValue: EnumValue): void;
  visitExtension?(extension: Extension): void;
}

export type SyntaxTreeContainers = ProtoFile | Service | Message | Enum;

type NotUndef<F> = F extends undefined ? never : F;

//Extract visit methods from Visitor
export type VisitMethods = {
  [K in keyof Visitor]-?: NotUndef<Visitor[K]> extends (elem: infer E) => any ? E extends Type ? K : never : never
}[keyof Visitor];

export type VisitContainerMethods = {
  [K in keyof Visitor]-?: NotUndef<Visitor[K]> extends (elem: infer E) => any ? E extends SyntaxTreeContainers ? K : never : never
}[keyof Visitor];


//Holds the visit* method names from the Visitor interface for use by proxies and such
const vm: Record<VisitMethods, true> = {
  visitFile: true,
  visitService: true,
  visitMessage: true,
  visitEnum: true,
  visitMethod: true,
  visitField: true,
  visitOneof: true,
  visitEnumValue: true,
  visitExtension: true,
};

//Holds the visit* method names from the Visitor interface for methods that return a boolean (i.e. container visitors)
const vcm: Record<VisitContainerMethods, true> = {
  visitFile: true,
  visitService: true,
  visitMessage: true,
  visitEnum: true,
};
export const visitorMethods = Object.keys(vm) as Array<VisitMethods>;
export const visitorContainerMethods = Object.keys(vcm) as Array<VisitMethods>;

export type Skipper = {
  [P in VisitMethods]?: NotUndef<Visitor[P]> extends (arg: infer U) => any ? (arg: U) => boolean | void : never;
};
