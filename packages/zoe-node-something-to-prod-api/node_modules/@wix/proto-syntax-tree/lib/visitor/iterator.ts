import {Enum, EnumValue, Extension, Field, Message, Method, Oneof, ProtoFile, Service, SyntaxTree, TypeName} from '../api';
import {SyntaxTreeContainers, Visitor} from './index';

export function visitSyntaxTree(st: SyntaxTree, visitor: Visitor) {
  const iterator = new SyntaxTreeIterator(visitor);
  iterator.iterate(st);
}

export function visitSyntaxTreeFrom(node: SyntaxTreeContainers, visitor: Visitor) {
  const iterator = new SyntaxTreeIterator(visitor);
  iterator.iterateFrom(node);
}

class SyntaxTreeIterator {
  private readonly visitor: Visitor;

  constructor(visitor: Visitor) {
    this.visitor = visitor;
  }

  iterate(syntaxTree: SyntaxTree): void {
    this.iterateFiles(syntaxTree.files);
  }

  iterateFrom(node: ProtoFile | Service | Message | Enum): void {
    switch (node.typeName) {
      case TypeName.File:
        this.visitFile(node);
        break;
      case TypeName.Service:
        this.visitService(node);
        break;
      case TypeName.Message:
        this.visitMessage(node);
        break;
      case TypeName.Enum:
        this.visitEnum(node);
        break;
    }
  }

  private iterateFiles(files: readonly ProtoFile[]) {
    for (const file of files) {
      this.visitFile(file);
    }
  }

  private visitFile(file: ProtoFile) {
    if (this.visitor.visitFile) {
      if (this.visitor.visitFile(file) === false) {
        return;
      }
    }

    this.iterateServices(file.services);
    this.iterateMessages(file.messages);
    this.iterateEnums(file.enums);
    this.iterateExtensions(file.extensions);
  }

  private iterateServices(services: readonly Service[]) {
    for (const service of services) {
      this.visitService(service);
    }
  }

  private visitService(service: Service) {
    if (this.visitor.visitService) {
      if (this.visitor.visitService(service) === false) {
        return;
      }
    }

    this.iterateMethods(service.methods);
  }

  private iterateMessages(messages: readonly Message[]) {
    for (const message of messages) {
      this.visitMessage(message);
    }
  }

  private visitMessage(message: Message) {
    if (this.visitor.visitMessage) {
      if (this.visitor.visitMessage(message) === false) {
        return;
      }
    }

    this.iterateMessages(message.messages);
    this.iterateEnums(message.enums);
    this.iterateOneofs(message.oneofs);
    this.iterateFields(message.fields);
  }

  private iterateEnums(enums: readonly Enum[]) {
    for (const enm of enums) {
      this.visitEnum(enm);
    }
  }

  private visitEnum(enm: Enum) {
    if (this.visitor.visitEnum) {
      if (this.visitor.visitEnum(enm) === false) {
        return;
      }
    }

    this.iterateEnumValues(enm.values);
  }

  private iterateMethods(methods: readonly Method[]) {
    if (this.visitor.visitMethod) {
      for (const method of methods) {
        this.visitor.visitMethod(method);
      }
    }
  }

  private iterateFields(fields: readonly Field[]) {
    if (this.visitor.visitField) {
      for (const field of fields) {
        this.visitor.visitField(field);
      }
    }
  }

  private iterateOneofs(oneofs: readonly Oneof[]) {
    if (this.visitor.visitOneof) {
      for (const oneof of oneofs) {
        this.visitor.visitOneof(oneof);
      }
    }
  }

  private iterateEnumValues(enumValues: readonly EnumValue[]) {
    for (const enumValue of enumValues) {
      if (this.visitor.visitEnumValue) {
        this.visitor.visitEnumValue(enumValue);
      }
    }
  }

  private iterateExtensions(extensions: readonly Extension[]) {
    if (this.visitor.visitExtension) {
      for (const extension of extensions) {
        this.visitor.visitExtension(extension);
      }
    }
  }
}
