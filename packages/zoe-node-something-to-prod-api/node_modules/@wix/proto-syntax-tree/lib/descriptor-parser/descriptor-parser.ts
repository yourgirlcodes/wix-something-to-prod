import assert from 'assert';
import * as pb from 'google-protobuf/google/protobuf/descriptor_pb';
import {
  ExtensionFieldBinaryInfo,
  ExtensionFieldInfo,
  Message,
  BinaryReader,
  BinaryRead
} from 'google-protobuf';
import debug from 'debug';
import {FileDescriptorSet} from '../descriptor';
import {asFileDescriptorSet} from './descriptor-adapter';

const miniPb = require('./mini_descriptor_pb').google.protobuf as typeof pb;
const srcLessPb = require('./srcless_descriptor_pb').google.protobuf as typeof pb;

const log = debug('wix:flynt:descriptor-parser');

type DeserFunc = (msg: Message, reader: BinaryReader) => Message;

type BinaryReadPrimitive = (this: BinaryReader) => any;
type MsgConstructor = new () => Message;

interface MsgFieldInfo {
  readerFunc: BinaryRead;
  fieldIndex: number;
  fieldName: string;
  jsonName: string;
  msgCtor: MsgConstructor;
  isRepeated: boolean;
  binaryDeserializeFn?: DeserFunc;
}

interface PrimitiveFieldInfo {
  readerFunc: BinaryReadPrimitive;
  fieldIndex: number;
  fieldName: string;
  jsonName: string;
  msgCtor: undefined;
  isRepeated: boolean;
  binaryDeserializeFn: undefined;
}

type FieldInfo = MsgFieldInfo | PrimitiveFieldInfo;

interface Context {
  msgCache: Map<string, pb.DescriptorProto>;
  deserCache: Map<string, DeserFunc>;
}

export function parseFileDescriptorSet(descriptorSetBytes: Buffer[], allSrcs = false): FileDescriptorSet[] {
  return parsePbFileDescriptorSet(descriptorSetBytes, allSrcs).map(asFileDescriptorSet);
}

export function parsePbFileDescriptorSet(descriptorSetBytes: Buffer[], allSrcs = false): pb.FileDescriptorSet[] {
  const context = {
    msgCache: new Map<string, pb.DescriptorProto>(),
    deserCache: new Map<string, DeserFunc>(),
  };

  function cacheMessage(cacheKeyPrefix: string, msg: pb.DescriptorProto) {
    const fqn = cacheKeyPrefix + '.' + msg.getName();
    context.msgCache.set(fqn, msg);
    for (const nested of msg.getNestedTypeList()) {
      cacheMessage(fqn, nested);
    }
  }

  log('parsing file descriptors - first pass');
  initExtendees();

  const firstPassDescriptors = descriptorSetBytes.map(ds => miniPb.FileDescriptorSet.deserializeBinary(ds));

  log('creating extensions');
  for (const firstPassFiles of firstPassDescriptors) {
    for (const file of firstPassFiles.getFileList()) {
      const pkgName = file.getPackage()!;

      const cacheKeyPrefix = pkgName ? `.${pkgName}` : '';
      for (const msg of file.getMessageTypeList()) {
        cacheMessage(cacheKeyPrefix, msg);
      }

      for (const extension of file.getExtensionList()) {
        createExtension(extension, context);
      }
    }
  }

  log('parsing file descriptors - second pass');
  if (allSrcs) {
    return descriptorSetBytes.map(ds => pb.FileDescriptorSet.deserializeBinary(ds));
  } else {
    const lastSet = descriptorSetBytes.pop()!;
    return descriptorSetBytes.map(ds => srcLessPb.FileDescriptorSet.deserializeBinary(ds))
      .concat(pb.FileDescriptorSet.deserializeBinary(lastSet));
  }
}

function getDeserializeFunction(typeName: string, context: Context) {
  let result = context.deserCache.get(typeName);
  if (!result) {
    const msgType = context.msgCache.get(typeName);
    assert(msgType, `could not find ${typeName} in msgCache. This usually means descriptor sets were provided in the wrong order`);
    result = generateDeserializeFunction(msgType, context);
    context.deserCache.set(typeName, result);
  }
  return result;
}

function initFieldInfo(msgType: pb.DescriptorProto, fieldInfoCache: Map<number, FieldInfo>, context: Context) {
  for (const field of msgType.getFieldList()) {
    const fieldInfo = getFieldInfo(field, context);
    fieldInfoCache.set(fieldInfo.fieldIndex, fieldInfo);
  }
}

function generateDeserializeFunction(msgType: pb.DescriptorProto, context: Context): DeserFunc {
  const fieldInfoCache = new Map<number, FieldInfo>();
  let fieldInfoInit = false;
  return function (msg: Message, reader: BinaryReader) {
    if (!fieldInfoInit) {
      fieldInfoInit = true;
      initFieldInfo(msgType, fieldInfoCache, context);
    }
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const fieldNumber = reader.getFieldNumber();
      assert(fieldNumber);
      const fieldInfo = fieldInfoCache.get(fieldNumber);
      assert(fieldInfo, `no field info cache for field number ${fieldNumber} in ${msgType.getName()}`);
      let value: any;
      if (fieldInfo.msgCtor) {
        assert(fieldInfo.binaryDeserializeFn);
        const MsgCtor = fieldInfo.msgCtor;
        value = new MsgCtor();
        fieldInfo.readerFunc.call(reader, value, fieldInfo.binaryDeserializeFn);
      } else {
        value = fieldInfo.readerFunc.call(reader);
      }
      (msg as Option).setFieldValue(fieldInfo, value);
    }
    return msg;
  };
}

class Option extends Message {
  [key: string]: any;

  serializeBinary(): Uint8Array {
    throw new Error('not implemented');
  }

  toObject() {
    return {};
  }

  setFieldValue(fieldInfo: FieldInfo, value: any) {
    const fieldName = fieldInfo.jsonName;
    if (fieldInfo.isRepeated) {
      const currentVal = this[fieldName];
      if (!currentVal) {
        this[fieldName] = [value];
      } else {
        currentVal.push(value);
      }
    } else {
      this[fieldName] = value;
    }
  }
}

function getExtendee(extension: pb.FieldDescriptorProto, container: typeof pb) {
  switch (extension.getExtendee()) {
    case '.google.protobuf.FileOptions':
      return container.FileOptions;
    case '.google.protobuf.ServiceOptions':
      return container.ServiceOptions;
    case '.google.protobuf.MethodOptions':
      return container.MethodOptions;
    case '.google.protobuf.MessageOptions':
      return container.MessageOptions;
    case '.google.protobuf.EnumOptions':
      return container.EnumOptions;
    case '.google.protobuf.EnumValueOptions':
      return container.EnumValueOptions;
    case '.google.protobuf.FieldOptions':
      return container.FieldOptions;
    case '.google.protobuf.OneofOptions':
      return container.OneofOptions;
  }
}

function initExtendees() {
  function initExtendee(extendee: typeof Message) {
    extendee.extensions = {};
    extendee.extensionsBinary = {};
  }

  initExtendee(pb.FileOptions);
  initExtendee(pb.ServiceOptions);
  initExtendee(pb.MethodOptions);
  initExtendee(pb.MessageOptions);
  initExtendee(pb.EnumOptions);
  initExtendee(pb.EnumValueOptions);
  initExtendee(pb.FieldOptions);
  initExtendee(pb.OneofOptions);
}

function getFieldHandlerFuncs(fieldType: pb.FieldDescriptorProto, context: Context):
  {readerFunc: BinaryReadPrimitive} | {readerFunc: BinaryRead; msgCtor: MsgConstructor; deserFunc: DeserFunc} | undefined {
  switch (fieldType.getType()) {
    case pb.FieldDescriptorProto.Type.TYPE_DOUBLE:
      return {readerFunc: BinaryReader.prototype.readDouble};
    case pb.FieldDescriptorProto.Type.TYPE_FLOAT:
      return {readerFunc: BinaryReader.prototype.readFloat};
    case pb.FieldDescriptorProto.Type.TYPE_INT64:
      return {readerFunc: BinaryReader.prototype.readInt64};
    case pb.FieldDescriptorProto.Type.TYPE_UINT64:
      return {readerFunc: BinaryReader.prototype.readUint64};
    case pb.FieldDescriptorProto.Type.TYPE_INT32:
      return {readerFunc: BinaryReader.prototype.readInt32};
    case pb.FieldDescriptorProto.Type.TYPE_FIXED64:
      return {readerFunc: BinaryReader.prototype.readFixed64};
    case pb.FieldDescriptorProto.Type.TYPE_FIXED32:
      return {readerFunc: BinaryReader.prototype.readFixed32};
    case pb.FieldDescriptorProto.Type.TYPE_BOOL:
      return {readerFunc: BinaryReader.prototype.readBool};
    case pb.FieldDescriptorProto.Type.TYPE_STRING:
      return {readerFunc: BinaryReader.prototype.readString};
    case pb.FieldDescriptorProto.Type.TYPE_GROUP:
      return {readerFunc: BinaryReader.prototype.skipGroup};
    case pb.FieldDescriptorProto.Type.TYPE_MESSAGE:
      return {
        readerFunc: BinaryReader.prototype.readMessage,
        msgCtor: Option,
        deserFunc: getDeserializeFunction(fieldType.getTypeName()!, context)
      };
    case pb.FieldDescriptorProto.Type.TYPE_BYTES:
      return {readerFunc: BinaryReader.prototype.readBytes};
    case pb.FieldDescriptorProto.Type.TYPE_UINT32:
      return {readerFunc: BinaryReader.prototype.readUint32};
    case pb.FieldDescriptorProto.Type.TYPE_ENUM:
      return {readerFunc: BinaryReader.prototype.readEnum};
    case pb.FieldDescriptorProto.Type.TYPE_SFIXED32:
      return {readerFunc: BinaryReader.prototype.readSfixed32};
    case pb.FieldDescriptorProto.Type.TYPE_SFIXED64:
      return {readerFunc: BinaryReader.prototype.readSfixed64};
    case pb.FieldDescriptorProto.Type.TYPE_SINT32:
      return {readerFunc: BinaryReader.prototype.readSint32};
    case pb.FieldDescriptorProto.Type.TYPE_SINT64:
      return {readerFunc: BinaryReader.prototype.readSint64};
  }
}

function getFieldInfo(fieldDesc: pb.FieldDescriptorProto, context: Context): FieldInfo {
  const funcs = getFieldHandlerFuncs(fieldDesc, context);
  assert(funcs, `no field info for ${fieldDesc.getName()}`);
  if ('msgCtor' in funcs) {
    return {
      readerFunc: funcs.readerFunc,
      fieldIndex: fieldDesc.getNumber()!,
      fieldName: fieldDesc.getName()!,
      jsonName: fieldDesc.getJsonName()!,
      msgCtor: funcs.msgCtor,
      isRepeated: fieldDesc.getLabel() === pb.FieldDescriptorProto.Label.LABEL_REPEATED,
      binaryDeserializeFn: funcs.deserFunc,
    };
  } else {
    return {
      readerFunc: funcs.readerFunc,
      fieldIndex: fieldDesc.getNumber()!,
      fieldName: fieldDesc.getName()!,
      jsonName: fieldDesc.getJsonName()!,
      msgCtor: undefined,
      isRepeated: fieldDesc.getLabel() === pb.FieldDescriptorProto.Label.LABEL_REPEATED,
      binaryDeserializeFn: undefined,
    };
  }
}

function createExtension(extension: pb.FieldDescriptorProto, context: Context) {
  const fieldInfo = getFieldInfo(extension, context);

  const extensionFieldInfo = new ExtensionFieldInfo(fieldInfo.fieldIndex,
    {[fieldInfo.fieldName]: 0},
    fieldInfo.msgCtor as any,
    undefined as any, //No need to support
    fieldInfo.isRepeated ? 1 : 0);

  const extensionFieldBinaryInfo = new ExtensionFieldBinaryInfo(
    extensionFieldInfo,
    fieldInfo.readerFunc,
    undefined as any, //No need to support
    undefined as any, //No need to support
    fieldInfo.binaryDeserializeFn as any,
    false,
  );

  const extendee = getExtendee(extension, pb);
  if (extendee) {
    extendee.extensions[extension.getNumber()!] = extensionFieldInfo;
    extendee.extensionsBinary[extension.getNumber()!] = extensionFieldBinaryInfo;
  }

  const srcLessExtendee = getExtendee(extension, srcLessPb);
  if (srcLessExtendee) {
    srcLessExtendee.extensions[extension.getNumber()!] = extensionFieldInfo;
    srcLessExtendee.extensionsBinary[extension.getNumber()!] = extensionFieldBinaryInfo;
  }
}
