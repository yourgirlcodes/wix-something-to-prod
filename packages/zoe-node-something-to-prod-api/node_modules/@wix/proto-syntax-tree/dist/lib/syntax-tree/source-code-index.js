"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationIndex = exports.newSourceCodeIndex = exports.pInfo = exports.rootPathInfo = void 0;
const source_code_info_1 = require("./source-code-info");
class PathInfoImpl {
    constructor(path, parent, index) {
        this.path = path;
        this.parent = parent;
        this.index = index;
    }
    calcFullPath() {
        if (this.index !== undefined) {
            return this.parent.fullPath.concat(this.path, this.index);
        }
        else {
            return this.parent.fullPath.concat(this.path);
        }
    }
    get fullPath() {
        if (!this._calculated) {
            this._calculated = this.calcFullPath();
        }
        return this._calculated;
    }
}
function rootPathInfo() {
    return { fullPath: [] };
}
exports.rootPathInfo = rootPathInfo;
function pInfo(parent, path, index) {
    return new PathInfoImpl(path, parent, index);
}
exports.pInfo = pInfo;
function newSourceCodeIndex(file, descriptor) {
    const sourceCodeInfo = descriptor.sourceCodeInfo;
    if (sourceCodeInfo) {
        return new SourceCodeIndexImpl(file, sourceCodeInfo);
    }
    return new NoSourceCodeIndex();
}
exports.newSourceCodeIndex = newSourceCodeIndex;
class SourceCodeIndexImpl {
    constructor(file, sourceCodeInfo) {
        this.file = file;
        this.index = new LocationIndex(Array.from(sourceCodeInfo.locationList));
    }
    getSourceCodeInfoByPath(pathInfo, container) {
        const actualPath = pathInfo.fullPath;
        const location = this.index.findByPath(actualPath);
        if (location) {
            return new source_code_info_1.SourceCodeInfoImpl(location, container);
        }
        throw new Error('no source code info found');
    }
    getSourceCodeInfoByPathPrefix(pathInfo, container) {
        const actualPath = pathInfo.fullPath;
        const location = this.index.findByPathPrefix(actualPath);
        if (location) {
            return new source_code_info_1.SourceCodeInfoImpl(location, container);
        }
        throw new Error('no source code info found');
    }
    getSourceCodeInfoBySubPath(pathInfo, container, name, subPath) {
        const actualPath = pathInfo.fullPath.concat(subPath);
        const location = this.index.findByPath(actualPath);
        if (location) {
            return new source_code_info_1.SourceCodeInfoImpl(location, container, name);
        }
        throw new Error('no source code info found');
    }
    getSourceCodeInfoBySubPaths(pathInfo, container, name, subPaths) {
        const actualPath = pathInfo.fullPath;
        const location = this.index.findByPathPrefixAndLastElements(actualPath, subPaths);
        if (location) {
            return new source_code_info_1.SourceCodeInfoImpl(location, container, name);
        }
        throw new Error('no source code info found');
    }
}
class LocationIndex {
    constructor(locations) {
        this.locations = locations;
    }
    findByPath(actualPath) {
        return this.locations.find(location => {
            const path = location.pathList;
            return (path.length === actualPath.length && actualPath.every((value, i) => value === path[i]));
        });
    }
    findByPathPrefix(actualPath) {
        return this.locations.find(location => {
            const path = location.pathList;
            return (path.length >= actualPath.length && actualPath.every((value, i) => value === path[i]));
        });
    }
    findByPathPrefixAndLastElements(actualPath, lastElements) {
        return this.locations.find(location => {
            const path = location.pathList;
            const expectedLength = actualPath.length + 1;
            if (path.length === expectedLength && actualPath.every((value, i) => value === path[i])) {
                const lastPathElem = path[path.length - 1];
                return lastElements.some(lastElem => lastElem === lastPathElem);
            }
            return false;
        });
    }
}
exports.LocationIndex = LocationIndex;
class NoSourceCodeIndex {
    getSourceCodeInfoByPath() {
        throw new Error('no source code info provided');
    }
    getSourceCodeInfoByPathPrefix() {
        throw new Error('no source code info provided');
    }
    getSourceCodeInfoBySubPath() {
        throw new Error('no source code info provided');
    }
    getSourceCodeInfoBySubPaths() {
        throw new Error('no source code info provided');
    }
}
//# sourceMappingURL=source-code-index.js.map