"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSyntaxTree = exports.SyntaxTreeImpl = exports.SyntaxTreeError = void 0;
const api_1 = require("../api");
const proto_file_1 = require("./proto-file");
const assert_1 = __importDefault(require("assert"));
class SyntaxTreeError extends Error {
}
exports.SyntaxTreeError = SyntaxTreeError;
class SyntaxTreeImpl {
    constructor() {
        this.files = [];
        this.types = new Map();
        this.options = new Map();
    }
    toJSON() {
        return {
            files: this.files
        };
    }
    addType(type) {
        this.types.set(type.fqn, type);
        if (type.fqn.startsWith('.')) {
            this.types.set(type.fqn.slice(1), type);
        }
    }
    addOption(ext) {
        if (ext.optionType) {
            let options = this.options.get(ext.optionType);
            if (!options) {
                options = {};
                this.options.set(ext.optionType, options);
            }
            options[ext.number] = ext;
        }
    }
    getOptionByNumber(optionType, optionNumber) {
        const options = this.options.get(optionType);
        (0, assert_1.default)(options, 'option not found');
        return options[optionNumber];
    }
    getType(fqn) {
        const type = this.findType(fqn);
        if (!type) {
            throw new SyntaxTreeError(`Type not found: ${fqn}`);
        }
        return type;
    }
    findType(fqn) {
        return this.types.get(fqn);
    }
    getAndValidateType(fqn, typeName) {
        const type = this.getType(fqn);
        if (type.typeName === typeName) {
            return type;
        }
        throw new SyntaxTreeError(`Expected ${fqn} to be a ${typeName} but it is a ${type.typeName}`);
    }
    getFile(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.File);
    }
    getService(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Service);
    }
    getMethod(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Method);
    }
    getMessage(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Message);
    }
    getExtension(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Extension);
    }
    getEnum(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Enum);
    }
    getField(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Field);
    }
    getOneof(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.Oneof);
    }
    getEnumValue(fqn) {
        return this.getAndValidateType(fqn, api_1.TypeName.EnumValue);
    }
}
exports.SyntaxTreeImpl = SyntaxTreeImpl;
function buildSyntaxTree(fileDescriptorSets, opts) {
    const st = new SyntaxTreeImpl();
    for (const fileDescriptorSet of fileDescriptorSets) {
        for (const fileDescriptor of fileDescriptorSet.fileList) {
            const fileInfo = opts.getFileInfo(fileDescriptor.name);
            const file = new proto_file_1.ProtoFileImpl(st, fileDescriptor, fileInfo);
            st.files.push(file);
        }
    }
    return st;
}
exports.buildSyntaxTree = buildSyntaxTree;
//# sourceMappingURL=index.js.map