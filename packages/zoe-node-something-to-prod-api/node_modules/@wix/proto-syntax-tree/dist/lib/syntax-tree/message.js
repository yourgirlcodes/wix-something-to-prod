"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageImpl = void 0;
const api_1 = require("../api");
const base_type_1 = require("./base-type");
const enum_1 = require("./enum");
const one_of_1 = require("./one-of");
const field_1 = require("./field");
const descriptor_paths_1 = require("./descriptor-paths");
const options_1 = require("./options");
const source_code_index_1 = require("./source-code-index");
const source_code_details_1 = require("./source-code-details");
const reserved_1 = require("./reserved");
class MessageImpl extends base_type_1.BaseType {
    constructor(st, descriptor, parent, pathInfo, sourceIdx) {
        super(descriptor, parent);
        this.st = st;
        this.typeName = api_1.TypeName.Message;
        this.descriptor = descriptor;
        this.parent = parent;
        this.reserved = new reserved_1.ReservedWithExclusiveRange(descriptor);
        this.options = new options_1.OptionsImpl(st, { options: descriptor.options, optionType: api_1.OptionType.MessageOptions }, this, (0, source_code_index_1.pInfo)(pathInfo, descriptor_paths_1.MessageDescriptorPath.options), sourceIdx);
        this.detailedSourceCode = (0, source_code_details_1.initDetailedSourceCode)(pathInfo, sourceIdx, this, {
            'name': descriptor_paths_1.MessageDescriptorPath.name,
        });
        st.addType(this);
        this.enums = [];
        let i = 0;
        for (const enumDescriptor of descriptor.enumTypeList) {
            const anEnum = new enum_1.EnumImpl(st, enumDescriptor, this, (0, source_code_index_1.pInfo)(pathInfo, descriptor_paths_1.MessageDescriptorPath.enum, i++), sourceIdx);
            this.enums.push(anEnum);
        }
        this.messages = [];
        i = 0;
        for (const nestedDescriptor of descriptor.nestedTypeList) {
            const nested = new MessageImpl(st, nestedDescriptor, this, (0, source_code_index_1.pInfo)(pathInfo, descriptor_paths_1.MessageDescriptorPath.message, i++), sourceIdx);
            this.messages.push(nested);
        }
        this.oneofs = [];
        i = 0;
        for (const oneofDescriptor of descriptor.oneofDeclList) {
            const oneof = new one_of_1.OneofImpl(st, oneofDescriptor, this, (0, source_code_index_1.pInfo)(pathInfo, descriptor_paths_1.MessageDescriptorPath.oneof, i++), sourceIdx);
            this.oneofs.push(oneof);
        }
        this.fields = new field_1.FieldsImpl();
        i = 0;
        for (const fieldDescriptor of descriptor.fieldList) {
            const field = new field_1.FieldImpl(st, fieldDescriptor, this, (0, source_code_index_1.pInfo)(pathInfo, descriptor_paths_1.MessageDescriptorPath.field, i++), sourceIdx);
            this.fields.push(field);
        }
    }
    get isMapEntry() {
        return this.descriptor.options?.mapEntry === true;
    }
    get file() {
        return this.parent.file;
    }
    toJSON() {
        return {
            typeName: this.typeName,
            name: this.name,
            options: this.options.allOptions,
            fields: this.fields,
            oneofs: this.oneofs,
            messages: this.messages,
            enums: this.enums,
            isMapEntry: this.isMapEntry,
        };
    }
}
exports.MessageImpl = MessageImpl;
//# sourceMappingURL=message.js.map