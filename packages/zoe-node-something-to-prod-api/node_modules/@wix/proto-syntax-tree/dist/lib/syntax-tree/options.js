"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionsImpl = void 0;
const api_1 = require("../api");
const source_code_index_1 = require("./source-code-index");
const assert_1 = __importDefault(require("assert"));
class OptionsImpl {
    constructor(st, descOptions, parent, pathInfo, sourceIdx) {
        this.st = st;
        this.parent = parent;
        this.pathInfo = pathInfo;
        this.sourceIdx = sourceIdx;
        this.optionByNum = new Map();
        this.descOptions = descOptions;
    }
    get allOptions() {
        const result = [];
        const customOptions = this.descOptions.options?.customOptions;
        if (customOptions) {
            for (const fieldNumber in customOptions) {
                const opt = this.getOptionByNumber(Number.parseInt(fieldNumber));
                if (opt) {
                    result.push(opt);
                }
            }
        }
        return result.flat();
    }
    getOptions(extensionType) {
        const extension = this.st.findType(extensionType);
        if (extension && extension.typeName === api_1.TypeName.Extension && extension.optionType === this.descOptions.optionType) {
            const result = this.getOptionByNumber(extension.number);
            if (result !== undefined) {
                if (isArray(result)) {
                    return result;
                }
                else {
                    return Object.freeze([result]);
                }
            }
        }
        return Object.freeze([]);
    }
    getTypedOption(option) {
        (0, assert_1.default)(option.optionType === this.descOptions.optionType, 'invalid extension type');
        const result = this.getOptionByNumber(option.extensionNumber);
        if (result === undefined && option.repeated) {
            return Object.freeze([]);
        }
        return result;
    }
    getOptionByNumber(extensionNumber) {
        let cached = this.optionByNum.get(extensionNumber);
        if (!cached) {
            cached = { value: this.getOptionByNumberInternal(extensionNumber) };
            this.optionByNum.set(extensionNumber, cached);
        }
        return cached.value;
    }
    getOptionByNumberInternal(extensionNumber) {
        if (this.descOptions.options) {
            const value = this.descOptions.options.customOptions[extensionNumber];
            if (value !== undefined) {
                if (Array.isArray(value)) {
                    return Object.freeze(value.map((val, idx) => new OptionImpl(this.st, extensionNumber, this.descOptions.optionType, val, this.parent, this.pathInfo, this.sourceIdx, idx)));
                }
                else {
                    return new OptionImpl(this.st, extensionNumber, this.descOptions.optionType, value, this.parent, this.pathInfo, this.sourceIdx);
                }
            }
        }
    }
}
exports.OptionsImpl = OptionsImpl;
class OptionImpl {
    constructor(st, extensionNumber, optionType, value, parent, pathInfo, sourceIdx, idx) {
        this.st = st;
        this.extensionNumber = extensionNumber;
        this.optionType = optionType;
        this.sourceIdx = sourceIdx;
        this.idx = idx;
        this._value = deepFreeze(value);
        this._parent = parent;
        this.pathInfo = (0, source_code_index_1.pInfo)(pathInfo, extensionNumber, idx);
    }
    get sourceCode() {
        return this.sourceIdx.getSourceCodeInfoByPathPrefix(this.pathInfo, this);
    }
    get file() {
        return this._parent.file;
    }
    get extension() {
        return this.st.getOptionByNumber(this.optionType, this.extensionNumber);
    }
    get value() {
        return this._value;
    }
    get fqn() {
        let result = `${this._parent.fqn}[${this.extension.fqn}]`;
        if (this.idx !== undefined) {
            result += `.${this.idx}`;
        }
        return result;
    }
    toJSON() {
        return {
            name: this.extension.fqn,
            value: this.value,
        };
    }
}
function deepFreeze(obj) {
    const object = obj;
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames) {
        const value = object[name];
        if (value && typeof value === 'object') {
            deepFreeze(value);
        }
    }
    return Object.freeze(obj);
}
function isArray(value) {
    return Array.isArray(value);
}
//# sourceMappingURL=options.js.map