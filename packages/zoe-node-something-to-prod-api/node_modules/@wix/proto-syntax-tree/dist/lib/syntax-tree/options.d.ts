import { Extension, OptionType, Option, Options, ProtoFile, RepeatedTypedOption, SourceCodeInfo, Type, TypedOption } from '../api';
import { SyntaxTreeImpl } from './index';
import { PathInfo, SourceCodeIndex } from './source-code-index';
import { CustomOptionsContainer } from '../descriptor';
interface DescriptorOptions<OT extends OptionType> {
    options?: CustomOptionsContainer;
    optionType: OT;
}
export declare class OptionsImpl<OT extends OptionType> implements Options<OT> {
    private readonly st;
    private readonly parent;
    private readonly pathInfo;
    private readonly sourceIdx;
    private readonly descOptions;
    private readonly optionByNum;
    constructor(st: SyntaxTreeImpl, descOptions: DescriptorOptions<OT>, parent: Type, pathInfo: PathInfo, sourceIdx: SourceCodeIndex);
    get allOptions(): Option[];
    getOptions(extensionType: string): readonly OptionImpl<any>[];
    getTypedOption<T>(option: TypedOption<OT, T>): Option<T> | undefined;
    getTypedOption<T>(option: RepeatedTypedOption<OT, T>): readonly Option<T>[];
    private getOptionByNumber;
    private getOptionByNumberInternal;
}
declare class OptionImpl<T> implements Option<T> {
    private readonly st;
    private readonly extensionNumber;
    private readonly optionType;
    private readonly sourceIdx;
    private readonly idx?;
    private readonly _parent;
    private readonly pathInfo;
    private readonly _value;
    constructor(st: SyntaxTreeImpl, extensionNumber: number, optionType: OptionType, value: T, parent: Type, pathInfo: PathInfo, sourceIdx: SourceCodeIndex, idx?: number | undefined);
    get sourceCode(): SourceCodeInfo;
    get file(): ProtoFile;
    get extension(): Extension;
    get value(): T;
    get fqn(): string;
    toJSON(): {
        name: string;
        value: T;
    };
}
export {};
