"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePbFileDescriptorSet = exports.parseFileDescriptorSet = void 0;
const assert_1 = __importDefault(require("assert"));
const pb = __importStar(require("google-protobuf/google/protobuf/descriptor_pb"));
const google_protobuf_1 = require("google-protobuf");
const debug_1 = __importDefault(require("debug"));
const descriptor_adapter_1 = require("./descriptor-adapter");
const miniPb = require('./mini_descriptor_pb').google.protobuf;
const srcLessPb = require('./srcless_descriptor_pb').google.protobuf;
const log = (0, debug_1.default)('wix:flynt:descriptor-parser');
function parseFileDescriptorSet(descriptorSetBytes, allSrcs = false) {
    return parsePbFileDescriptorSet(descriptorSetBytes, allSrcs).map(descriptor_adapter_1.asFileDescriptorSet);
}
exports.parseFileDescriptorSet = parseFileDescriptorSet;
function parsePbFileDescriptorSet(descriptorSetBytes, allSrcs = false) {
    const context = {
        msgCache: new Map(),
        deserCache: new Map(),
    };
    function cacheMessage(cacheKeyPrefix, msg) {
        const fqn = cacheKeyPrefix + '.' + msg.getName();
        context.msgCache.set(fqn, msg);
        for (const nested of msg.getNestedTypeList()) {
            cacheMessage(fqn, nested);
        }
    }
    log('parsing file descriptors - first pass');
    initExtendees();
    const firstPassDescriptors = descriptorSetBytes.map(ds => miniPb.FileDescriptorSet.deserializeBinary(ds));
    log('creating extensions');
    for (const firstPassFiles of firstPassDescriptors) {
        for (const file of firstPassFiles.getFileList()) {
            const pkgName = file.getPackage();
            const cacheKeyPrefix = pkgName ? `.${pkgName}` : '';
            for (const msg of file.getMessageTypeList()) {
                cacheMessage(cacheKeyPrefix, msg);
            }
            for (const extension of file.getExtensionList()) {
                createExtension(extension, context);
            }
        }
    }
    log('parsing file descriptors - second pass');
    if (allSrcs) {
        return descriptorSetBytes.map(ds => pb.FileDescriptorSet.deserializeBinary(ds));
    }
    else {
        const lastSet = descriptorSetBytes.pop();
        return descriptorSetBytes.map(ds => srcLessPb.FileDescriptorSet.deserializeBinary(ds))
            .concat(pb.FileDescriptorSet.deserializeBinary(lastSet));
    }
}
exports.parsePbFileDescriptorSet = parsePbFileDescriptorSet;
function getDeserializeFunction(typeName, context) {
    let result = context.deserCache.get(typeName);
    if (!result) {
        const msgType = context.msgCache.get(typeName);
        (0, assert_1.default)(msgType, `could not find ${typeName} in msgCache. This usually means descriptor sets were provided in the wrong order`);
        result = generateDeserializeFunction(msgType, context);
        context.deserCache.set(typeName, result);
    }
    return result;
}
function initFieldInfo(msgType, fieldInfoCache, context) {
    for (const field of msgType.getFieldList()) {
        const fieldInfo = getFieldInfo(field, context);
        fieldInfoCache.set(fieldInfo.fieldIndex, fieldInfo);
    }
}
function generateDeserializeFunction(msgType, context) {
    const fieldInfoCache = new Map();
    let fieldInfoInit = false;
    return function (msg, reader) {
        if (!fieldInfoInit) {
            fieldInfoInit = true;
            initFieldInfo(msgType, fieldInfoCache, context);
        }
        while (reader.nextField()) {
            if (reader.isEndGroup()) {
                break;
            }
            const fieldNumber = reader.getFieldNumber();
            (0, assert_1.default)(fieldNumber);
            const fieldInfo = fieldInfoCache.get(fieldNumber);
            (0, assert_1.default)(fieldInfo, `no field info cache for field number ${fieldNumber} in ${msgType.getName()}`);
            let value;
            if (fieldInfo.msgCtor) {
                (0, assert_1.default)(fieldInfo.binaryDeserializeFn);
                const MsgCtor = fieldInfo.msgCtor;
                value = new MsgCtor();
                fieldInfo.readerFunc.call(reader, value, fieldInfo.binaryDeserializeFn);
            }
            else {
                value = fieldInfo.readerFunc.call(reader);
            }
            msg.setFieldValue(fieldInfo, value);
        }
        return msg;
    };
}
class Option extends google_protobuf_1.Message {
    serializeBinary() {
        throw new Error('not implemented');
    }
    toObject() {
        return {};
    }
    setFieldValue(fieldInfo, value) {
        const fieldName = fieldInfo.jsonName;
        if (fieldInfo.isRepeated) {
            const currentVal = this[fieldName];
            if (!currentVal) {
                this[fieldName] = [value];
            }
            else {
                currentVal.push(value);
            }
        }
        else {
            this[fieldName] = value;
        }
    }
}
function getExtendee(extension, container) {
    switch (extension.getExtendee()) {
        case '.google.protobuf.FileOptions':
            return container.FileOptions;
        case '.google.protobuf.ServiceOptions':
            return container.ServiceOptions;
        case '.google.protobuf.MethodOptions':
            return container.MethodOptions;
        case '.google.protobuf.MessageOptions':
            return container.MessageOptions;
        case '.google.protobuf.EnumOptions':
            return container.EnumOptions;
        case '.google.protobuf.EnumValueOptions':
            return container.EnumValueOptions;
        case '.google.protobuf.FieldOptions':
            return container.FieldOptions;
        case '.google.protobuf.OneofOptions':
            return container.OneofOptions;
    }
}
function initExtendees() {
    function initExtendee(extendee) {
        extendee.extensions = {};
        extendee.extensionsBinary = {};
    }
    initExtendee(pb.FileOptions);
    initExtendee(pb.ServiceOptions);
    initExtendee(pb.MethodOptions);
    initExtendee(pb.MessageOptions);
    initExtendee(pb.EnumOptions);
    initExtendee(pb.EnumValueOptions);
    initExtendee(pb.FieldOptions);
    initExtendee(pb.OneofOptions);
}
function getFieldHandlerFuncs(fieldType, context) {
    switch (fieldType.getType()) {
        case pb.FieldDescriptorProto.Type.TYPE_DOUBLE:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readDouble };
        case pb.FieldDescriptorProto.Type.TYPE_FLOAT:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readFloat };
        case pb.FieldDescriptorProto.Type.TYPE_INT64:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readInt64 };
        case pb.FieldDescriptorProto.Type.TYPE_UINT64:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readUint64 };
        case pb.FieldDescriptorProto.Type.TYPE_INT32:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readInt32 };
        case pb.FieldDescriptorProto.Type.TYPE_FIXED64:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readFixed64 };
        case pb.FieldDescriptorProto.Type.TYPE_FIXED32:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readFixed32 };
        case pb.FieldDescriptorProto.Type.TYPE_BOOL:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readBool };
        case pb.FieldDescriptorProto.Type.TYPE_STRING:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readString };
        case pb.FieldDescriptorProto.Type.TYPE_GROUP:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.skipGroup };
        case pb.FieldDescriptorProto.Type.TYPE_MESSAGE:
            return {
                readerFunc: google_protobuf_1.BinaryReader.prototype.readMessage,
                msgCtor: Option,
                deserFunc: getDeserializeFunction(fieldType.getTypeName(), context)
            };
        case pb.FieldDescriptorProto.Type.TYPE_BYTES:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readBytes };
        case pb.FieldDescriptorProto.Type.TYPE_UINT32:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readUint32 };
        case pb.FieldDescriptorProto.Type.TYPE_ENUM:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readEnum };
        case pb.FieldDescriptorProto.Type.TYPE_SFIXED32:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readSfixed32 };
        case pb.FieldDescriptorProto.Type.TYPE_SFIXED64:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readSfixed64 };
        case pb.FieldDescriptorProto.Type.TYPE_SINT32:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readSint32 };
        case pb.FieldDescriptorProto.Type.TYPE_SINT64:
            return { readerFunc: google_protobuf_1.BinaryReader.prototype.readSint64 };
    }
}
function getFieldInfo(fieldDesc, context) {
    const funcs = getFieldHandlerFuncs(fieldDesc, context);
    (0, assert_1.default)(funcs, `no field info for ${fieldDesc.getName()}`);
    if ('msgCtor' in funcs) {
        return {
            readerFunc: funcs.readerFunc,
            fieldIndex: fieldDesc.getNumber(),
            fieldName: fieldDesc.getName(),
            jsonName: fieldDesc.getJsonName(),
            msgCtor: funcs.msgCtor,
            isRepeated: fieldDesc.getLabel() === pb.FieldDescriptorProto.Label.LABEL_REPEATED,
            binaryDeserializeFn: funcs.deserFunc,
        };
    }
    else {
        return {
            readerFunc: funcs.readerFunc,
            fieldIndex: fieldDesc.getNumber(),
            fieldName: fieldDesc.getName(),
            jsonName: fieldDesc.getJsonName(),
            msgCtor: undefined,
            isRepeated: fieldDesc.getLabel() === pb.FieldDescriptorProto.Label.LABEL_REPEATED,
            binaryDeserializeFn: undefined,
        };
    }
}
function createExtension(extension, context) {
    const fieldInfo = getFieldInfo(extension, context);
    const extensionFieldInfo = new google_protobuf_1.ExtensionFieldInfo(fieldInfo.fieldIndex, { [fieldInfo.fieldName]: 0 }, fieldInfo.msgCtor, undefined, fieldInfo.isRepeated ? 1 : 0);
    const extensionFieldBinaryInfo = new google_protobuf_1.ExtensionFieldBinaryInfo(extensionFieldInfo, fieldInfo.readerFunc, undefined, undefined, fieldInfo.binaryDeserializeFn, false);
    const extendee = getExtendee(extension, pb);
    if (extendee) {
        extendee.extensions[extension.getNumber()] = extensionFieldInfo;
        extendee.extensionsBinary[extension.getNumber()] = extensionFieldBinaryInfo;
    }
    const srcLessExtendee = getExtendee(extension, srcLessPb);
    if (srcLessExtendee) {
        srcLessExtendee.extensions[extension.getNumber()] = extensionFieldInfo;
        srcLessExtendee.extensionsBinary[extension.getNumber()] = extensionFieldBinaryInfo;
    }
}
//# sourceMappingURL=descriptor-parser.js.map