export interface SyntaxTree {
    readonly files: readonly ProtoFile[];
    findType(fqn: string): Type | undefined;
    getType(fqn: string): Type;
    getFile(fqn: string): ProtoFile;
    getService(fqn: string): Service;
    getMethod(fqn: string): Method;
    getMessage(fqn: string): Message;
    getExtension(fqn: string): Extension;
    getEnum(fqn: string): Enum;
    getField(fqn: string): Field;
    getOneof(fqn: string): Oneof;
    getEnumValue(fqn: string): EnumValue;
}
export declare enum TypeName {
    File = "File",
    Service = "Service",
    Method = "Method",
    Message = "Message",
    Field = "Field",
    Oneof = "Oneof",
    Enum = "Enum",
    EnumValue = "EnumValue",
    Extension = "Extension"
}
export declare type Type = ProtoFile | Service | Method | Message | Field | Oneof | Enum | EnumValue | Extension;
export interface BaseType {
    readonly name: string;
    readonly fqn: string;
    readonly st: SyntaxTree;
    readonly sourceCode: SourceCodeInfo;
}
export interface ProtoFile extends BaseType {
    readonly typeName: TypeName.File;
    readonly file: ProtoFile;
    readonly path: string;
    readonly package: string;
    readonly messages: readonly Message[];
    readonly enums: readonly Enum[];
    readonly services: readonly Service[];
    readonly extensions: readonly Extension[];
    readonly options: Options<OptionType.FileOptions>;
    readonly protoFolder: ProtoFolderType;
    readonly detailedSourceCode: {
        readonly syntax: SourceCodeInfo;
        readonly package: SourceCodeInfo;
    };
}
export declare enum ProtoFolderType {
    MainProtoFolder = 0,
    IncludeProtoFolder = 1
}
export interface Service extends BaseType {
    readonly typeName: TypeName.Service;
    readonly file: ProtoFile;
    readonly parent: ProtoFile;
    readonly methods: readonly Method[];
    readonly options: Options<OptionType.ServiceOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
    };
}
export interface Method extends BaseType {
    readonly typeName: TypeName.Method;
    readonly file: ProtoFile;
    readonly parent: Service;
    readonly request: Message;
    readonly response: Message;
    readonly clientStreaming: boolean;
    readonly serverStreaming: boolean;
    readonly options: Options<OptionType.MethodOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
        readonly request: SourceCodeInfo;
        readonly response: SourceCodeInfo;
    };
}
export interface Fields extends ReadonlyArray<Field> {
    byName(fieldName: string): Field | undefined;
}
export interface Message extends BaseType {
    readonly typeName: TypeName.Message;
    readonly isMapEntry: boolean;
    readonly file: ProtoFile;
    readonly parent: ProtoFile | Message;
    readonly messages: readonly Message[];
    readonly enums: readonly Enum[];
    readonly fields: Fields;
    readonly oneofs: readonly Oneof[];
    readonly reserved: Reserved;
    readonly options: Options<OptionType.MessageOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
    };
}
export interface Field extends BaseType {
    readonly typeName: TypeName.Field;
    readonly file: ProtoFile;
    readonly parent: Message;
    readonly number: number;
    readonly oneof?: Oneof;
    readonly fieldType: FieldType;
    readonly options: Options<OptionType.FieldOptions>;
    readonly proto2Optional: boolean;
    readonly proto3Optional: boolean;
    readonly jsonName: string;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
        readonly label: SourceCodeInfo;
        readonly number: SourceCodeInfo;
        readonly type: SourceCodeInfo;
    };
}
export interface Oneof extends BaseType {
    readonly typeName: TypeName.Oneof;
    readonly file: ProtoFile;
    readonly parent: Message;
    readonly fields: readonly Field[];
    readonly options: Options<OptionType.OneofOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
    };
}
export interface Enum extends BaseType {
    readonly typeName: TypeName.Enum;
    readonly file: ProtoFile;
    readonly parent: ProtoFile | Message;
    readonly values: readonly EnumValue[];
    readonly reserved: Reserved;
    readonly options: Options<OptionType.EnumOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
    };
}
export interface EnumValue extends BaseType {
    readonly typeName: TypeName.EnumValue;
    readonly file: ProtoFile;
    readonly parent: Enum;
    readonly number: number;
    readonly options: Options<OptionType.EnumValueOptions>;
    readonly detailedSourceCode: {
        readonly name: SourceCodeInfo;
        readonly number: SourceCodeInfo;
    };
}
export declare type FieldType = PrimitiveFieldType | WrapperFieldType | EnumFieldType | MessageFieldType | RepeatedFieldType | MapFieldType;
export declare type ElementTypes = PrimitiveFieldType | WrapperFieldType | EnumFieldType | MessageFieldType;
export declare enum FieldKind {
    Primitive = "Primitive",
    Wrapper = "Wrapper",
    Enum = "Enum",
    Message = "Message",
    Repeated = "Repeated",
    Map = "Map"
}
export declare enum Primitives {
    DOUBLE = 1,
    FLOAT = 2,
    INT64 = 3,
    UINT64 = 4,
    INT32 = 5,
    FIXED64 = 6,
    FIXED32 = 7,
    BOOL = 8,
    STRING = 9,
    BYTES = 12,
    UINT32 = 13,
    SFIXED32 = 15,
    SFIXED64 = 16,
    SINT32 = 17,
    SINT64 = 18
}
export declare type WrapperTypes = Primitives.DOUBLE | Primitives.FLOAT | Primitives.INT32 | Primitives.INT64 | Primitives.UINT64 | Primitives.UINT32 | Primitives.BOOL | Primitives.STRING | Primitives.BYTES;
export declare type MapKeyTypes = Primitives.INT32 | Primitives.INT64 | Primitives.UINT64 | Primitives.UINT32 | Primitives.BOOL | Primitives.STRING | Primitives.SFIXED32 | Primitives.SFIXED64 | Primitives.SINT32 | Primitives.SINT64;
export interface PrimitiveFieldType {
    readonly kind: FieldKind.Primitive;
    readonly type: Primitives;
}
export interface WrapperFieldType {
    readonly kind: FieldKind.Wrapper;
    readonly type: WrapperTypes;
    readonly message: Message;
}
export interface EnumFieldType {
    readonly kind: FieldKind.Enum;
    readonly enum: Enum;
}
export interface MessageFieldType {
    readonly kind: FieldKind.Message;
    readonly message: Message;
}
export interface RepeatedFieldType {
    readonly kind: FieldKind.Repeated;
    readonly elementType: ElementTypes;
}
export interface MapFieldType {
    readonly kind: FieldKind.Map;
    readonly keyType: MapKeyTypes;
    readonly valueType: ElementTypes;
}
export interface Reserved {
    isReservedNumber(num: number): boolean;
    isReservedName(name: string): boolean;
    readonly reservedNames: Iterable<string>;
    readonly reservedNumbers: Iterable<Range>;
}
export interface Range {
    start: number;
    end: number;
}
export declare type SourceCodeContainer = Type | Option;
export interface SourceCodeInfo {
    readonly container: SourceCodeContainer;
    readonly fqn: string;
    readonly leadingComments: string;
    readonly trailingComments: string;
    readonly leadingDetachedComments: readonly string[];
    readonly startLine: number;
    readonly startColumn: number;
    readonly endLine: number;
    readonly endColumn: number;
}
export declare enum OptionType {
    FileOptions = 1,
    ServiceOptions = 2,
    MethodOptions = 3,
    MessageOptions = 4,
    EnumOptions = 5,
    EnumValueOptions = 6,
    FieldOptions = 7,
    OneofOptions = 8
}
export interface Extension extends BaseType {
    readonly typeName: TypeName.Extension;
    readonly parent: ProtoFile;
    readonly file: ProtoFile;
    readonly optionType: OptionType | undefined;
    readonly number: number;
    readonly fieldType: FieldType;
}
export declare type BaseTypedOption<OT extends OptionType, _T> = {
    extensionNumber: number;
    optionType: OT;
};
export declare type TypedOption<OT extends OptionType, T> = BaseTypedOption<OT, T> & {
    repeated: false;
};
export declare type RepeatedTypedOption<OT extends OptionType, T> = BaseTypedOption<OT, T> & {
    repeated: true;
};
export interface Options<OT extends OptionType> {
    readonly allOptions: readonly Option[];
    getOptions(extensionType: string): readonly Option[];
    getTypedOption<T>(option: TypedOption<OT, T>): Option<T> | undefined;
    getTypedOption<T>(option: RepeatedTypedOption<OT, T>): readonly Option<T>[];
}
export interface Option<T = any> {
    readonly fqn: string;
    readonly extension: Extension;
    readonly file: ProtoFile;
    readonly sourceCode: SourceCodeInfo;
    readonly value: T;
}
