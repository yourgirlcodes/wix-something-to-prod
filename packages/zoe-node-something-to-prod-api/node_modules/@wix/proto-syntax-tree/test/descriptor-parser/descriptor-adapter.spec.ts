import {generateBinaryFileDescriptor} from '@wix/flynt-protoc';
import {parseFileDescriptorSet} from '../../lib/descriptor-parser/descriptor-parser';
import {FileDescriptorProto, FileDescriptorSet, FileOptions} from '../../lib/descriptor';
import {generateSyntaxTreeFromDescriptorSets, getStdIncludeProtos} from '../../lib';
import {FieldDescriptorProto} from 'google-protobuf/google/protobuf/descriptor_pb';
import Type = FieldDescriptorProto.Type;
import Label = FieldDescriptorProto.Label;
import {SyntaxTree} from '../../lib/api';

export async function genDescriptor(mainProtoFolder: string) {
  const buffer = await generateBinaryFileDescriptor(mainProtoFolder, {include: ['./include']});
  return buffer;
}

describe('parseFileDescriptorSet', () => {
  describe('simple options', () => {
    describe('parsing', () => {
      let fileOptions: FileOptions;

      beforeAll(async () => {
        const fdsBytes = await genDescriptor('./test/modules/descriptor-parser/simple-options');
        const fileDescriptor = item(parseFileDescriptorSet([fdsBytes])[0].fileList, 1);
        fileOptions = fileDescriptor.options!;
      });

      describe('primitives', () => {
        it('TYPE_DOUBLE', async () => {
          const optionValue = fileOptions.customOptions[20001];
          expect(optionValue).toEqual(2000.1);
        });

        it('TYPE_FLOAT', async () => {
          const optionValue = fileOptions.customOptions[20002];
          expect(optionValue).toBeCloseTo(2.0002, 5);
        });

        it('TYPE_INT64', async () => {
          const optionValue = fileOptions.customOptions[20003];
          expect(optionValue).toEqual(-20003);
        });

        it('TYPE_UINT64', async () => {
          const optionValue = fileOptions.customOptions[20004];
          expect(optionValue).toEqual(20004);
        });

        it('TYPE_INT32', async () => {
          const optionValue = fileOptions.customOptions[20005];
          expect(optionValue).toEqual(-20005);
        });

        it('TYPE_FIXED64', async () => {
          const optionValue = fileOptions.customOptions[20006];
          expect(optionValue).toEqual(20006);
        });

        it('TYPE_FIXED32', async () => {
          const optionValue = fileOptions.customOptions[20007];
          expect(optionValue).toEqual(20007);
        });

        it('TYPE_BOOL', async () => {
          const optionValue = fileOptions.customOptions[20008];
          expect(optionValue).toEqual(true);
        });

        it('TYPE_STRING', async () => {
          const optionValue = fileOptions.customOptions[20009];
          expect(optionValue).toEqual('20009');
        });

        it('TYPE_BYTES', async () => {
          const optionValue = fileOptions.customOptions[20010];
          expect(optionValue).toEqual(Uint8Array.from(Buffer.from('20010')));
        });

        it('TYPE_UINT32', async () => {
          const optionValue = fileOptions.customOptions[20011];
          expect(optionValue).toEqual(20011);
        });

        it('TYPE_ENUM', async () => {
          const optionValue = fileOptions.customOptions[20012];
          expect(optionValue).toEqual(1);
        });

        it('TYPE_SFIXED32', async () => {
          const optionValue = fileOptions.customOptions[20013];
          expect(optionValue).toEqual(20013);
        });

        it('TYPE_SFIXED64', async () => {
          const optionValue = fileOptions.customOptions[20014];
          expect(optionValue).toEqual(20014);
        });

        it('TYPE_SINT32', async () => {
          const optionValue = fileOptions.customOptions[20015];
          expect(optionValue).toEqual(-20015);
        });

        it('TYPE_SINT64', async () => {
          const optionValue = fileOptions.customOptions[20016];
          expect(optionValue).toEqual(-20016);
        });
      });

      describe('repeated', () => {
        it('TYPE_STRING', async () => {
          const optionValue = fileOptions.customOptions[30009];
          expect(optionValue).toEqual(['30009.1', '30009.2', '30009.3']);
        });

        it('TYPE_ENUM', async () => {
          const optionValue = fileOptions.customOptions[30012];
          expect(optionValue).toEqual([2]);
        });
      });

      describe('option iteration', () => {
        it('returns all options', async () => {
          const optkeys = [];
          for (const opt in fileOptions.customOptions) {
            optkeys.push(opt);
          }
          expect(optkeys).toEqual(['20001', '20002', '20003', '20004', '20005', '20006', '20007', '20008', '20009', '20010',
            '20011', '20012', '20013', '20014', '20015', '20016', '30009', '30012']);
          expect(Object.keys(fileOptions.customOptions)).toEqual(optkeys);
        });
      });
    });

    describe('option locations', () => {
      let file: FileDescriptorProto;

      beforeAll(async () => {
        const fdsBytes = await genDescriptor('./test/modules/descriptor-parser/all-option-locations');
        file = item(parseFileDescriptorSet([fdsBytes])[0].fileList, 2);
      });

      it('file', async () => {
        const optionValue = file.options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('service', async () => {
        const optionValue = item(file.serviceList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('method', async () => {
        const optionValue = item(item(file.serviceList, 0).methodList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('message', async () => {
        const optionValue = item(file.messageTypeList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('field', async () => {
        const optionValue = item(item(file.messageTypeList, 0).fieldList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('enum', async () => {
        const optionValue = item(file.enumTypeList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('enumValue', async () => {
        const optionValue = item(item(file.enumTypeList, 0).valueList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });

      it('Oneof', async () => {
        const optionValue = item(item(file.messageTypeList, 0).oneofDeclList, 0).options!.customOptions[40000];
        expect(optionValue).toEqual('xyz');
      });
    });
  });

  describe('complex options', () => {
    let file: FileDescriptorProto;

    beforeAll(async () => {
      const fdsBytes = await genDescriptor('./test/modules/descriptor-parser/complex-options');
      const fds = parseFileDescriptorSet([fdsBytes])[0].fileList;
      file = item(fds, 2);
    });

    it('message', async () => {
      const optionValue = file.options!.customOptions[40000];
      expect(optionValue).toBeDefined();

      expect(optionValue['typeDouble']).toEqual(2000.1);
      expect(optionValue['typeFloat']).toBeCloseTo(2.0002, 5);
      expect(optionValue['typeInt64']).toEqual(-20003);
      expect(optionValue['typeUint64']).toEqual(20004);
      expect(optionValue['typeInt32']).toEqual(-20005);
      expect(optionValue['typeFixed64']).toEqual(20006);
      expect(optionValue['typeFixed32']).toEqual(20007);
      expect(optionValue['typeBool']).toEqual(true);
      expect(optionValue['typeString']).toEqual('20009');
      expect(optionValue['typeBytes']).toEqual(Uint8Array.from(Buffer.from('20010')));
      expect(optionValue['typeUint32']).toEqual(20011);
      expect(optionValue['typeEnum']).toEqual(1);
      expect(optionValue['typeSfixed32']).toEqual(20013);
      expect(optionValue['typeSfixed64']).toEqual(20014);
      expect(optionValue['typeSint32']).toEqual(-20015);
      expect(optionValue['typeSint64']).toEqual(-20016);
      expect(optionValue['repeatedString']).toEqual(['a', 'b', 'c', 'd']);
      expect(optionValue['complex']).toEqual({
        'typeSint64': -20016
      });
      expect(optionValue['emptyRepeatedInt']).toBeUndefined();
    });
  });

  describe('json serialization', () => {
    describe('basic functionality', () => {
      const mainProtoFolder = './test/modules/small';
      let descriptors: FileDescriptorSet[];
      let jsonDescriptors: FileDescriptorSet[];
      let mainFileDescriptor: FileDescriptorProto;
      let jsonMainFileDescriptor: FileDescriptorProto;

      beforeAll(async () => {
        const fdsBytes = await generateBinaryFileDescriptor(mainProtoFolder, {include: ['./include']});
        descriptors = parseFileDescriptorSet([fdsBytes]);
        jsonDescriptors = JSON.parse(JSON.stringify(descriptors, null, 1)) as FileDescriptorSet[];
        mainFileDescriptor = last(descriptors[0].fileList);
        jsonMainFileDescriptor = JSON.parse(JSON.stringify(mainFileDescriptor, null, 1));
      });

      it('json stringify', async () => {
        const json = JSON.stringify(mainFileDescriptor, null, 1);
        expect(json).not.toMatch(/"descriptor"/);
        expect(json).not.toMatch(/wrappers_/);
        expect(json).not.toMatch(/extensionObject_/);
      });

      it('json stringify/parse', async () => {
        expect(jsonMainFileDescriptor).toEqual(expect.objectContaining<FileDescriptorProto>({
          name: 'messages.proto',
          package: 'com.wix',
          syntax: 'proto3',
          extensionList: [],
          messageTypeList: [{
            name: 'SomeMessage',
            options: {
              customOptions: {
                '30000': [{'length': 500, 'name': 'my_name'}],
              },
            },
            enumTypeList: [],
            fieldList: [{
              name: 'str_value',
              type: Type.TYPE_STRING,
              number: 666,
              label: Label.LABEL_OPTIONAL,
              jsonName: 'strValue',
            }],
            extensionList: [],
            extensionRangeList: [],
            nestedTypeList: [],
            oneofDeclList: [],
            reservedNameList: [],
            reservedRangeList: []
          }],
          enumTypeList: [],
          serviceList: [],
        }));
      });

      it('stringify properties in sorted order', async () => {
        const msg = first(mainFileDescriptor.messageTypeList);
        const json = JSON.stringify(msg, null, 1);
        expect(json.indexOf('"name"')).toBeGreaterThan(json.indexOf('"fieldList"'));
      });

      it('stringify options', async () => {
        const opts = first(mainFileDescriptor.messageTypeList).options!;
        const json = JSON.stringify(opts.customOptions, null, 1);
        expect(json).toMatch(/30000/);
        expect(json).not.toMatch(/40001/);
        expect(json).not.toMatch(/40002/);
        expect(json).not.toMatch(/40003/);
        expect(json).not.toMatch(/40004/);
      });

      describe('syntax tree', () => {
        let stFromDescriptors: SyntaxTree;
        let strFromJsonDescriptors: SyntaxTree;

        beforeAll(() => {
          stFromDescriptors = generateSyntaxTreeFromDescriptorSets(descriptors, mainProtoFolder);
          strFromJsonDescriptors = generateSyntaxTreeFromDescriptorSets(jsonDescriptors, mainProtoFolder);
        });

        it('tree created from json serialized descriptor is equal to tree created from descriptors', async () => {
          const stJson = JSON.stringify(stFromDescriptors, null, 1);
          const stFromJsonJson = JSON.stringify(strFromJsonDescriptors, null, 1);

          expect(stFromJsonJson).toEqual(stJson);
        });

        it('sourceCode', async () => {
          const scFromDescriptors = stFromDescriptors.getMessage('.com.wix.SomeMessage').sourceCode;
          const scFromJsonDescriptors = strFromJsonDescriptors.getMessage('.com.wix.SomeMessage').sourceCode;
          expect(scFromJsonDescriptors.startLine).toStrictEqual(scFromDescriptors.startLine);
          expect(scFromJsonDescriptors.endColumn).toStrictEqual(scFromDescriptors.endColumn);
        });

        it('without source code', async () => {
          function excludeSourceCode(key: string, value: any) {
            if (key !== 'sourceCodeInfo') {
              return value;
            }
          }

          const jsonDescriptorsWithoutSource = JSON.parse(JSON.stringify(descriptors, excludeSourceCode, 1)) as FileDescriptorSet[];
          const stWithoutSource = generateSyntaxTreeFromDescriptorSets(jsonDescriptorsWithoutSource, mainProtoFolder);
          expect(() => stWithoutSource.getMessage('.com.wix.SomeMessage').sourceCode).toThrow(/no source code info/);
        });

      });
    });

    describe('complex', () => {
      const mainProtoFolder = './test/modules/complex/src/main/proto';
      let descriptors: FileDescriptorSet[];
      let jsonDescriptors: FileDescriptorSet[];
      let descriptor: FileDescriptorSet;
      let jsonDescriptor: FileDescriptorSet;

      beforeAll(async () => {
        const fdsBytes = await generateBinaryFileDescriptor(mainProtoFolder, {include: [
          ...getStdIncludeProtos(),
          './test/modules/complex/protos-common/src/main/proto',
          './test/modules/complex/protos-query/src/main/proto',
          './test/modules/complex/schedule-api/src/main/proto',
          './test/modules/complex/common-api/src/main/proto',
          './test/modules/complex/locations-web/proto',
          './test/modules/complex/site-properties-api-proto/src/main/proto',
        ]});
        descriptors = parseFileDescriptorSet([fdsBytes]);
        jsonDescriptors = JSON.parse(JSON.stringify(descriptors, null, 1)) as FileDescriptorSet[];
        descriptor = descriptors[0];
        jsonDescriptor = jsonDescriptors[0];
      });

      it('json stringify/parse sanity', async () => {
        function checkEquals<T>(fn: (fds: FileDescriptorSet) => T) {
          const expected: T = fn(descriptor);
          const actual: T = fn(jsonDescriptor);
          expect(actual).toEqual(expected);
        }

        checkEquals(d => length(d.fileList));
        checkEquals(d => last(d.fileList).name);
        checkEquals(d => last(d.fileList).package);
        checkEquals(d => length(last(d.fileList).messageTypeList));
        checkEquals(d => last(last(d.fileList).messageTypeList).name);
        checkEquals(d => first(last(last(d.fileList).messageTypeList).fieldList).type);
        checkEquals(d => first(last(last(d.fileList).messageTypeList).fieldList).oneofIndex);
      });

      it('tree created from json serialized descriptor is equal to tree created from descriptors', async () => {
        const stFromDescriptors = generateSyntaxTreeFromDescriptorSets(descriptors, mainProtoFolder);
        const strFromJsonDescriptors = generateSyntaxTreeFromDescriptorSets(jsonDescriptors, mainProtoFolder);

        const stJson = JSON.stringify(stFromDescriptors, null, 1);
        const stFromJsonJson = JSON.stringify(strFromJsonDescriptors, null, 1);

        expect(stFromJsonJson).toEqual(stJson);
      });
    });

    describe('very complex', () => {
      const mainProtoFolder = './test/modules/very-complex';
      let descriptors: FileDescriptorSet[];
      let jsonDescriptors: FileDescriptorSet[];

      beforeAll(async () => {
        const fdsBytes = await generateBinaryFileDescriptor(mainProtoFolder, {include: [
          './include',
          './test/google-includes'
        ]});
        descriptors = parseFileDescriptorSet([fdsBytes]);
        jsonDescriptors = JSON.parse(JSON.stringify(descriptors, null, 1)) as FileDescriptorSet[];
      });

      it('tree created from json serialized descriptor is equal to tree created from descriptors', async () => {
        const stFromDescriptors = generateSyntaxTreeFromDescriptorSets(descriptors, mainProtoFolder);
        const strFromJsonDescriptors = generateSyntaxTreeFromDescriptorSets(jsonDescriptors, mainProtoFolder);

        const stJson = JSON.stringify(stFromDescriptors, null, 1);
        const stFromJsonJson = JSON.stringify(strFromJsonDescriptors, null, 1);

        expect(stFromJsonJson).toEqual(stJson);
      });
    });
  });
});

function item<T>(iterable: Iterable<T>, index: number): T {
  let i = 0;
  for (const item of iterable) {
    if (i === index) {
      return item;
    }
    i++;
  }
  throw new Error(`item ${index} not found`);
}

function first<T>(iterable: Iterable<T>): T {
  for (const item of iterable) {
    return item;
  }
  throw new Error('empty iterable');
}

function last<T>(iterable: Iterable<T>): T {
  let found = false;
  let last: T;
  for (const item of iterable) {
    found = true;
    last = item;
  }
  if (!found) {
    throw new Error('empty iterable');
  }
  return last!;
}

function length<T>(iterable: Iterable<T>): number {
  let i = 0;
  for (const _ of iterable) {
    i++;
  }
  return i;
}
