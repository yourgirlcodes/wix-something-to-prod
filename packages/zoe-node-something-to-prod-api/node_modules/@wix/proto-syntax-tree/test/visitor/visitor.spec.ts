import {genSt, LoggingVisitor, proto} from '../test-utils';
import {generateSyntaxTreeFromSource} from '../../lib';
import {SyntaxTree} from '../../lib/api';
import {visitSyntaxTree, visitSyntaxTreeFrom} from '../../lib/visitor';

describe('visitor', function () {

  describe('single file', () => {

    let st: SyntaxTree;

    beforeAll(async () => {
      st = await genSt(proto`
      service Service {
        rpc Method (Message) returns (Message) {
        }
        rpc Method1 (Message) returns (Message) {
        }
      }

      message Message {
        oneof one_of {
          int32 field = 1;
        }

        message NestedMessage {
        }

        enum NestedEnum {
           NESTED_VAL = 0;
        }
      }

      message Message2 {

      }

      enum Enum {
        VAL = 0;
      }
      `);
    });

    it('visits all elements', async () => {
      const visitor = new LoggingVisitor();
      visitSyntaxTree(st, visitor);
      expect(visitor.visited).toEqual([
        'singleFile.proto [File]',
        '.foo.bar.Service [Service]',
        '.foo.bar.Service.Method [Method]',
        '.foo.bar.Service.Method1 [Method]',
        '.foo.bar.Message [Message]',
        '.foo.bar.Message.NestedMessage [Message]',
        '.foo.bar.Message.NestedEnum [Enum]',
        '.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]',
        '.foo.bar.Message.one_of [Oneof]',
        '.foo.bar.Message.field [Field]',
        '.foo.bar.Message2 [Message]',
        '.foo.bar.Enum [Enum]',
        '.foo.bar.Enum.VAL [EnumValue]',
      ]);
    });

    describe('branch skipping', () => {
      it('skip file should skip all', () => {
        const visitor = new LoggingVisitor();
        visitor.visitFile = () => false;
        visitSyntaxTree(st, visitor);
        expect(visitor.visited).toEqual([
        ]);
      });

      it('skip service should skip methods', () => {
        const visitor = new LoggingVisitor();
        visitor.visitService = () => false;
        visitSyntaxTree(st, visitor);
        expect(visitor.visited).toEqual([
          'singleFile.proto [File]',
          '.foo.bar.Message [Message]',
          '.foo.bar.Message.NestedMessage [Message]',
          '.foo.bar.Message.NestedEnum [Enum]',
          '.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]',
          '.foo.bar.Message.one_of [Oneof]',
          '.foo.bar.Message.field [Field]',
          '.foo.bar.Message2 [Message]',
          '.foo.bar.Enum [Enum]',
          '.foo.bar.Enum.VAL [EnumValue]',
        ]);
      });

      it('skip message should skip nested messages, nested enums, fields, and oneofs', () => {
        const visitor = new LoggingVisitor();
        visitor.visitMessage = () => false;
        visitSyntaxTree(st, visitor);
        expect(visitor.visited).toEqual([
          'singleFile.proto [File]',
          '.foo.bar.Service [Service]',
          '.foo.bar.Service.Method [Method]',
          '.foo.bar.Service.Method1 [Method]',
          '.foo.bar.Enum [Enum]',
          '.foo.bar.Enum.VAL [EnumValue]',
        ]);
      });

      it('skip enum should skip enum values', () => {
        const visitor = new LoggingVisitor();
        visitor.visitEnum = () => false;
        visitSyntaxTree(st, visitor);
        expect(visitor.visited).toEqual([
          'singleFile.proto [File]',
          '.foo.bar.Service [Service]',
          '.foo.bar.Service.Method [Method]',
          '.foo.bar.Service.Method1 [Method]',
          '.foo.bar.Message [Message]',
          '.foo.bar.Message.NestedMessage [Message]',
          '.foo.bar.Message.one_of [Oneof]',
          '.foo.bar.Message.field [Field]',
          '.foo.bar.Message2 [Message]',
        ]);
      });

      it('does not skip sibling branches', () => {
        const visitor = new LoggingVisitor(['.foo.bar.Message']);
        visitSyntaxTree(st, visitor);
        expect(visitor.visited).toEqual([
          'singleFile.proto [File]',
          '.foo.bar.Service [Service]',
          '.foo.bar.Service.Method [Method]',
          '.foo.bar.Service.Method1 [Method]',
          '.foo.bar.Message2 [Message]', //Sibling of .foo.bar.Message is still iterated
          '.foo.bar.Enum [Enum]',
          '.foo.bar.Enum.VAL [EnumValue]',
        ]);
      });

    });

    describe('visit partial hierarchy', () => {
      it('starts from file', async () => {
        const visitor = new LoggingVisitor();
        visitSyntaxTreeFrom(st.getFile('singleFile.proto'), visitor);
        expect(visitor.visited).toEqual([
          'singleFile.proto [File]',
          '.foo.bar.Service [Service]',
          '.foo.bar.Service.Method [Method]',
          '.foo.bar.Service.Method1 [Method]',
          '.foo.bar.Message [Message]',
          '.foo.bar.Message.NestedMessage [Message]',
          '.foo.bar.Message.NestedEnum [Enum]',
          '.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]',
          '.foo.bar.Message.one_of [Oneof]',
          '.foo.bar.Message.field [Field]',
          '.foo.bar.Message2 [Message]',
          '.foo.bar.Enum [Enum]',
          '.foo.bar.Enum.VAL [EnumValue]',
        ]);
      });

      it('starts from service', async () => {
        const visitor = new LoggingVisitor();
        visitSyntaxTreeFrom(st.getService('.foo.bar.Service'), visitor);
        expect(visitor.visited).toEqual([
          '.foo.bar.Service [Service]',
          '.foo.bar.Service.Method [Method]',
          '.foo.bar.Service.Method1 [Method]',
        ]);
      });

      it('starts from message', async () => {
        const visitor = new LoggingVisitor();
        visitSyntaxTreeFrom(st.getMessage('.foo.bar.Message'), visitor);
        expect(visitor.visited).toEqual([
          '.foo.bar.Message [Message]',
          '.foo.bar.Message.NestedMessage [Message]',
          '.foo.bar.Message.NestedEnum [Enum]',
          '.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]',
          '.foo.bar.Message.one_of [Oneof]',
          '.foo.bar.Message.field [Field]',
        ]);
      });

      it('starts from enum', async () => {
        const visitor = new LoggingVisitor();
        visitSyntaxTreeFrom(st.getEnum('.foo.bar.Enum'), visitor);
        expect(visitor.visited).toEqual([
          '.foo.bar.Enum [Enum]',
          '.foo.bar.Enum.VAL [EnumValue]',
        ]);
      });
    });
  });

  it('visits elements across files', async () => {
    const st = await generateSyntaxTreeFromSource('./test/modules/visitor');
    const visitor = new LoggingVisitor(['google/protobuf/descriptor.proto']);
    visitSyntaxTree(st, visitor);
    expect(visitor.visited).toEqual([
      'messages.proto [File]',
      '.com.wix.Message [Message]',
      'options.proto [File]',
      '.options.file [Extension]',
      'service.proto [File]',
      '.com.wix.Service [Service]',
      '.com.wix.Service.Method [Method]',
    ]);
  });


});
