import {genSt, LoggingVisitor, proto} from '../test-utils';
import {Enum, EnumValue, Field, SyntaxTree} from '../../lib/api';
import {skip, Skipper, Visitor, visitSyntaxTree} from '../../lib/visitor';

describe('skipper', function () {

  let st: SyntaxTree;

  beforeAll(async () => {
    st = await genSt(proto`
    message Message {
      oneof one_of {
        int32 field = 1;
        int32 field_2 = 2;
      }
    }

    message Message2 {
    }

    enum Enum {
      VAL = 0;
      VAL_1 = 1;
      VAL_2 = 2;
    }
    `);
  });

  it('keeps current behavior if skipper is empty', async () => {
    const visitor = new LoggingVisitor();
    visitSyntaxTree(st, skip(visitor, {}));
    expect(visitor.visited).toEqual([
      'singleFile.proto [File]',
      '.foo.bar.Message [Message]',
      '.foo.bar.Message.one_of [Oneof]',
      '.foo.bar.Message.field [Field]',
      '.foo.bar.Message.field_2 [Field]',
      '.foo.bar.Message2 [Message]',
      '.foo.bar.Enum [Enum]',
      '.foo.bar.Enum.VAL [EnumValue]',
      '.foo.bar.Enum.VAL_1 [EnumValue]',
      '.foo.bar.Enum.VAL_2 [EnumValue]',
    ]);
  });

  it('skips all fields', async () => {
    const visitor = new LoggingVisitor();
    const skipper = skip(visitor, {
      visitField(): boolean {
        return false;
      }
    });
    visitSyntaxTree(st, skipper);
    expect(visitor.visited).toEqual([
      'singleFile.proto [File]',
      '.foo.bar.Message [Message]',
      '.foo.bar.Message.one_of [Oneof]',
      '.foo.bar.Message2 [Message]',
      '.foo.bar.Enum [Enum]',
      '.foo.bar.Enum.VAL [EnumValue]',
      '.foo.bar.Enum.VAL_1 [EnumValue]',
      '.foo.bar.Enum.VAL_2 [EnumValue]',
    ]);
  });

  it('skips field and enum values with digits', async () => {
    const visitor = new LoggingVisitor();
    const skipper = skip(visitor, {
      visitField(field: Field) {
        if (field.name.match(/\d/)) {
          return false;
        }
      },

      visitEnumValue(enumValue: EnumValue) {
        if (enumValue.name.match(/\d/)) {
          return false;
        }
      },

    });
    visitSyntaxTree(st, skipper);
    expect(visitor.visited).toEqual([
      'singleFile.proto [File]',
      '.foo.bar.Message [Message]',
      '.foo.bar.Message.one_of [Oneof]',
      '.foo.bar.Message.field [Field]',
      '.foo.bar.Message2 [Message]',
      '.foo.bar.Enum [Enum]',
      '.foo.bar.Enum.VAL [EnumValue]',
    ]);
  });

  it('skips according to both skipper and visitor rules', async () => {
    const visitor = new LoggingVisitor(['.foo.bar.Message']);
    const skipper = skip(visitor, {
      visitEnum(_t: Enum) {
        return false;
      },
    });
    visitSyntaxTree(st, skipper);
    expect(visitor.visited).toEqual([
      'singleFile.proto [File]',
      '.foo.bar.Message2 [Message]',
    ]);
  });

  it('skips entire hierarchy if skipper skips it', async () => {
    const fields: string[] = [];
    const fieldVisitor: Visitor = {
      visitField(field: Field) {
        fields.push(field.name);
      }
    };

    visitSyntaxTree(st, fieldVisitor);
    expect(fields).not.toEqual([]);

    const msgSkipper: Skipper = {
      visitMessage() {
        return false;
      }
    };

    fields.length = 0;
    visitSyntaxTree(st, skip(fieldVisitor, msgSkipper));
    expect(fields).toEqual([]);
  });

});
