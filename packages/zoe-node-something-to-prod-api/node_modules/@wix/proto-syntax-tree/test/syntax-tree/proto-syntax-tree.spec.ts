import {generateSyntaxTreeFrom, generateSyntaxTreeFromDescriptorFiles, generateSyntaxTreeFromDescriptorSets, generateSyntaxTreeFromSource, getStdIncludeProtos} from '../../lib';
import {
  EnumValue,
  Extension,
  OptionType,
  FieldKind,
  FieldType,
  MessageFieldType,
  Method,
  Primitives,
  ProtoFolderType,
  SyntaxTree,
  TypeName
} from '../../lib/api';
import * as path from 'path';
import {RepeatedTypedOptions, TypedOptions} from '../../lib/syntax-tree/typed-options';
import {SyntaxTreeImpl} from '../../lib/syntax-tree';
import {readFile} from 'fs/promises';
import {parseFileDescriptorSet} from '../../lib/descriptor-parser/descriptor-parser';
import {getProtoFiles} from '@wix/flynt-protoc';

describe('generateSyntaxTree', function () {
  describe('simple proto file', () => {
    const mainProtoFolder = './test/modules/simple';
    const includeProtoFolder = './test/modules/include';
    const mainDescriptorFile = './test/modules/simple/fds/main.bin';
    const includeDescriptorFiles = [
      './test/modules/simple/fds/wrappers.bin',
      './test/modules/simple/fds/http.bin',
      './test/modules/simple/fds/descriptor.bin',
      './test/modules/simple/fds/annotations.bin',
      './test/modules/simple/fds/include.bin',
    ];

    const stData = [
      {
        name: 'via protoc',
        genTree: () => generateSyntaxTreeFromSource(mainProtoFolder, [includeProtoFolder])
      },
      {
        name: 'from descriptors',
        genTree: () => generateSyntaxTreeFromDescriptorFiles(mainDescriptorFile, mainProtoFolder, includeDescriptorFiles)
      },
      {
        name: 'from JSON descriptors',
        genTree: async () => {
          const descriptorFiles = [...includeDescriptorFiles, mainDescriptorFile];
          const descriptors = await Promise.all(descriptorFiles.map(fileName => readFile(fileName)));
          const fileDescriptorSet = parseFileDescriptorSet(descriptors);
          const json = JSON.stringify(fileDescriptorSet, null, 1);
          const jsonFileDescriptorSet = JSON.parse(json);
          return generateSyntaxTreeFromDescriptorSets(jsonFileDescriptorSet, mainProtoFolder);
        }
      }
    ];

    describe.each(stData)('generated $name', (test) => {
      let st: SyntaxTree;

      beforeAll(async () => {
        st = await test.genTree();
      });

      describe('getType', () => {
        it('should return all types', async () => {
          expect(st.getType('com/wix/messages.proto')).toHaveProperty('typeName', TypeName.File);
          expect(st.getType('.com.wix.SomeService')).toHaveProperty('typeName', TypeName.Service);
          expect(st.getType('.com.wix.SomeService.Method')).toHaveProperty('typeName', TypeName.Method);
          expect(st.getType('.com.wix.MethodRequest')).toHaveProperty('typeName', TypeName.Message);
          expect(st.getType('.com.wix.MethodRequest.int_32')).toHaveProperty('typeName', TypeName.Field);
          expect(st.getType('.com.wix.MethodResponse.one_of_tag')).toHaveProperty('typeName', TypeName.Oneof);
          expect(st.getType('.com.wix.SomeEnum')).toHaveProperty('typeName', TypeName.Enum);
          expect(st.getType('.com.wix.SomeEnum.VAL_1')).toHaveProperty('typeName', TypeName.EnumValue);
        });

        it('should return all types via type specific getter', async () => {
          expect(() => st.getFile('com/wix/messages.proto')).not.toThrow();
          expect(() => st.getService('.com.wix.SomeService')).not.toThrow();
          expect(() => st.getMethod('.com.wix.SomeService.Method')).not.toThrow();
          expect(() => st.getMessage('.com.wix.MethodRequest')).not.toThrow();
          expect(() => st.getField('.com.wix.MethodRequest.int_32')).not.toThrow();
          expect(() => st.getOneof('.com.wix.MethodResponse.one_of_tag')).not.toThrow();
          expect(() => st.getEnum('.com.wix.SomeEnum')).not.toThrow();
          expect(() => st.getEnumValue('.com.wix.SomeEnum.VAL_1')).not.toThrow();
        });

        it('should return types also from known imported protos', async () => {
          expect(st.getType('.google.protobuf.StringValue')).toHaveProperty('typeName', TypeName.Message);
        });

        it('should throw if getType does not find an entity', async () => {
          expect(() => st.getType('.fqn.666')).toThrow(/Type not found.*666/);
        });

        it('should return nested types', async () => {
          expect(st.getType('.com.wix.MethodResponse.SomeEnum')).toHaveProperty('typeName', TypeName.Enum);
          expect(st.getType('.com.wix.MethodResponse.NestedMessage')).toHaveProperty('typeName', TypeName.Message);
        });

        it('should throw if finds wrong type', async () => {
          expect(() => st.getField('.com.wix.SomeEnum.VAL_1')).toThrow(/Expected.*Field.*Enum/);
        });
      });

      describe('load', () => {
        it('loads all imported files', async () => {
          expect(st.files).toEqual(
            [
              expect.objectContaining({name: 'google/protobuf/wrappers.proto'}),
              expect.objectContaining({name: 'google/api/http.proto'}),
              expect.objectContaining({name: 'google/protobuf/descriptor.proto'}),
              expect.objectContaining({name: 'google/api/annotations.proto'}),
              expect.objectContaining({name: 'com/include/messages.proto'}),
              expect.objectContaining({name: 'com/wix/messages.proto'}),
              expect.objectContaining({name: 'com/wix/service.proto'}),
            ]
          );
        });

        it('correctly marks MainProtoFolder', async () => {
          [
            'com/wix/service.proto',
            'com/wix/messages.proto',
          ].forEach((fileName) => {
            const protoFile = st.getFile(fileName);
            expect(protoFile.protoFolder).toEqual(ProtoFolderType.MainProtoFolder);
            expect(protoFile.path).toEqual(path.resolve(mainProtoFolder, fileName));
          });
        });

        it('correctly marks IncludeProtoFolder', async () => {
          [
            'com/include/messages.proto',
            'google/api/annotations.proto',
            'google/protobuf/wrappers.proto',
          ].forEach((fileName) => {
            const protoFile = st.getFile(fileName);
            expect(protoFile.protoFolder).toEqual(ProtoFolderType.IncludeProtoFolder);
            expect(protoFile.path).toEqual(fileName);
          });
        });

        it('should load services', async () => {
          const protoFile = st.getFile('com/wix/service.proto');
          expect(protoFile.services).toEqual(
            [
              expect.objectContaining({
                name: 'SomeService',
                fqn: '.com.wix.SomeService',
              })
            ]
          );
        });

        it('should load service methods', async () => {
          const svc = st.getService('.com.wix.SomeService');
          expect(svc.methods).toEqual(
            [
              expect.objectContaining<Partial<Method>>({
                name: 'Method',
                fqn: '.com.wix.SomeService.Method',
              })]
          );
        });

        it('should load service method options', async () => {
          const method = st.getMethod('.com.wix.SomeOtherService.Method');
          const methodOptions = method.options.getOptions('.google.api.http');
          expect(methodOptions).toEqual(
            [
              expect.objectContaining({
                value: {
                  get: '/v1/method',
                },
                fqn: '.com.wix.SomeOtherService.Method[.google.api.http]',
              }),
            ]
          );
        });

        it('should load messages', async () => {
          const protoFile = st.getFile('com/wix/messages.proto');
          expect(protoFile.messages).toEqual(
            [
              expect.objectContaining({
                name: 'MethodRequest',
                fqn: '.com.wix.MethodRequest',
              }),
              expect.objectContaining({
                name: 'MethodResponse',
                fqn: '.com.wix.MethodResponse',
              })
            ]
          );
        });

        it('should load nested messages', async () => {
          const msg = st.getMessage('.com.wix.MethodResponse');
          expect(msg.messages).toEqual(
            [
              expect.objectContaining({
                name: 'NestedMessage',
                fqn: '.com.wix.MethodResponse.NestedMessage',
              })
            ]
          );
        });

        it('should load nested enums', async () => {
          const msg = st.getMessage('.com.wix.MethodResponse');
          expect(msg.enums).toEqual(
            [
              expect.objectContaining({
                name: 'SomeEnum',
                fqn: '.com.wix.MethodResponse.SomeEnum',
              })
            ]
          );
        });

        it('should load message fields', async () => {
          const msg = st.getMessage('.com.wix.MethodRequest');
          expect(msg.fields).toEqual(
            [
              expect.objectContaining({
                name: 'int_32',
                fqn: '.com.wix.MethodRequest.int_32',
              }),
              expect.objectContaining({
                name: 'str_value',
                fqn: '.com.wix.MethodRequest.str_value',
              }),
              expect.objectContaining({
                name: 'included_request',
                fqn: '.com.wix.MethodRequest.included_request',
              })
            ]
          );
        });

        it('should load message oneofs', async () => {
          const msg = st.getMessage('.com.wix.MethodResponse');
          expect(msg.oneofs).toEqual(
            [
              expect.objectContaining({
                name: 'one_of_tag',
                fqn: '.com.wix.MethodResponse.one_of_tag',
              })
            ]
          );
        });

        it('should load enums', async () => {
          const protoFile = st.getFile('com/wix/messages.proto');

          expect(protoFile.enums).toEqual(
            [
              expect.objectContaining({
                name: 'SomeEnum',
                fqn: '.com.wix.SomeEnum',
              }),
            ]
          );
        });

        it('should load enum values', async () => {
          const someEnum = st.getEnum('.com.wix.SomeEnum');
          expect(someEnum.values).toEqual(
            [
              expect.objectContaining<Partial<EnumValue>>({
                name: 'UNKNOWN',
                number: 0,
                fqn: '.com.wix.SomeEnum.UNKNOWN',
              }),
              expect.objectContaining({
                name: 'VAL_1',
                number: 1,
                fqn: '.com.wix.SomeEnum.VAL_1',
              }),
              expect.objectContaining({
                name: 'VAL_2',
                number: 2,
                fqn: '.com.wix.SomeEnum.VAL_2',
              }),
              expect.objectContaining({
                name: 'VAL_999',
                number: 999,
                fqn: '.com.wix.SomeEnum.VAL_999',
              }),
            ]
          );
        });
      });

      describe('include files', () => {
        it('finds types from include files', async () => {
          const svc = st.getService('.com.include.SomeIncludedService');
          expect(svc.methods).toEqual(
            [
              expect.objectContaining<Partial<Method>>({
                name: 'Method',
                fqn: '.com.include.SomeIncludedService.Method',
              })]
          );
        });

        it('should load options', async () => {
          const method = st.getMethod('.com.include.SomeIncludedService.Method');
          const methodOptions = method.options.getOptions('.google.api.http');
          expect(methodOptions).toEqual(
            [
              expect.objectContaining({
                value: {
                  get: '/v1/method',
                },
                fqn: '.com.include.SomeIncludedService.Method[.google.api.http]',
              }),
            ]
          );

        });
      });

      describe('file reference', () => {
        it('service should reference the containing packge', async () => {
          const svc = st.getService('.com.wix.SomeService');
          expect(svc.file).toBe(st.getFile('com/wix/service.proto'));
        });

        it('message should reference the containing packge', async () => {
          const msg = st.getMessage('.google.protobuf.StringValue');
          expect(msg.file).toBe(st.getFile('google/protobuf/wrappers.proto'));
        });

        it('nested message should reference the containing packge', async () => {
          const msg = st.getMessage('.com.wix.MethodResponse.NestedMessage');
          expect(msg.file).toBe(st.getFile('com/wix/messages.proto'));
        });

        it('enum should reference the containing packge', async () => {
          const someEnum = st.getEnum('.com.wix.SomeEnum');
          expect(someEnum.file).toBe(st.getFile('com/wix/messages.proto'));
        });

      });
    });
  });

  describe('complex proto file', () => {
    const mainProtoFolder = './test/modules/complex/src/main/proto';
    let st: SyntaxTree;

    beforeAll(async () => {
      st = await generateSyntaxTreeFrom({
        mainProtoFolder,
        protoFiles: await getProtoFiles(mainProtoFolder),
        include: [
          mainProtoFolder,
          './test/modules/complex/protos-common/src/main/proto',
          './test/modules/complex/protos-query/src/main/proto',
          './test/modules/complex/schedule-api/src/main/proto',
          './test/modules/complex/common-api/src/main/proto',
          './test/modules/complex/locations-web/proto',
          './test/modules/complex/site-properties-api-proto/src/main/proto',
        ],
        includeStdProtos: true,
      });
    });

    it('fails without stdProtos', async () => {
      await expect(generateSyntaxTreeFrom({
        mainProtoFolder,
        include: [
          './test/modules/complex/protos-common/src/main/proto',
          './test/modules/complex/protos-query/src/main/proto',
          './test/modules/complex/schedule-api/src/main/proto',
          './test/modules/complex/common-api/src/main/proto',
          './test/modules/complex/locations-web/proto',
          './test/modules/complex/site-properties-api-proto/src/main/proto',
        ],
        includeStdProtos: false,
      })).rejects.toThrow(/annotations.proto.*not found/);
    });

    it('works without stdProtos and explicitly including std proto folders', async () => {
      await expect(generateSyntaxTreeFrom({
        mainProtoFolder,
        include: [
          './test/modules/complex/protos-common/src/main/proto',
          './test/modules/complex/protos-query/src/main/proto',
          './test/modules/complex/schedule-api/src/main/proto',
          './test/modules/complex/common-api/src/main/proto',
          './test/modules/complex/locations-web/proto',
          './test/modules/complex/site-properties-api-proto/src/main/proto',
          ...getStdIncludeProtos(),
        ],
        includeStdProtos: false,
      })).resolves.not.toThrow();
    });

    it('loads and parses proto files', () => {
      const genMonitoringDashboardMethod = st.getMethod('.wix.api.funnel.builder.backoffice.BackofficeFlowService.GenerateMonitoringDashboard');
      expect(genMonitoringDashboardMethod.sourceCode.leadingComments).toContain('generates monitoring dashboard for published flow snapshot');
      const backofficePagesService = st.getFile('wix/api/funnel/builder/backoffice/backoffice-page-service.proto').services[0];
      const queryPagesMethod = backofficePagesService.methods[3];
      expect(queryPagesMethod.name).toEqual('QueryPages');
      const queryField = queryPagesMethod.request.fields[0];
      expect((queryField.fieldType as MessageFieldType).message).toBe(st.getMessage('.wix.common.QueryV2'));
    });

    it('marks files from main folder and provides real path', () => {
      [
        'wix/api/funnel/builder/backoffice/backoffice-flow-service.proto',
        'wix/api/funnel/builder/hydra/adi-service.proto',
        'wix/api/funnel/builder/backoffice/flow.proto',
        'wix/api/funnel/builder/v2/flow.proto'
      ].forEach(fileName => {
        const f = st.getFile(fileName);
        expect(f.protoFolder).toEqual(ProtoFolderType.MainProtoFolder);
        expect(f.path).toEqual(path.resolve(mainProtoFolder, fileName));
      });
    });

    it('marks files from include folder and does not provide real path', () => {
      [
        'com/wixpress/siteproperties/api/v4/properties.proto',
        'com/wixpress/locations/location.proto',
        'com/wix/bookings/common/api/v1/entities/paging.proto',
        'wix/common/paging.proto',
      ].forEach(fileName => {
        const f = st.getFile(fileName);
        expect(f.protoFolder).toEqual(ProtoFolderType.IncludeProtoFolder);
        expect(f.path).toEqual(fileName);
      });
    });
  });

  describe('no-package', () => {
    it('loads successfully', async () => {
      const st = await generateSyntaxTreeFromSource('./test/modules/no-package');
      expect(st.files).toHaveLength(2);
      expect(st.files[0].package).toEqual('');
      expect(st.files[1].package).toEqual('');
      expect(st.getMessage('.SomeMethodRequest')).toBeDefined();
      expect(st.getService('.Service')).toBeDefined();
    });
  });

  describe('extensions and options', () => {
    let st: SyntaxTree;

    beforeAll(async () => {
      st = await generateSyntaxTreeFromSource('./test/modules/options');
    });

    describe('extensions', () => {
      function checkExtension<T extends FieldType>(fqn: string, extType: OptionType, fieldType: T) {
        const ext = st.getExtension(fqn);
        expect(ext.optionType).toBe(extType);
        expect(ext.fieldType).toEqual(expect.objectContaining(fieldType));
        const sti = st as SyntaxTreeImpl;
        expect(sti.getOptionByNumber(extType, ext.number)).toEqual(ext);
      }

      it('loads extensions', () => {
        const file = st.getFile('foo/options.proto');
        //Check a few options
        expect(file.extensions.length).toEqual(10);
        expect(file.extensions).toContainEqual(
          expect.objectContaining<Partial<Extension>>({
            name: 'file',
            fqn: '.options.file',
            number: 20000,
            optionType: OptionType.FileOptions,
          })
        );
        expect(file.extensions).toContainEqual(
          expect.objectContaining<Partial<Extension>>({
            name: 'enum_value',
            fqn: '.options.enum_value',
            number: 50000,
            optionType: OptionType.EnumValueOptions,
          })
        );
      });

      it('file', () => {
        checkExtension('.options.file', OptionType.FileOptions, {
          kind: FieldKind.Primitive,
          type: Primitives.INT32
        });
      });

      it('service', () => {
        checkExtension('.options.service', OptionType.ServiceOptions, {
          kind: FieldKind.Repeated,
          elementType: expect.objectContaining({
            kind: FieldKind.Primitive,
            type: Primitives.INT32,
          })
        });
        checkExtension('.options.service_2', OptionType.ServiceOptions, {
          kind: FieldKind.Primitive,
          type: Primitives.STRING
        });
      });

      it('method', () => {
        checkExtension('.options.method', OptionType.MethodOptions, {
          kind: FieldKind.Message,
          message: st.getMessage('.options.MethodOptions')
        });

      });

      it('message', () => {
        checkExtension('.options.message', OptionType.MessageOptions, {
          kind: FieldKind.Repeated,
          elementType: expect.objectContaining({
            kind: FieldKind.Message,
            message: st.getMessage('.options.MessageOptions')
          })
        });

      });

      it('enum', () => {
        checkExtension('.options.enum', OptionType.EnumOptions, {
          kind: FieldKind.Message,
          message: st.getMessage('.options.EnumOption')
        });

      });

      it('enum value', () => {
        checkExtension('.options.enum_value', OptionType.EnumValueOptions, {
          kind: FieldKind.Enum,
          enum: st.getEnum('.options.EnumOptionValues')
        });


      });

      it('field', () => {
        checkExtension('.options.field', OptionType.FieldOptions, {
          kind: FieldKind.Repeated,
          elementType: expect.objectContaining({
            kind: FieldKind.Primitive,
            type: Primitives.STRING
          })
        });

      });

      it('one of', () => {
        checkExtension('.options.one_of', OptionType.OneofOptions, {
          kind: FieldKind.Primitive,
          type: Primitives.STRING
        });
      });
    });

    describe('options', () => {
      describe('negative', () => {
        it('returns an empty array when element doesnt contain any options', async () => {
          const file = st.getFile('foo/options.proto');
          expect(file.options.getOptions('.options.file')).toEqual([]);
        });

        it('returns an empty array when requesting non existing option', async () => {
          const file = st.getFile('com/wix/service.proto');
          expect(file.options.getOptions('no-such-option')).toEqual([]);
        });

        it('returns an empty array when requesting an option from a different type', async () => {
          const svc = st.getService('.com.wix.Service');
          expect(svc.options.getOptions('.options.file')).toEqual([]);
        });

        it('returns an empty array when requesting an option not defined', async () => {
          const svc = st.getService('.com.wix.Service2');
          expect(svc.options.getOptions('.options.service_2')).toEqual([]);
        });
      });

      it('file', async () => {
        const file = st.getFile('com/wix/service.proto');
        expect(file.options.allOptions).toHaveLength(1);
        const options = file.options.getOptions('.options.file');
        expect(options).toHaveLength(1);
        const [option] = options;
        expect(option.extension).toBe(st.getExtension('.options.file'));
        expect(option.value).toEqual(3);
        expect(option.fqn).toEqual('com/wix/service.proto[.options.file]');
      });

      it('service', async () => {
        const svc = st.getService('.com.wix.Service');
        expect(svc.options.allOptions).toHaveLength(3);
        const options = svc.options.getOptions('.options.service');
        expect(options).toHaveLength(2);
        expect(options[0].fqn).toEqual('.com.wix.Service[.options.service].0');
        expect(options[1].fqn).toEqual('.com.wix.Service[.options.service].1');

        const options_2 = svc.options.getOptions('.options.service_2');
        expect(options_2).toHaveLength(1);
        expect(options_2[0].value).toEqual('svc2');
      });

      it('method', async () => {
        const method = st.getMethod('.com.wix.Service.Method');
        expect(method.options.allOptions).toHaveLength(1);
        expect(method.options.allOptions[0].value).toEqual({name: 'xyz'});
      });

      it('message', async () => {
        const message = st.getMessage('.com.wix.Message');
        const options = message.options.getOptions('.options.message');
        expect(options).toHaveLength(2);
        expect(options[0].fqn).toEqual('.com.wix.Message[.options.message].0');
        expect(options[0].value).toEqual({name: ['name1']});
        expect(options[1].value).toEqual({name: ['name3', 'name4']});
      });

      it('message with empty array is returned as undefined', async () => {
        const message = st.getMessage('.com.wix.Response');
        const options = message.options.getOptions('.options.message');
        expect(options).toHaveLength(1);
        expect(options[0].value.name).toBeUndefined();
      });

      it('field', async () => {
        const field = st.getField('.com.wix.Message.num');
        const options = field.options.getOptions('.options.field');
        expect(options[0].value).toEqual('f1');
        expect(options[0].fqn).toEqual('.com.wix.Message.num[.options.field].0');
      });

      it('oneof', async () => {
        const oneof = st.getOneof('.com.wix.Message.one_of');
        const options = oneof.options.getOptions('.options.one_of');
        expect(options[0].value).toEqual('one_of');
        expect(options[0].fqn).toEqual('.com.wix.Message.one_of[.options.one_of]');
      });

      it('enum', async () => {
        const someEnum = st.getEnum('.com.wix.SomeEnum');
        const options = someEnum.options.getOptions('.options.enum');
        expect(options[0].value).toEqual({value: 1});
        expect(options[0].fqn).toEqual('.com.wix.SomeEnum[.options.enum]');
      });

      it('enum value', async () => {
        const enumValue = st.getEnumValue('.com.wix.SomeEnum.VALUE');
        const options = enumValue.options.getOptions('.options.enum_value');
        expect(options[0].value).toEqual(1);
        expect(options[0].fqn).toEqual('.com.wix.SomeEnum.VALUE[.options.enum_value]');
      });
    });

    describe('typed options', () => {
      function extNumber(extension: string) {
        return st.getExtension(extension).number;
      }

      enum EnumOptionValues {
        UNKNOWN = 0,
        VALUE1 = 1,
        VALUE2 = 2,
      }

      describe('negative', () => {

        it('returns empty array when requesting a repeated option and option not placed on element', async () => {
          const file = st.getFile('foo/options.proto');
          const opt = RepeatedTypedOptions.file<number>(extNumber('.options.file_2'));
          expect(file.options.getTypedOption(opt)).toEqual([]);
        });

        it('returns undefined when requesting a non repeated option and option not placed on element', async () => {
          const svc = st.getService('.com.wix.Service2');
          const opt = TypedOptions.service<string>(extNumber('.options.service_2'));
          expect(svc.options.getTypedOption(opt)).toBeUndefined();
        });

        it('returns undefined or empty array  when requesting non existing option', async () => {
          const file = st.getFile('com/wix/service.proto');
          const opt = TypedOptions.file<number>(5);
          expect(file.options.getTypedOption(opt)).toBeUndefined();

          const rep_opt = RepeatedTypedOptions.file<number>(6);
          expect(file.options.getTypedOption(rep_opt)).toEqual([]);

        });

        it('returns an empty array when requesting an option from a different type', async () => {
          const svc = st.getService('.com.wix.Service');
          const opt = TypedOptions.file<number>(extNumber('.options.file'));
          //@ts-expect-error this should not pass compilation because of wrong extension type
          expect(() => svc.options.getTypedOption(opt)).toThrow(/invalid extension type/);
        });
      });

      it('file', async () => {
        const file = st.getFile('com/wix/service.proto');
        expect(file.options.allOptions).toHaveLength(1);
        const opt = TypedOptions.file<number>(extNumber('.options.file'));
        const option = file.options.getTypedOption(opt);
        expect(option).toBeDefined();
        expect<number>(option!.value).toEqual(3);
      });

      it('service', async () => {
        const svc = st.getService('.com.wix.Service');

        const opt = RepeatedTypedOptions.service<number>(extNumber('.options.service'));
        const options = svc.options.getTypedOption(opt);

        expect(options).toHaveLength(2);
        expect<number>(options[0].value).toEqual(1);
        expect<number>(options[1].value).toEqual(2);

        const opt2 = TypedOptions.service<string>(extNumber('.options.service_2'));
        const options_2 = svc.options.getTypedOption(opt2);
        expect(options_2).toBeDefined();
        expect<string>(options_2!.value).toEqual('svc2');
      });

      it('method', async () => {
        const method = st.getMethod('.com.wix.Service.Method');
        const opt = TypedOptions.method<{name: string}>(extNumber('.options.method'));
        const option = method.options.getTypedOption(opt);
        expect(option).toBeDefined();
        expect<{name: string}>(option!.value).toEqual({name: 'xyz'});
      });

      it('message', async () => {
        const message = st.getMessage('.com.wix.Message');
        const opt = RepeatedTypedOptions.message<{name?: string[]}>(extNumber('.options.message'));
        const options = message.options.getTypedOption(opt);
        expect(options).toHaveLength(2);

        expect<{name?: string[]}>(options[0].value).toEqual({name: ['name1']});
        expect<{name?: string[]}>(options[1].value).toEqual({name: ['name3', 'name4']});
      });

      it('message with empty array is returned as undefined', async () => {
        const message = st.getMessage('.com.wix.Response');
        const opt = RepeatedTypedOptions.message<{name?: string[]}>(extNumber('.options.message'));
        const option = message.options.getTypedOption(opt);
        expect(option).toHaveLength(1);

        expect<string[] | undefined>(option[0].value.name).toBeUndefined();
      });

      it('field', async () => {
        const field = st.getField('.com.wix.Message.num');
        const opt = RepeatedTypedOptions.field<string>(extNumber('.options.field'));
        const options = field.options.getTypedOption(opt);
        expect<string>(options[0].value).toEqual('f1');
      });

      it('oneof', async () => {
        const oneof = st.getOneof('.com.wix.Message.one_of');

        const opt = TypedOptions.oneOf<string>(extNumber('.options.one_of'));
        const option = oneof.options.getTypedOption(opt);

        expect(option).toBeDefined();
        expect<string>(option!.value).toEqual('one_of');
      });

      it('enum', async () => {
        const someEnum = st.getEnum('.com.wix.SomeEnum');
        const opt = TypedOptions.enum<{value: EnumOptionValues}>(extNumber('.options.enum'));
        const option = someEnum.options.getTypedOption(opt);

        expect(option).toBeDefined();
        expect<{value: EnumOptionValues}>(option!.value).toEqual({value: EnumOptionValues.VALUE1});
      });

      it('enum value', async () => {
        const enumValue = st.getEnumValue('.com.wix.SomeEnum.VALUE');
        const opt = TypedOptions.enumValue<EnumOptionValues>(extNumber('.options.enum_value'));
        const option = enumValue.options.getTypedOption(opt);
        expect(option).toBeDefined();
        expect<EnumOptionValues>(option!.value).toEqual(EnumOptionValues.VALUE1);
      });
    });
  });

  describe('immutability', () => {
    let st: SyntaxTree;

    beforeAll(async () => {
      st = await generateSyntaxTreeFromSource('./test/modules/simple', ['./test/modules/include']);
    });

    describe('options', () => {
      it('fails if option array is mutated', async () => {
        const method = st.getMethod('.com.wix.SomeOtherService.Method');
        const methodOptions = method.options.getOptions('.google.api.http');
        //@ts-expect-error this should fail
        expect(() => methodOptions.pop()).toThrow(/Cannot delete/);

        expect(() => {
          //@ts-expect-error this should fail
          methodOptions[0] = null;
        }).toThrow(/read only/);
      });

      it('fails if option array is mutated - also when option not found', async () => {
        const method = st.getMethod('.com.wix.SomeOtherService.Method');
        const methodOptions = method.options.getOptions('.google.api.http2');
        //@ts-expect-error this should fail
        expect(() => methodOptions.push(1)).toThrow(/Cannot add/);
      });

      it('fails if option value is mutated', async () => {
        const method = st.getMethod('.com.wix.SomeOtherService.Method');
        const methodOptions = method.options.getOptions('.google.api.http');
        expect(() => {
          //@ts-expect-error value is readonly
          methodOptions[0].value = 'hello';
        }).toThrow(/Cannot set/);
      });

      it('fails if option value properties are mutated', async () => {
        const method = st.getMethod('.com.wix.SomeOtherService.Method');
        const methodOptions = method.options.getOptions('.google.api.http');
        const value = methodOptions[0].value;
        expect(() => {
          value.foo = 'hello';
        }).toThrow(/object is not extensible/);

        expect(() => {
          value.get = null;
        }).toThrow(/read only/);
      });

      it('fails if deep option value is mutated', async () => {
        const method = st.getMethod('.com.wix.SomeOtherService.Method2');
        const methodOptions = method.options.getOptions('.google.api.http');
        const value = methodOptions[0].value;
        expect(() => {
          value.additionalBindings.foo = 'hello';
        }).toThrow(/object is not extensible/);

        expect(() => {
          value.additionalBindings[0].get = null;
        }).toThrow(/read only/);

        expect(() => {
          value.additionalBindings.pop();
        }).toThrow(/Cannot delete/);
      });

    });
  });
});
