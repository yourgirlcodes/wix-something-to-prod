import {Option, SourceCodeInfo, SyntaxTree, Type} from '../../lib/api';
import path from 'path';
import {genSt, proto} from '../test-utils';
import {generateSyntaxTreeFromSource} from '../../lib';

describe('source code info', () => {
  describe('single file tests', () => {
    function checkSourceCodeInfo(type: Type, typeName: string, line: number, column: number) {
      line += 3; //Adapting to the generated proto file
      expect(type.sourceCode.leadingComments.trim()).toEqual(`leading ${typeName}`);
      expect(type.sourceCode.trailingComments.trim()).toEqual(`trailing ${typeName}`);
      expect(type.sourceCode.leadingDetachedComments.map(s => s.trim())).toEqual([`leading detached ${typeName}`]);
      expect(type.sourceCode.startLine).toEqual(line);
      expect(type.sourceCode.startColumn).toEqual(column);
      expect(type.sourceCode.container).toEqual(type);
      expect(type.sourceCode.fqn).toEqual(type.fqn);
      expect(path.basename(type.sourceCode.container.file.path)).toEqual('singleFile.proto');
    }

    function checkLocation(srcCodeInfo: SourceCodeInfo, type: Type, name: string, line: number, column: number, endCol?: number) {
      line += 3; //Adapting to the generated proto file
      expect(srcCodeInfo.startLine).toEqual(line);
      expect(srcCodeInfo.startColumn).toEqual(column);
      if (endCol !== undefined) {
        expect(srcCodeInfo.endColumn).toEqual(endCol);
      }
      expect(srcCodeInfo.container).toEqual(type);
      expect(srcCodeInfo.fqn).toEqual(`${type.fqn}.(${name})`);
      expect(path.basename(srcCodeInfo.container.file.path)).toEqual('singleFile.proto');
    }

    it('file', async () => {
      const st = await genSt(proto`
      `);
      const file = st.getFile('singleFile.proto');
      //Not using checkSourceCodeInfo and checkLocation because they auto add lines to adapt to the gen proto
      expect(file.sourceCode.startLine).toEqual(1);
      expect(file.sourceCode.startColumn).toEqual(1);
      expect(file.sourceCode.container).toEqual(file);

      expect(file.detailedSourceCode.syntax.startLine).toEqual(1);
      expect(file.detailedSourceCode.syntax.startColumn).toEqual(1);
      expect(file.detailedSourceCode.syntax.container).toEqual(file);

      expect(file.detailedSourceCode.package.startLine).toEqual(2);
      expect(file.detailedSourceCode.package.startColumn).toEqual(1);
      expect(file.detailedSourceCode.package.container).toEqual(file);
    });

    it('service', async () => {
      const st = await genSt(proto`
      //leading detached service

      /* leading service */
      service Service { /* trailing service */

        rpc Method (Message) returns (Message) {
        }
      }

      message Message {
      }
      `);
      const type = st.getService('.foo.bar.Service');
      checkSourceCodeInfo(type, 'service', 5, 7);
      checkLocation(type.detailedSourceCode.name, type, 'name', 5, 15);
    });

    it('method', async () => {
      const st = await genSt(proto`
      service Service {

        //leading detached method

        /* leading method */
        rpc Method (Message) returns (Message) { // trailing method
        }
      }

      message Message {
      }
      `);
      const type = st.getMethod('.foo.bar.Service.Method');
      checkSourceCodeInfo(type, 'method', 7, 9);
      checkLocation(type.detailedSourceCode.name, type, 'name', 7, 13);
      checkLocation(type.detailedSourceCode.request, type, 'request', 7, 21);
      checkLocation(type.detailedSourceCode.response, type, 'response', 7, 39);
    });

    it('message', async () => {
      const st = await genSt(proto`
      //leading detached message

      /* leading message */
      message Message { /* trailing message */

      }
      `);
      const type = st.getMessage('.foo.bar.Message');
      checkSourceCodeInfo(type, 'message', 5, 7);
      checkLocation(type.detailedSourceCode.name, type, 'name', 5, 15);
    });

    it('field', async () => {
      const st = await genSt(proto`
      message Message {

        //leading detached field

        /* leading field */
        string field = 1; // trailing field
        repeated Message msg = 2;
      }
      `);
      const type = st.getField('.foo.bar.Message.field');
      checkSourceCodeInfo(type, 'field', 7, 9);
      checkLocation(type.detailedSourceCode.type, type, 'type', 7, 9, 15);
      checkLocation(type.detailedSourceCode.name, type, 'name', 7, 16);
      checkLocation(type.detailedSourceCode.number, type, 'number', 7, 24);

      const type2 = st.getField('.foo.bar.Message.msg');
      checkLocation(type2.detailedSourceCode.label, type2, 'label', 8, 9, 17);
      checkLocation(type2.detailedSourceCode.type, type2, 'type', 8, 18, 25);
      checkLocation(type2.detailedSourceCode.name, type2, 'name', 8, 26);
      checkLocation(type2.detailedSourceCode.number, type2, 'number', 8, 32);
    });

    it('oneof', async () => {
      const st = await genSt(proto`
      message Message {

        //leading detached oneof

        /* leading oneof */
        oneof one_of { // trailing oneof

          int32 field2 = 2;
        }
      }
      `);
      const type = st.getOneof('.foo.bar.Message.one_of');
      checkSourceCodeInfo(type, 'oneof', 7, 9);
      checkLocation(type.detailedSourceCode.name, type, 'name', 7, 15);
    });

    it('enum', async () => {
      const st = await genSt(proto`
      //leading detached enum

      /* leading enum */
      enum Enum { // trailing enum

        VALUE = 0;
      }
      `);
      const type = st.getEnum('.foo.bar.Enum');
      checkSourceCodeInfo(type, 'enum', 5, 7);
      checkLocation(type.detailedSourceCode.name, type, 'name', 5, 12);
    });

    it('enum value', async () => {
      const st = await genSt(proto`
      enum Enum {

        //leading detached enum value

        /* leading enum value */
        VALUE = 0; // trailing enum value
      }
      `);
      const type = st.getEnumValue('.foo.bar.Enum.VALUE');
      checkSourceCodeInfo(type, 'enum value', 7, 9);
      checkLocation(type.detailedSourceCode.name, type, 'name', 7, 9, 14);
      checkLocation(type.detailedSourceCode.number, type, 'number', 7, 17, 18);
    });

    it('nested message', async () => {
      const st = await genSt(proto`
      message Message {

        //leading detached nested message

        /* leading nested message */
        message NestedMessage { // trailing nested message

        }
      }
      `);
      const type = st.getType('.foo.bar.Message.NestedMessage');
      checkSourceCodeInfo(type, 'nested message', 7, 9);
    });

    it('nested enum', async () => {
      const st = await genSt(proto`
      message Message {

        //leading detached nested enum

        /* leading nested enum */
        enum NestedEnum { // trailing nested enum
          VALUE = 0;
        }
      }
      `);
      const type = st.getType('.foo.bar.Message.NestedEnum');
      checkSourceCodeInfo(type, 'nested enum', 7, 9);
    });
  });

  describe('multi file tests', () => {
    let st: SyntaxTree;

    beforeAll(async () => {
      st = await generateSyntaxTreeFromSource('./test/modules/source-code-info');
    });

    it('package comments', () => {
      const files = st.files.filter(f => f.package === 'com.wix');

      expect(files[0].detailedSourceCode.package.leadingComments.trim()).toEqual('leading from msgs.proto package');
      expect(files[1].detailedSourceCode.package.leadingComments.trim()).toEqual('leading from svc.proto package');

      expect(files[0].detailedSourceCode.package.leadingDetachedComments).toEqual(['leading detached from msgs.proto package\n']);
      expect(files[1].detailedSourceCode.package.leadingDetachedComments).toEqual(['leading detached from svc.proto package\n']);

      expect(files[0].detailedSourceCode.package.trailingComments.trim()).toEqual('');
      expect(files[1].detailedSourceCode.package.trailingComments.trim()).toEqual('trailing from svc.proto package');
    });

    it('file from include folder also include source code details', async () => {
      const file = st.getFile('google/protobuf/descriptor.proto');
      expect(file.detailedSourceCode.package.startLine).toBeDefined();
    });

    it('syntax comments', () => {
      const file = st.getFile('service.proto');

      expect(file.detailedSourceCode.syntax.leadingComments.trim()).toEqual('leading from svc.proto syntax');
      expect(file.detailedSourceCode.syntax.leadingDetachedComments).toEqual(['leading detached from svc.proto syntax\n']);
      expect(file.detailedSourceCode.syntax.trailingComments.trim()).toEqual('trailing from svc.proto syntax');
    });

    it('supports extension comments', () => {
      const extension = st.getExtension('.options.service');
      expect(extension.sourceCode.leadingComments.trim()).toEqual('leading service extension');
      expect(extension.sourceCode.leadingDetachedComments).toEqual(['leading detached service extension\n']);
      expect(extension.sourceCode.trailingComments.trim()).toEqual('trailing service extension');
    });

    describe('options', () => {
      function checkSourceCodeInfoComments(option: Option, optionName: string, trailingOnly?: boolean) {
        if (!trailingOnly) {
          expect(option.sourceCode.leadingComments.trim()).toEqual(`leading ${optionName}`);
        }
        expect(option.sourceCode.trailingComments.trim()).toEqual(`trailing ${optionName}`);
        if (!trailingOnly) {
          expect(option.sourceCode.leadingDetachedComments.map(s => s.trim())).toEqual([`leading detached ${optionName}`]);
        }
        expect(option.sourceCode.container).toEqual(option);
        expect(option.sourceCode.fqn).toEqual(option.fqn);
      }

      it('file', async () => {
        const type = st.getFile('service.proto');
        const [option] = type.options.getOptions('.options.file');
        checkSourceCodeInfoComments(option, 'file-option');
      });

      it('service', async () => {
        const type = st.getService('.com.wix.Service');
        const [option, option2] = type.options.getOptions('.options.service');
        checkSourceCodeInfoComments(option, 'service-option');
        checkSourceCodeInfoComments(option2, 'service-option-2');
      });

      it('method', async () => {
        const type = st.getMethod('.com.wix.Service.Method');
        const [option] = type.options.getOptions('.options.method');
        checkSourceCodeInfoComments(option, 'method-option');
      });

      it('method - alternative syntax', async () => {
        const type = st.getMethod('.com.wix.Service.Method2');
        const [option] = type.options.getOptions('.options.method');
        checkSourceCodeInfoComments(option, 'method.name-option');
      });

      it('message', async () => {
        const type = st.getMessage('.com.wix.Message');
        const [option, option2] = type.options.getOptions('.options.message');
        checkSourceCodeInfoComments(option, 'message-option');
        checkSourceCodeInfoComments(option2, 'message-option2');
      });

      //field option comments not available in protoc
      it.skip('field', async () => {
        const type = st.getField('.com.wix.Message.num');
        const [option] = type.options.getOptions('.options.field');
        checkSourceCodeInfoComments(option, 'field-option', false);
      });

      it('oneof', async () => {
        const type = st.getOneof('.com.wix.Message.one_of');
        const [option] = type.options.getOptions('.options.one_of');
        checkSourceCodeInfoComments(option, 'oneof-option');
      });

      it('enum', async () => {
        const type = st.getEnum('.com.wix.SomeEnum');
        const [option] = type.options.getOptions('.options.enum');
        checkSourceCodeInfoComments(option, 'enum-option');
      });

      //enum value option comment not available in protoc
      it.skip('enum value', async () => {
        const type = st.getEnumValue('.com.wix.SomeEnum.VALUE');
        const [option] = type.options.getOptions('.options.enum_value');
        checkSourceCodeInfoComments(option, 'enum-value-option', true);
      });
    });
  });
});
