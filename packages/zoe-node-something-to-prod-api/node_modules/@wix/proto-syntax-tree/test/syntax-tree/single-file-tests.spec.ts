import {
  EnumFieldType,
  FieldKind,
  MapFieldType, Message,
  MessageFieldType,
  PrimitiveFieldType,
  Primitives,
  RepeatedFieldType,
  WrapperFieldType,
  WrapperTypes
} from '../../lib/api';
import {genSt, proto} from '../test-utils';

describe('generateSyntaxTree - single file tests', function () {

  describe('references', () => {
    it('circular definition', async () => {
      const st = await genSt(proto`
      message Msg1 {
        Msg2 msg2 = 1;
      }

      message Msg2 {
        Msg1 msg1 = 1;
      }
      `);

      const fieldMsg2 = st.getField('.foo.bar.Msg1.msg2');
      expect(fieldMsg2.fieldType.kind).toEqual(FieldKind.Message);
      expect((fieldMsg2.fieldType as MessageFieldType).message).toBe(st.getMessage('.foo.bar.Msg2'));

      const fieldMsg1 = st.getField('.foo.bar.Msg2.msg1');
      expect(fieldMsg1.fieldType.kind).toEqual(FieldKind.Message);
      expect((fieldMsg1.fieldType as MessageFieldType).message).toBe(st.getMessage('.foo.bar.Msg1'));
    });

    it('circular nested definition', async () => {
      const st = await genSt(proto`
      message Parent {
        int32 int_32 = 1;
        message Nested {
          Parent parent = 1;
          foo.bar.Parent.Enum enum = 2;
        }

        enum Enum {
          VAL_0 = 0;
          VAL_1 = 1;
        }

        Nested nested = 2;
        Enum enum = 3;
      }
      `);

      expect(st.getMessage('.foo.bar.Parent.Nested')).toBeDefined();
    });

    it('oneof should reference its fields and fields should reference the oneof', async () => {
      const st = await genSt(proto`
      message Msg {
        int32 fld = 3;
        oneof tag {
          string str = 1;
          int32 num = 2;
        }
      }`);

      const fldStr = st.getField('.foo.bar.Msg.str');
      const fldNum = st.getField('.foo.bar.Msg.num');
      const oneof = st.getOneof('.foo.bar.Msg.tag');
      expect(oneof.name).toEqual('tag');
      expect(oneof.fields[0]).toBe(fldStr);
      expect(oneof.fields[1]).toBe(fldNum);
      expect(fldStr.oneof).toBe(oneof);
      expect(fldNum.oneof).toBe(oneof);
    });
  });

  describe('methods', () => {
    it('streaming', async () => {
      const st = await genSt(proto`
      service Service {
        rpc Method (Message) returns (Message) {
        }
        rpc StreamingMethod (stream Message) returns (stream Message) {
        }
      }

      message Message {
      }
      `);

      const method = st.getMethod('.foo.bar.Service.Method');
      expect(method.clientStreaming).toBe(false);
      expect(method.serverStreaming).toBe(false);

      const streamingMethod = st.getMethod('.foo.bar.Service.StreamingMethod');
      expect(streamingMethod.clientStreaming).toBe(true);
      expect(streamingMethod.serverStreaming).toBe(true);
    });
  });

  describe('messages', () => {
    it('isMapEntry returns true when a Message is a map entry', async () => {
      const st = await genSt(proto`
      message Msg {
        map<int32, string> int_to_str_map = 1;
      }

      `);

      const msgIntString = st.getMessage('.foo.bar.Msg.IntToStrMapEntry');
      expect(msgIntString.isMapEntry).toEqual(true);
    });

    it('reserved field numbers', async () => {
      const st = await genSt(proto`
      message Msg {
        double double = 1;
        reserved 10 to 20;
        reserved 2;
        reserved 4, 5 to 8;
        string string = 9;
        repeated int32 numbers = 999;
        reserved 1000 to max;
      }`);

      const msg = st.getMessage('.foo.bar.Msg');
      expect(msg.reserved.isReservedNumber(2)).toBe(true);
      expect(msg.reserved.isReservedNumber(3)).toBe(false);
      expect(msg.reserved.isReservedNumber(4)).toBe(true);
      expect(msg.reserved.isReservedNumber(5)).toBe(true);
      expect(msg.reserved.isReservedNumber(8)).toBe(true);
      expect(msg.reserved.isReservedNumber(10)).toBe(true);
      expect(msg.reserved.isReservedNumber(21)).toBe(false);
      expect(msg.reserved.isReservedNumber(1000)).toBe(true);
      expect(msg.reserved.isReservedNumber(1000000)).toBe(true);
    });

    it('reserved field names', async () => {
      const st = await genSt(proto`
      message Msg {
        double double = 1;
        reserved "int32";
        reserved "uint32", "float";
        string string = 9;
        repeated int32 numbers = 999;
      }`);

      const msg = st.getMessage('.foo.bar.Msg');
      expect(msg.reserved.isReservedName('int32')).toBe(true);
      expect(msg.reserved.isReservedName('float')).toBe(true);
      expect(msg.reserved.isReservedName('numbers')).toBe(false);
      expect(msg.reserved.isReservedName('foo')).toBe(false);
    });
  });

  describe('fields', () => {
    it('field numbers', async () => {
      function expectFieldNumber(fieldName: string, num: number) {
        const field = st.getField(`.foo.bar.Msg.${fieldName}`);
        expect(field.number).toEqual(num);
      }

      const st = await genSt(proto`
      message Msg {
        double double = 1;
        string string = 9;
        repeated int32 numbers = 999;
      }`);

      expectFieldNumber('double', 1);
      expectFieldNumber('string', 9);
      expectFieldNumber('numbers', 999);
    });

    it('field by name', async () => {
      function assertFieldEqualsFieldByName(msg: Message, fieldName: string) {
        const field = st.getField(`.foo.bar.Msg.${fieldName}`);
        expect(field).toEqual(msg.fields.byName(fieldName));
      }

      const st = await genSt(proto`
      message Msg {
        double double = 1;
        string string = 9;
        repeated int32 numbers = 999;
      }`);

      const msg = st.getMessage('.foo.bar.Msg');
      assertFieldEqualsFieldByName(msg, 'double');
      assertFieldEqualsFieldByName(msg, 'string');
      assertFieldEqualsFieldByName(msg, 'numbers');

      expect(msg.fields.byName('foo-bar')).toBeUndefined();
    });

    it('optional field', async () => {
      const st = await genSt(proto`
      message Msg {
        optional int32 opt_int_field = 1;
        int32 non_opt_int_field = 2;
      }

      `);

      const optIntField = st.getField('.foo.bar.Msg.opt_int_field');
      expect(optIntField.proto3Optional).toEqual(true);
      const nonOptIntField = st.getField('.foo.bar.Msg.non_opt_int_field');
      expect(nonOptIntField.proto3Optional).toEqual(false);
    });

    describe('field types', () => {
      it('primitives', async () => {
        function expectPrimitiveField(fieldName: string, typ: Primitives, toString: string = fieldName) {
          const field = st.getField(`.foo.bar.Msg.${fieldName}`);
          expect(field.fieldType.kind).toEqual(FieldKind.Primitive);
          expect((field.fieldType as PrimitiveFieldType).type).toEqual(typ);
          expect(field.fieldType.toString()).toEqual(toString);
        }

        const st = await genSt(proto`
      message Msg {
        double double = 1;
        float float = 2;
        int64 int64 = 3;
        uint64 uint64 = 4;
        int32 int32 = 5;
        fixed64 fixed64 = 6;
        fixed32 fixed32 = 7;
        bool bool = 8;
        string string = 9;
        bytes bytes = 12;
        uint32 uint32 = 13;
        sfixed32 sfixed32 = 15;
        sfixed64 sfixed64 = 16;
        sint32 sint32 = 17;
        sint64 sint64 = 18;
      }`);

        expectPrimitiveField('double', Primitives.DOUBLE);
        expectPrimitiveField('float', Primitives.FLOAT);
        expectPrimitiveField('int64', Primitives.INT64);
        expectPrimitiveField('uint64', Primitives.UINT64);
        expectPrimitiveField('int32', Primitives.INT32);
        expectPrimitiveField('fixed64', Primitives.FIXED64);
        expectPrimitiveField('fixed32', Primitives.FIXED32);
        expectPrimitiveField('bool', Primitives.BOOL);
        expectPrimitiveField('string', Primitives.STRING);
        expectPrimitiveField('bytes', Primitives.BYTES);
        expectPrimitiveField('uint32', Primitives.UINT32);
        expectPrimitiveField('sfixed32', Primitives.SFIXED32);
        expectPrimitiveField('sfixed64', Primitives.SFIXED64);
        expectPrimitiveField('sint32', Primitives.SINT32);
        expectPrimitiveField('sint64', Primitives.SINT64);
      });

      it('enum', async () => {
        const st = await genSt(proto`
      message Msg {
        SomeEnum enum1 = 1;
      }

      enum SomeEnum {
        UNKNOWN = 0;
      }
      `);

        const field = st.getField('.foo.bar.Msg.enum1');
        expect(field.fieldType.kind).toEqual(FieldKind.Enum);
        expect((field.fieldType as EnumFieldType).enum).toBe(st.getEnum('.foo.bar.SomeEnum'));
        expect(field.fieldType.toString()).toEqual('.foo.bar.SomeEnum');
      });

      it('message', async () => {
        const st = await genSt(proto`
      message SomeMessage {
        int32 num = 1;
      }

      message Msg {
        SomeMessage msg1 = 1;
      }
      `);

        const field = st.getField('.foo.bar.Msg.msg1');
        expect(field.fieldType.kind).toEqual(FieldKind.Message);
        expect((field.fieldType as MessageFieldType).message).toBe(st.getMessage('.foo.bar.SomeMessage'));
        expect(field.fieldType.toString()).toEqual('.foo.bar.SomeMessage');
      });

      it('Map', async () => {
        const st = await genSt(proto`
      message Msg {
        map<string, int32> str_int32_map = 1;
        map<bool, Msg> bool_msg_map = 2;
      }
      `);

        const strIntMap = st.getField('.foo.bar.Msg.str_int32_map');
        expect(strIntMap.fieldType.kind).toEqual(FieldKind.Map);
        const keyType1 = (strIntMap.fieldType as MapFieldType).keyType;
        expect(keyType1).toEqual(Primitives.STRING);
        const valueType1 = (strIntMap.fieldType as MapFieldType).valueType;
        expect(valueType1.kind).toEqual(FieldKind.Primitive);
        expect((valueType1 as PrimitiveFieldType).type).toEqual(Primitives.INT32);
        expect(strIntMap.fieldType.toString()).toEqual('map<string,int32>');

        const boolMsgMap = st.getField('.foo.bar.Msg.bool_msg_map');
        expect(boolMsgMap.fieldType.kind).toEqual(FieldKind.Map);
        const keyType2 = (boolMsgMap.fieldType as MapFieldType).keyType;
        expect(keyType2).toEqual(Primitives.BOOL);
        const valueType2 = (boolMsgMap.fieldType as MapFieldType).valueType;
        expect(valueType2.kind).toEqual(FieldKind.Message);
        expect((valueType2 as MessageFieldType).message).toEqual(st.getMessage('.foo.bar.Msg'));
        expect(boolMsgMap.fieldType.toString()).toEqual('map<bool,.foo.bar.Msg>');
      });

      it('wrappers', async () => {
        function expectWrapperField(fieldName: string, typ: WrapperTypes, toString: string) {
          const field = st.getField(`.foo.bar.Msg.${fieldName}`);
          expect(field.fieldType.kind).toEqual(FieldKind.Wrapper);
          expect((field.fieldType as WrapperFieldType).type).toEqual(typ);
          expect((field.fieldType as WrapperFieldType).message).toBeDefined();
          expect(field.fieldType.toString()).toEqual(toString);
        }

        const st = await genSt(proto`
      message Msg {
        google.protobuf.DoubleValue double = 1;
        google.protobuf.FloatValue float = 2;
        google.protobuf.Int64Value int64 = 3;
        google.protobuf.UInt64Value uint64 = 4;
        google.protobuf.Int32Value int32 = 5;
        google.protobuf.BoolValue bool = 6;
        google.protobuf.StringValue string = 7;
        google.protobuf.BytesValue bytes = 8;
        google.protobuf.UInt32Value uint32 = 9;
      }`, ['google/protobuf/wrappers.proto']);


        expectWrapperField('double', Primitives.DOUBLE, '.google.protobuf.DoubleValue');
        expectWrapperField('float', Primitives.FLOAT, '.google.protobuf.FloatValue');
        expectWrapperField('int64', Primitives.INT64, '.google.protobuf.Int64Value');
        expectWrapperField('uint64', Primitives.UINT64, '.google.protobuf.UInt64Value');
        expectWrapperField('int32', Primitives.INT32, '.google.protobuf.Int32Value');
        expectWrapperField('bool', Primitives.BOOL, '.google.protobuf.BoolValue');
        expectWrapperField('string', Primitives.STRING, '.google.protobuf.StringValue');
        expectWrapperField('bytes', Primitives.BYTES, '.google.protobuf.BytesValue');
        expectWrapperField('uint32', Primitives.UINT32, '.google.protobuf.UInt32Value');
      });

      it('repeated', async () => {
        function expectRepeatedField(fieldName: string, kind: FieldKind, toString: string) {
          const field = st.getField(`.foo.bar.Msg.${fieldName}`);
          expect(field.fieldType.kind).toEqual(FieldKind.Repeated);
          expect((field.fieldType as RepeatedFieldType).elementType.kind).toEqual(kind);
          expect(field.fieldType.toString()).toEqual(toString);
          return (field.fieldType as RepeatedFieldType);
        }

        const st = await genSt(proto`
      enum SomeEnum {
        UNKNOWN = 0;
      }

      message SomeMessage {
        int32 num = 1;
      }

      message Msg {
        repeated int32 int32_array = 1;
        repeated SomeEnum enum_array = 2;
        repeated SomeMessage msg_array = 3;
      }`);

        const repeatedInt32 = expectRepeatedField('int32_array', FieldKind.Primitive, 'repeated int32');
        expect((repeatedInt32.elementType as PrimitiveFieldType).type).toEqual(Primitives.INT32);

        const repeatedEnum = expectRepeatedField('enum_array', FieldKind.Enum, 'repeated .foo.bar.SomeEnum');
        expect((repeatedEnum.elementType as EnumFieldType).enum).toBe(st.getEnum('.foo.bar.SomeEnum'));

        const repeatedMessage = expectRepeatedField('msg_array', FieldKind.Message, 'repeated .foo.bar.SomeMessage');
        expect((repeatedMessage.elementType as MessageFieldType).message).toBe(st.getMessage('.foo.bar.SomeMessage'));
      });
    });
  });

  describe('enums', () => {
    it('reserved numbers', async () => {
      const st = await genSt(proto`
      enum Enum {
        UNKNOWN = 0;
        VAL_9 = 9;
        VAL_999 = 999;
        reserved 1000 to max;
        reserved 1;
        reserved 3, 4 to 8;
      }`);

      const enm = st.getEnum('.foo.bar.Enum');
      expect(enm.reserved.isReservedNumber(1)).toBe(true);
      expect(enm.reserved.isReservedNumber(2)).toBe(false);
      expect(enm.reserved.isReservedNumber(3)).toBe(true);
      expect(enm.reserved.isReservedNumber(1000)).toBe(true);
      expect(enm.reserved.isReservedNumber(10000)).toBe(true);
    });

    it('reserved values', async () => {
      const st = await genSt(proto`
      enum Enum {
        UNKNOWN = 0;
        VAL_9 = 9;
        VAL_999 = 999;
        reserved "VAL_1";
        reserved "VAL_99", "VAL_3";
      }`);

      const enm = st.getEnum('.foo.bar.Enum');
      expect(enm.reserved.isReservedName('VAL_1')).toBe(true);
      expect(enm.reserved.isReservedName('VAL_99')).toBe(true);
      expect(enm.reserved.isReservedName('VAL_3')).toBe(true);
      expect(enm.reserved.isReservedName('VAL_999')).toBe(false);
    });
  });
});

