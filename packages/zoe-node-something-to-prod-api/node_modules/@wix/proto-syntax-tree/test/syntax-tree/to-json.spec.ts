import {SyntaxTree} from '../../lib/api';
import {genSt, proto} from '../test-utils';
import {generateSyntaxTreeFromSource} from '../../lib';

describe('toJson', () => {
  let st: SyntaxTree;

  function checkJsonStringify(fqn: string, expected: any) {
    const elem = st.getType(fqn);
    const obj = JSON.parse(JSON.stringify(elem));
    expect(obj).toEqual(expected);
  }

  describe('simple proto', () => {
    beforeAll(async () => {
      st = await genSt(proto`
      service Service {
        rpc Method (Message) returns (Message) {
        }
        rpc Method1 (Message) returns (Message) {
        }
      }

      message Message {
        oneof one_of {
          int32 some_field = 1;
        }

        message NestedMessage {
        }

        enum NestedEnum {
           NESTED_VAL = 0;
        }
      }

      message Message2 {

      }

      enum Enum {
        VAL = 0;
      }
      `);
    });

    it('file', async () => {
      checkJsonStringify('singleFile.proto', {
        typeName: 'File',
        name: 'singleFile.proto',
        package: 'foo.bar',
        options: [],
        path: expect.stringMatching(/singleFile\.proto/),
        protoFolder: 'MainProtoFolder',
        services: expect.anything(),
        messages: expect.anything(),
        extensions: expect.anything(),
        enums: expect.anything(),
      });
    });

    it('service', async () => {
      checkJsonStringify('.foo.bar.Service', {
        typeName: 'Service',
        name: 'Service',
        options: [],
        methods: expect.anything(),
      });
    });

    it('method', async () => {
      checkJsonStringify('.foo.bar.Service.Method', {
        typeName: 'Method',
        name: 'Method',
        options: [],
        request: '.foo.bar.Message',
        response: '.foo.bar.Message',
      });
    });

    it('message', async () => {
      checkJsonStringify('.foo.bar.Message', {
        typeName: 'Message',
        name: 'Message',
        options: [],
        fields: expect.anything(),
        isMapEntry: false,
        messages: expect.anything(),
        oneofs: expect.anything(),
        enums: expect.anything(),
      });
    });

    it('field', async () => {
      checkJsonStringify('.foo.bar.Message.some_field', {
        typeName: 'Field',
        name: 'some_field',
        options: [],
        number: 1,
        fieldType: {
          kind: 'Primitive',
          type: 5,
        },
        jsonName: 'someField',
        proto2Optional: true,
        proto3Optional: false,
      });
    });

    it('oneof', async () => {
      checkJsonStringify('.foo.bar.Message.one_of', {
        typeName: 'Oneof',
        name: 'one_of',
        options: [],
        fields: ['some_field'],
      });
    });

    it('enum', async () => {
      checkJsonStringify('.foo.bar.Enum', {
        typeName: 'Enum',
        name: 'Enum',
        options: [],
        values: expect.anything(),
      });
    });

    it('enumValue', async () => {
      checkJsonStringify('.foo.bar.Message.NestedEnum.NESTED_VAL', {
        typeName: 'EnumValue',
        name: 'NESTED_VAL',
        options: [],
        number: 0
      });
    });

    it('JSON.stringify completes successfully', async () => {
      const json = JSON.stringify(st, null, 1);
      expect(json).toBeDefined();
    });
  });

  describe('complex proto', () => {
    beforeAll(async () => {
      st = await generateSyntaxTreeFromSource('./test/modules/complex/src/main/proto',
        [
          './test/modules/complex/protos-common/src/main/proto',
          './test/modules/complex/protos-query/src/main/proto',
          './test/modules/complex/schedule-api/src/main/proto',
          './test/modules/complex/common-api/src/main/proto',
          './test/modules/complex/locations-web/proto',
          './test/modules/complex/site-properties-api-proto/src/main/proto',
        ]);
    });

    it('successfully converts complex proto to json', async () => {
      const json = JSON.stringify(st, null, 1);
      console.log(json);
      //This checks stringify doesn't fail with "Circular Reference" error
      expect(json).toBeDefined();
    });

    it('extensions', async () => {
      checkJsonStringify('.wix.api.permission', {
        typeName: 'Extension',
        name: 'permission',
        optionType: 'MethodOptions',
        number: 50301,
        fieldType: {
          kind: 'Message',
          message: '.wix.api.PermissionRule',
        },
      });
    });

    it('options', async () => {
      checkJsonStringify('.wix.api.funnel.builder.backoffice.BackofficeFlowService.CreateFlow', {
        typeName: 'Method',
        name: 'CreateFlow',
        request: '.wix.api.funnel.builder.backoffice.CreateFlowRequest',
        response: '.wix.api.funnel.builder.backoffice.CreateFlowResponse',
        options: expect.arrayContaining([
          {
            name: '.wix.api.required',
            value: 'CreateFlowRequest.flow',
          }
        ]),
      });
    });

  });


});
