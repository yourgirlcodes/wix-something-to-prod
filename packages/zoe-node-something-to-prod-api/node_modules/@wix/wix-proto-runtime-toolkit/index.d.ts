import * as ProtobufJs from '@wix/wnp-protobufjs';
import Long from 'long';

/** cannot use '@wix/wnp-proto-runtime-types' due to cyclic dep */
type ServiceInterface<S> = Function & { prototype: S };
type $GeneratedMessageClassNominal$ = {
  __$$generatedFromProtobuf$$__: Symbol;
};
export type $$GeneratedMessage$$<C> = Function & { prototype: C } & $GeneratedMessageClassNominal$;


export const protobufjs: typeof ProtobufJs;

export namespace util {

  interface MethodDescriptor {
    readonly name: string;
    readonly messageTypes: [$$GeneratedMessage$$<any>, $$GeneratedMessage$$<any>];
    readonly __proto: (pbjs: typeof ProtobufJs) => ProtobufJs.ReflectionObject;
  }

  namespace Options {
    interface Result {
      find(key?: string | RegExp, includeKeys?: boolean): string[] & { readonly first: string | undefined };
    }

    interface Query {
      (object: ReflectionObject): Result;
    }

    interface RawOption {
      readonly name: string;
      readonly value: string;
    }

    type ReflectionObject = Pick<ProtobufJs.ReflectionObject, 'options' | 'parsedOptions'> & {
      readonly rawOptions?: RawOption[];
    };
  }

  export function fqn(clazzOrInstance: $$GeneratedMessage$$<any> | ProtobufJs.ReflectionObject): string;

  export function unimplementedMethods(classOrInstance: object): string[];

  export function interfaceClass(classOrInstance: object): ServiceInterface<any>;

  export function isRpcService(classOrInstance: object): boolean;

  export function serviceMethods(classOrInstance: object): MethodDescriptor[];

  export function isMessageClass(value?: any): boolean;

  export function options(namespace: string): Options.Query;
}

export namespace protobuf {
  export function encode<T>(clazz: $$GeneratedMessage$$<T>, value: T): Buffer;
  export function decode<T>(clazz: $$GeneratedMessage$$<T>, encoded: Buffer): T;
}

export namespace json {

  export interface Duration {
    seconds?: Long | string;
    nanos?: number;
  }

  export interface ConversionOptions {
    stringLongs?: boolean;
  }

  export namespace Duration {
    export function toJSON(duration: Duration, options?: ConversionOptions): string;
    export function fromJSON(value: string, options?: ConversionOptions): Duration;
  }
}

export namespace verification {

  export namespace Map {
    export namespace Key {
      export function isBoolean(value?: any): boolean;
      export function isInteger(value?: any): boolean;
    }
  }
}

export namespace grpc {

  export interface FieldMask {
    paths: string[];
  }

  export interface Timestamp {
    seconds: Long | string | number;
    nanos: number;
  }

  export type Value = StringValue | NumberValue | BooleanValue | NullValue | ListValue | StructValue;

  export interface StringValue {
    kind: 'stringValue';
    stringValue: string;
  }
  export interface NumberValue {
    kind: 'numberValue';
    numberValue: number;
  }
  export interface BooleanValue {
    kind: 'boolValue';
    boolValue: boolean;
  }
  export interface NullValue {
    kind: 'nullValue';
    nullValue: 0;
  }
  export interface ListValue {
    kind: 'listValue';
    listValue: {
      values: Value[];
    };
  }
  export interface StructValue {
    kind: 'structValue';
    structValue: {
      fields: {
        [key: string]: Value;
      };
    };
  }

  export function fromGRPC<T>(clazz: $$GeneratedMessage$$<T>, raw: object): T;
  export function toGRPC<T>(clazz: $$GeneratedMessage$$<T>, value: T): object;
  export function structToGRPC(struct: object | null | undefined): object | undefined | null;
  export function structFromGRPC(struct: object | null | undefined): object | undefined | null;
  export function valueToGRPC(value: any): any;
  export function valueFromGRPC(value: any): any;
  export function listValueToGRPC(value: any): any;
  export function listValueFromGRPC(value: any): any;
  export function longFromGRPC(long: object | number | string): Long;
  export function longToGRPC(long: Long): object;
  export function timestampFromGRPC(timestamp: Timestamp): Date;
  export function timestampToGRPC(date: Date): Timestamp;
  export function fieldmaskToGRPC(paths: string[]): FieldMask;
  export function fieldmaskFromGRPC(fieldMask: FieldMask): string[];

}
