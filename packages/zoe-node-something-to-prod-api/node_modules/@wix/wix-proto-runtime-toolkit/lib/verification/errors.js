const assert = require('assert');

class Errors {

  toArray() {
    throw new Error('abstract');
  }

  isEmpty() {
    return this.toArray().length === 0;
  }

  field(field) {
    assertIsString(field, 'field');
    return new Nested(this, {field});
  }

  index(/* i */) {
    throw new Error('abstract');
  }

  up() {
    throw new Error('abstract');
  }

  error(/* msg */) {
    throw new Error('abstract');
  }

  toString() {
    return this.toArray().join('\n');
  }

  static empty() {
    return new Root();
  }
}

class Root extends Errors {

  constructor() {
    super();
    this._errors = [];
  }

  index(/* index */) {
    throw new Error('root is not indexable');
  }

  toArray() {
    return this._errors;
  }

  up() {
    return this;
  }

  error(msg) {
    assertIsString(msg, 'error');
    this._errors.push(msg);
    return this;
  }

  toString() {
    return this.toArray().join('\n');
  }

  _bubble(msg, path) {
    const prefix = path.reduce((acc, p) => {
      acc += p.field ? `${acc.length ? '.' : ''}${p.field}` : `[${p.index}]`;
      return acc;
    }, '');
    this.error(`${prefix}: ${msg}`);
  }
}

class Nested extends Errors {

  constructor(parent, path) {
    super();
    this._parent = parent;
    this._path = path;
  }

  error(msg) {
    assertIsString(msg, 'error');
    this._bubble(msg, []);
    return this;
  }

  up() {
    return this._parent;
  }

  toArray() {
    return this._parent.toArray();
  }

  index(index) {
    assert(typeof index !== 'object' && (typeof index !== 'number' || Number.isInteger(index)),
      'index has to be a boolean, string or integer');
    return new Nested(this, {index});
  }

  _bubble(msg, path) {
    this._parent._bubble(msg, [this._path, ...path]);
  }
}

function assertIsString(arg, name) {
  assert(typeof arg === 'string', `${name} has to be a string`);
}



module.exports = Errors;
