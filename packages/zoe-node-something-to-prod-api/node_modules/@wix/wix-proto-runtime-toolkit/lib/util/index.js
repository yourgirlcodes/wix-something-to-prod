const SERVICE_MARKER = '__isRpcService__',
  assert = require('assert');

const FQN = Symbol('fqn');

const PARSED_OPTIONS_COMMENT_FIELD = '__comment';

function isMessageClass(clazz) {
  return typeof clazz === 'function' &&
    clazz.prototype &&
    clazz.prototype.hasOwnProperty('__proto') &&
    clazz.prototype.hasOwnProperty('__fqn__');
}

function isStringInteger(value) {
  const isStringInteger = /^[-+]?\d+$/;
  return typeof value === 'string' && isStringInteger.test(value);
}

function interfaceClass(service) {
  const seed = typeof service === 'function' ? service.prototype : Object.getPrototypeOf(service);
  const result = find(seed).constructor;
  assert(result.prototype[SERVICE_MARKER], 'no interface found');
  return result;
}

function find(clazz) {
  if (!clazz.__proto__[SERVICE_MARKER]) {
    return clazz;
  } return find(clazz.__proto__);
}

function isRpcService(instance) {
  if (typeof instance === 'function') {
    return instance.prototype[SERVICE_MARKER] || false;
  } else {
    return instance && instance[SERVICE_MARKER] || false;
  }
}

function serviceMethods(service) {
  const clazz = interfaceClass(service);
  return Object.getOwnPropertyNames(clazz.prototype)
    .filter(prop => clazz.prototype[prop] && clazz.prototype[prop]._messageTypes)
    .map(name => ({name, messageTypes: clazz.prototype[name]._messageTypes(), __proto: clazz.prototype[name].__proto}));
}

function fqn(type) {
  if (type && type.prototype && type.prototype.__fqn__) {
    return type.prototype.__fqn__;
  }
  if (typeof type[FQN] === 'undefined') {
    let result = type.name;
    if (type.parent) {
      const parentFqn = fqn(type.parent);
      result = parentFqn.length > 0 ? `${parentFqn}.${result}` : result;
    }
    type[FQN] = result;
  }
  return type[FQN];
}

function unimplementedMethods(instanceOrClass) {
  const res = [];
  const iClass = interfaceClass(instanceOrClass);

  serviceMethods(instanceOrClass).forEach(({name}) => {
    if (typeof instanceOrClass === 'function') {
      if (iClass.prototype[name] === instanceOrClass.prototype[name]) {
        res.push(name);
      }
    } else {
      if (iClass.prototype[name] === instanceOrClass[name]) {
        res.push(name);
      }
    }
  });
  return res;
}

function fromOptions(obj) {
  if (obj) {
    return Object.keys(obj).reduce((acc, key) => [...acc, {name: key, value: obj[key]}], []);
  }
}

function fromParsedOptions(parsedOptions) {
  function* flatten(obj) {
    function* rec(key, o) {
      if (typeof o === 'object') {
        for (const [k, v] of flatten(o)) {
          yield [[key, k].join('.'), v];
        }
      } else {
        yield [key, o];
      }
    }
    for (const [key, value] of Object.entries(obj).filter(([key]) => key !== PARSED_OPTIONS_COMMENT_FIELD)) {
      if (typeof value !== 'object' || Object.keys(value).length === 0) {
        yield [key, value];
      } else if (Array.isArray(value)) {
        for (const o of value) {
          yield *rec(key, o);
        }
      } else {
        yield *rec(key, value);
      }
    }
  }
  if (parsedOptions) {
    return parsedOptions.reduce((acc, opt) => {
      for (const [name, value] of flatten(opt)) {
        acc.push({name, value});
      }
      return acc;
    }, []);
  }
}


function options(namespace) {
  return node => {
    const opts = fromParsedOptions(node.parsedOptions) || node.rawOptions || fromOptions(node.options) || [];
    function find(pathOrRegex = /.*/, includeKeys = false) {
      const res = opts.reduce((acc, {name, value}) => {
        const canonical = name.replace(/\)|\(/g, '').replace(/^\./, '');
        if (canonical.startsWith(namespace)) {
          const withoutNamespace = canonical.substring(namespace.length + 1);
          const matches = pathOrRegex instanceof RegExp ? pathOrRegex.test(withoutNamespace) : canonical === `${namespace}.${pathOrRegex}`;
          if (matches) {
            acc.push(includeKeys ? [withoutNamespace, value] : value);
          }
        }
        return acc;
      }, []);
      Object.defineProperty(res, 'first', {
        get: function () {
          return this[0];
        }
      });
      return res;
    }

    return {find};
  };
}

module.exports = {interfaceClass, serviceMethods, isRpcService, unimplementedMethods, fqn, options, isMessageClass, isStringInteger};
