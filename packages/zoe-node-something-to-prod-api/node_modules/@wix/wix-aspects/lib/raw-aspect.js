const Aspect = require('./wix-aspect'),
  _ = require('lodash'),
  assert = require('assert'),
  matcher = require('matcher'),
  isRpc = require('./is-rpc');

const DROP = Symbol('drop_aspect');

const LOWER_CASE = Symbol('lower_case');

const DEFAULT_WHITELIST = [
  'User-Agent',
  'X-Forwarded-For',
  '_wixVIDX',
  '_wixCIDX',
  '_wixRIDX',
  'X-Wix-Request-Id',
  'wixSession2',
  'Authorization',
  'X-Wix-Country-Code',
  'geoip_country_code',
  'X-Wix-Region-Code',
  'x-wix-linguist',
  'smSession',
  'svSession',
  '_wix_browser_sess',
  'apps',
  'identities',
  '_wixUIDX',
  'wixLanguage',
  'petri_ovr',
  'country-code-override',
  'X-Wix-Language',
  'X-Wix-Forwarded-Url',
  'X-Wix-Ip',
  'Accept-Language',
  'automation',
  'Host',
  'consent-policy',
  'x-wix-brand',
  'x-wix-site-revision',
  'x-wix-bi-context',
  'x-wix-currency',
  'X-Wix-Client-Artifact-ID',
  'bSession',
  'commonConfig',
  'x-wix-user-agent',
  'x-wix-locale',
  'x-wix-inject-fault',
];

const DEFAULT_QUERY_PARAMS_WHITELIST = [
  'lang',
  'dateNumberFormat',
  'isPrimaryLanguage',
  'instance',
  'overrideLocale',
  'petri_ovr',
  'x-wix-petri-ex',
  'appUrl',
  'siteRevision',
  'currentCurrency',
  'locale',
];

const ERR_MSG = 'overrides has to be a map (object) of string to primitive';
const RPC_PREFIX = 'x-wixaspect-';

const EMPTY_DECODER_CONTEXT = {
  languageResolver: {
    additionalLanguages: () => [],
    regionalLanguages: () => []
  }
};

function createRawAspectFactory(whitelist = DEFAULT_WHITELIST, passThroughHeaders = [], whitelistPrefixes = [], whitelistQueryParams = DEFAULT_QUERY_PARAMS_WHITELIST, decoderContext = EMPTY_DECODER_CONTEXT) {

  const fixCaseIfWhitelisted = (function () {
    if (whitelist === true) {
      if (passThroughHeaders.length === 0) {
        return s => s;
      } else {
        return s => matcher.isMatch(s, passThroughHeaders, {caseSensitive: false}) ? undefined : s;
      }
    } else {
      return filterExactOrPrefixedCaseInsensitive(whitelist, whitelistPrefixes);
    }
  })();

  return requestData => {
    const inbound = ignoreCaseOnKeyAccess(read(requestData, fixCaseIfWhitelisted, new Set(whitelistQueryParams)));
    const pass = passThroughHeaders.length > 0 ?
      _.pick(requestData.headers, matcher(Object.keys(requestData.headers || {}), passThroughHeaders, {caseSensitive: false})) : {};
    return new RawAspect(requestData, inbound, pass, decoderContext);
  };
}

function ignoreCaseOnKeyAccess(dictionary) {
  dictionary[LOWER_CASE] = {};
  Object.keys(dictionary).forEach(key => dictionary[LOWER_CASE][key.toLowerCase()] = dictionary[key]);
  return new Proxy(dictionary, {
    get: (target, key) => typeof key === 'string' && target[LOWER_CASE][key.toLowerCase()] !== undefined ? target[LOWER_CASE][key.toLowerCase()] : target[key],
    set: (target, key, value) => {
      if (typeof key === 'string' && target[LOWER_CASE]) {
        target[LOWER_CASE][key.toLowerCase()] = value;
      }
      return Reflect.set(target, key, value);
    },
    deleteProperty: (target, key) => {
      delete target[key.toLowerCase()];
      delete target[LOWER_CASE][key.toLowerCase()];
      return true;
    }
  });
}

function filterExactOrPrefixedCaseInsensitive(whitelist, whitelistPrefixes) {
  const fullNames = new Map(whitelist.map(e => [e.toLowerCase(), e]));
  const prefixes = whitelistPrefixes.map(prefix => ({lowerCasedPrefix: prefix.toLowerCase(), prefix}));

  return s => {
    const lowerCased = s.toLowerCase();

    let whitelistedValue = fullNames.get(lowerCased);

    if (!whitelistedValue) {
      const prefixEntry = prefixes.find(entry => lowerCased.startsWith(entry.lowerCasedPrefix));
      if (prefixEntry) {
        whitelistedValue = `${prefixEntry.prefix}${s.slice(prefixEntry.prefix.length)}`;
      }
    }

    return whitelistedValue;
  };
}

class RawAspect extends Aspect {

  constructor(requestData, inbound, pass, decoderContext) {
    super('raw', requestData);
    this._aspect = {inbound, pass};
    const sanitizedHttpData = _.pick(requestData, ['query', 'url', 'originalUrl', 'remoteAddress', 'remotePort', 'headers', 'cookies']);
    this._httpData = _.isEmpty(sanitizedHttpData) ? undefined : sanitizedHttpData;
    this._decoderContext = decoderContext;
  }

  // TODO: deprecated. will be dropped together with AspectStore#broadcast
  override(values) {
    validateOverrides(values);
    this._aspect.replacements = Object.assign(this._aspect.replacements || {}, values);
  }

  get inbound() {
    return this._aspect.inbound;
  }

  get outbound() {
    return _.omitBy({...this.inbound, ...this._aspect.replacements}, value => value === DROP);
  }

  get(decoder, store) {
    return decoder.decode(this.inbound, {store, http: this._httpData, context: this._decoderContext});
  }

  copy(values) {
    validateOverrides(values);
    const clone = {...this};
    Object.setPrototypeOf(clone, Object.getPrototypeOf(this));

    clone._aspect = {inbound: ignoreCaseOnKeyAccess({...this._aspect.inbound}), pass: {...this._aspect.pass}};
    clone._aspect.replacements = {...this._aspect.replacements, ...values};
    return clone;
  }

  _augment(inbound) {
    assert(typeof inbound === 'object' && !Array.isArray(inbound), 'object expected');
    this._aspect.inbound = Object.assign(this._aspect.inbound, fixCasing({within: inbound, by: this._aspect.inbound}));
  }

  _decrease(key) {
    assert(typeof key === 'string', 'string expected');
    delete this._aspect.inbound[key];
  }

  get pass() {
    return this._aspect.pass;
  }
}

function fixCasing({within, by}) {
  const mapping = Object.keys(by).reduce((acc, key) => {
    acc[key.toLowerCase()] = key;
    return acc;
  }, {});

  return Object.keys(within).reduce((acc, key) => {
    acc[mapping[key.toLowerCase()] || key] = within[key];
    return acc;
  }, {});
}

function validateOverrides(values) {
  assert(values && typeof values === 'object', ERR_MSG);
  _.values(values).forEach(value => assert(typeof value !== 'object', ERR_MSG));
}

function stripPrefix(key) {
  return isPrefixed(key) ? key.substring(RPC_PREFIX.length) : key;
}

function isPrefixed(key) {
  return key.toLowerCase().startsWith(RPC_PREFIX);
}

function read(data, fixCaseIfWhitelisted, queryParamsWhitelist) {
  const res = {};

  const headers = data.rawHeaders || data.headers;

  [headers, data.cookies].forEach(map => {
    for (let key in map) {
      const fixedName = fixCaseIfWhitelisted(key);
      if (fixedName) {
        res[stripPrefix(fixedName)] = map[key];
      } else if (isPrefixed(key) && isRpc(data)) {
        res[stripPrefix(key)] = map[key];
      }
    }
  });

  Object.keys(data.query || {}).forEach(key => {
    if (queryParamsWhitelist.has(key)) {
      const value = data.query[key];
      res[key] = Array.isArray(value) ? value[0] : value;
    }
  });

  return res;
}


module.exports = createRawAspectFactory;
module.exports.RawAspect = RawAspect;
module.exports.DEFAULT_WHITELIST = DEFAULT_WHITELIST;
module.exports.DEFAULT_QUERY_PARAMS_WHITELIST = DEFAULT_QUERY_PARAMS_WHITELIST;
module.exports.DROP = DROP;
module.exports.EMPTY_DECODER_CONTEXT = EMPTY_DECODER_CONTEXT;
