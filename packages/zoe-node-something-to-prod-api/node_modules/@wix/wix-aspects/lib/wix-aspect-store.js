const assert = require('assert'),
  createRawAspectFactory = require('./raw-aspect'),
  DROP = createRawAspectFactory.DROP,
  _ = require('lodash'),
  util = require('util'),
  {ResponseAspects} = require('../lib/response-aspects');

const emptyAspectsBuilder = createStoreBuilder([]);

function createEmptyStore() {
  return emptyAspectsBuilder.build({});
}

function createStoreBuilder(aspectBuilders, {
  whitelist,
  whitelistPrefixes,
  passThroughHeaders,
  whitelistQueryParams,
  whitelistsProvider,
  augmenters = [],
  decoderContext = createRawAspectFactory.EMPTY_DECODER_CONTEXT
} = {}) {
  assert(aspectBuilders && aspectBuilders.length !== undefined, 'aspect builders must be an array.');

  function build(data) {
    if (whitelistsProvider) {
      ({whitelist, whitelistPrefixes, whitelistQueryParams} = whitelistsProvider());
    }
    assert(data && typeof data === 'object', 'requestData is mandatory when constructing Aspect');
    return buildAspects(data, aspectBuilders, {whitelist, whitelistPrefixes, passThroughHeaders, whitelistQueryParams, augmenters, decoderContext});
  }

  return {build};
}

function buildAspects(data, aspectFns, {whitelist, whitelistPrefixes, passThroughHeaders, whitelistQueryParams, augmenters, decoderContext}) {

  const store = new AspectStore();
  addRawAspect(store, data, {whitelist, whitelistPrefixes, passThroughHeaders, whitelistQueryParams, augmenters, decoderContext});

  const ret = aspectFns
    .map(aspectFn => aspectFn(data, store))
    .reduce((prev, curr) => {
      prev[curr.name] = curr;
      return prev;
    }, store);

  return Object.freeze(ret);
}

function addRawAspect(store, data, {whitelist, whitelistPrefixes, passThroughHeaders, whitelistQueryParams, augmenters, decoderContext}) {
  const aspect = createRawAspectFactory(whitelist, passThroughHeaders, whitelistPrefixes, whitelistQueryParams, decoderContext)(data);
  store[aspect.name] = aspect;
  const seed = {};
  const augmentations = augmenters.reduce((acc, augmenter) => {
    const replacement = augmenter.encoder.encode(augmenter.resolver(store.get(augmenter.decoder), store));
    return Object.assign(seed, replacement);
  }, {});
  if (Object.entries(augmentations).length > 0) {
    aspect._augment(augmentations);
  }
}

function isValidStore(obj) {
  return !!obj && obj.constructor.name === 'AspectStore';
}

class AspectStore {

  constructor(responseAspects = new ResponseAspects(), volatile = {}) {
    Object.defineProperty(this, '_volatile', {
      value: volatile
    });

    Object.defineProperty(this, '_responseAspects', {
      value: responseAspects
    });
  }

  get(decoder) {
    assert(decoder && decoder.decode && typeof decoder.decode === 'function', 'decoder is mandatory');
    return this.raw.get(decoder, this);
  }

  get volatile() {
    return this._volatile;
  }

  get responseAspects() {
    return this._responseAspects;
  }

  withoutAspect(drop) {
    assert(drop && typeof drop.dropKeys === 'function', 'DropSupport instance required');
    const replacements = _.mapValues(_.keyBy(drop.dropKeys(this.raw.inbound)), () => DROP);
    const newStore = createNewStore(this);
    copy(this, newStore, {raw: this.raw.copy(replacements)});
    return newStore;
  }

  withAspect(encoder, value) {
    validate(encoder, value);
    const newStore = createNewStore(this);
    let current;
    if (typeof encoder.decode === 'function') {
      current = this.get(encoder);
    }
    copy(this, newStore, {raw: this.raw.copy(encoder.encode(value, current))});
    return newStore;
  }

  withNewVolatile({clearResponseAspects = false} = {}) {
    const newStore = new AspectStore(clearResponseAspects ? undefined : this.responseAspects);
    copy(this, newStore);
    const allKeys = Object.keys(this.volatile).concat(Object.getOwnPropertySymbols(this.volatile));
    allKeys.forEach(key => newStore.volatile[key] = this.volatile[key]);
    return newStore;
  }
}

function copy(origin, target, overrides = {}) {
  for (let property in origin) {
    if (origin.hasOwnProperty(property)) {
      target[property] = overrides[property] ? overrides[property] : origin[property];
    }
  }
}

function validate(encoder, value) {
  assert(encoder && encoder.encode && typeof encoder.encode === 'function', 'encoder is mandatory');
  assert(typeof value !== 'undefined', 'value is mandatory');
}

function broadcast(encoder, value) {
  validate(encoder, value);
  this.raw.override(encoder.encode(value));
}

function createNewStore(store) {
  return store.withNewVolatile();
}

AspectStore.prototype.broadcast = util.deprecate(broadcast, 'AspectStore#broadcast is deprecated. Use AspectStore#withAspect instead.');

module.exports = {
  createStoreBuilder,
  createEmptyStore,
  isValidStore,
  AspectStore,
};
