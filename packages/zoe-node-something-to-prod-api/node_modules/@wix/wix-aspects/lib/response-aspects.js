const assert = require('assert'),
  _ = require('lodash');

const REMOTE_ASPECTS_MAX_ALLOWED_SIZE = 15000;

function validateEncoder(encoder) {
  assert(encoder && typeof encoder.encode === 'function', '"encoder" is mandatory and must have "encode" function');
}

function validateDecoder(decoder) {
  assert(decoder && typeof decoder.decode === 'function', '"decoder" is mandatory and must have "decode" function');
}

function validateMerger(mergeFn) {
  assert(mergeFn && typeof mergeFn === 'function', '"mergeFn" is mandatory and must be a function');
}

function validateAspect(aspect) {
  assert(aspect, '"aspect" is mandatory');
}

function validateRemoteAspects(remoteResponseAspects) {
  assert(Array.isArray(remoteResponseAspects) && remoteResponseAspects.every(e => typeof e === 'object'),
    'remoteAspects parameter is mandatory and must be an array of maps');
}

function withCaseInsensitiveKeys(storage) {
  const handler = {
    get: function (obj, prop) {
      const key = Object.keys(obj).find(key => key.toLowerCase() === prop.toLowerCase());
      if (key) {
        return obj[key];
      }
    }
  };

  return new Proxy(storage, handler);
}

function decodeWithCaseInsensitiveKey(decoder, map) {
  return decoder.decode(withCaseInsensitiveKeys(map));
}

class ResponseAspects {
  constructor() {
    this._local = {};
    this._remote = []; // Array of maps
  }

  appendAspect(aspect, {encoder, decoder, mergeFn} = {}) {
    validateAspect(aspect);
    validateEncoder(encoder);
    validateDecoder(decoder);
    validateMerger(mergeFn);

    const existingValue = decodeWithCaseInsensitiveKey(decoder, this._local);
    const newValue = existingValue === undefined ? aspect : mergeFn(existingValue, aspect);

    this._local = {...this._local, ...encoder.encode(newValue)};
  }

  appendRemoteAspects(remoteResponseAspects) {
    validateRemoteAspects(remoteResponseAspects);

    const nonEmptyRA = remoteResponseAspects.filter(m => !_.isEmpty(m));

    if (this._remote.length === nonEmptyRA.length && _.isEqual(this._remote, nonEmptyRA)) {
      // Existing RA are exactly the same - no need to duplicate
      return;
    }

    if (this._remote.length + nonEmptyRA.length > REMOTE_ASPECTS_MAX_ALLOWED_SIZE) {
      console.error(`You might reuse the same aspects objects for multiple calls. Most likely you should creating new aspect store for each logical transaction. Returned RA: ${JSON.stringify(nonEmptyRA)}`);
      const error = new Error(`Maximum allowed size of response aspects reached (${REMOTE_ASPECTS_MAX_ALLOWED_SIZE})`);
      error.details = {newRA: nonEmptyRA};
      throw error;
    }

    this._remote.push(...nonEmptyRA);
  }

  aspect({decoder, mergeFn}) {
    validateDecoder(decoder);
    validateMerger(mergeFn);

    return this.dump().map(e => decodeWithCaseInsensitiveKey(decoder, e)).reduce((acc, current) => mergeFn(acc, current), undefined);
  }

  dump() {
    return [this._local].concat(this._remote).filter(m => !_.isEmpty(m));
  }
}

module.exports = {ResponseAspects, REMOTE_ASPECTS_MAX_ALLOWED_SIZE};
