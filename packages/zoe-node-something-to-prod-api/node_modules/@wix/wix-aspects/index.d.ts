type Raw = Record<string, string>;

interface LanguageResolver {
  additionalLanguages: (store: AspectStore) => string[];
  regionalLanguages: (store: AspectStore) => string[];
}

interface DecoderContext {
  readonly languageResolver?: LanguageResolver;
}

interface DecoderOptions {
  readonly store: AspectStore;
  readonly http?: HttpData;
  readonly context?: DecoderContext;
}

interface StoreOptionsBase {
  readonly passThroughHeaders?: string[];
  readonly augmenters?: Array<Augmenter<any>>;
  readonly decoderContext?: DecoderContext;
}

export interface StoreOptions extends StoreOptionsBase, Whitelists {}

export interface StoreOptionsWithWhitelistsProvider extends StoreOptionsBase {
  readonly whitelistsProvider: WhitelistsProvider;
}

type WhitelistsProvider = () => Whitelists;

export interface Whitelists {
  readonly whitelist?: string[] | true;
  readonly whitelistQueryParams?: string[];
  readonly whitelistPrefixes?: string[];
}

export interface HttpData {
  readonly query?: Record<string, string[] | string>;
  readonly headers?: Raw;
  readonly cookies?: Raw;
  readonly url?: string;
  readonly originalUrl?: string;
  readonly remoteAddress?: string;
  readonly remotePort?: number;
}

export interface RequestData extends HttpData {
  readonly cookies?: Raw;
}

export interface StoreBuilder {
  build: (data: RequestData) => AspectStore;
}

export type AspectBuilder = (data: RequestData, store: AspectStore) => Aspect;

export class AspectStore {
  readonly [key: string]: any;
  get<T>(decoder: Decoder<T>): T;
  broadcast<T>(encoder: Encoder<T>, value: T): void;
  withAspect<T>(encoder: Encoder<T>, value: T): AspectStore;
  withoutAspect (drop: DropSupport): AspectStore;
  readonly responseAspects: ResponseAspects;
}

export class Aspect {
  readonly name: string;
  constructor (name: string, data: RequestData);
  export (): object;
  toJSON (): any;
  import (data: object): void;
  protected _setIfAny (source: any, target: object, key: number | string): void;
}

export function createEmptyStore (): AspectStore;
export function createStoreBuilder (aspectBuilders: AspectBuilder[], options: StoreOptions | StoreOptionsWithWhitelistsProvider): StoreBuilder;
export function isValidStore (store: any): boolean;

export interface Decoder<T> {
  decode: (data: Raw, options: DecoderOptions) => T;
}

export interface Encoder<T> {
  encode: (value: T, current?: T) => Raw;
}

export interface Augmenter<T> {
  decoder: Decoder<T>;
  encoder: Encoder<T>;
  resolver: (value: T, store: AspectStore) => T;
}

export const DEFAULT_WHITELIST: string[];
export const DEFAULT_QUERY_PARAMS_WHITELIST: string[];

export interface DropSupport {
  dropKeys: (raw: Raw) => string[];
}

// Response aspects - for internal libraries use

export interface ResponseAspectResolver<T> {
  decoder: Decoder<T>;
  encoder: Encoder<T>;

  mergeFn: (oldValue: T | undefined, newValue: T) => T;
}

type RawResponseAspects = Raw[];

export interface ResponseAspects {
  appendAspect: <T>(aspect: T, resolver: ResponseAspectResolver<T>) => void;
  appendRemoteAspects: (remoteAspects: RawResponseAspects) => void;
  aspect: <T>(resolver: ResponseAspectResolver<T>) => T;
  dump: () => RawResponseAspects;
}

type FlattenedPromise<T> = unknown extends T ? Promise<T> : T extends Promise<infer U> ? T : Promise<T>;

export const AspectsContext: {
  current: () => AspectStore | undefined;
  runWithAspects: (<T>(aspects: AspectStore, callback: () => T) => T) & (<T>(aspects: Promise<AspectStore>, callback: () => T) => FlattenedPromise<T>);
  runWithoutAspects: <T>(callback: () => T) => T;
};
