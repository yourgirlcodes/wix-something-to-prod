# raw aspects (aka aspects NG)

## old *deprecated* aspects

Old aspects (those that extend [`Aspect`](./README.md#aspectname-requestdata) base class) are bad because:
- are mutable
- require every hop along the chain of calls to be aware of it
- require custom serialization & deserialization code for each of the transports (REST, JSON-RPC, gRPC, kafka)

Those are deprecated and are replaced by raw aspects/aspects NG.

## raw aspects
Raw aspects solve the problems listed above:
- are immutable (to some extent)
- do not require each and every hop to be aware by utilizing conventions
- do not require custom serialization/deserialization code

## raw aspects - brief explanation

A boundary server (the one that accepts HTTP request from outside of wix DC) uses a whitelist (shared by both scala and node) to 
filter cookies, headers and query parameters, which will be propagated upon subsequent outgoing RPC/kafka calls by the infra code.

Raw aspects are immutable: 
- you can read the aspect value received
- you create a new instance of raw aspect with set/overridden value for outgoing interactions (RPC/kafka), if not explicitly overridden, the received value will be propagated.

**Note:** after overriding/setting new aspect value you cannot read it back. Instead read operation will return the incoming value present.

## raw aspects - example
The following example is in TypeScript for better comprehension, but applies to JavaScript as well.

_lib/NameAspect.ts_ (define your aspect here)
```typescript
import * as aspects from '..';

const HTTP_HEADER_FULL_NAME = 'x-wix-full-name';
const DELIMITER = '|';

export interface NameAspect {
  readonly first: string;
  readonly last: string;
}


/**
 * we assume here x-wix-full-name HTTP header is whitelisted
 */
class NameAspectCodec implements aspects.Decoder<NameAspect>, aspects.Encoder<NameAspect> {

  // implement your deserialization logic 
  decode(data: aspects.Raw): NameAspect {
    const fullName = data[HTTP_HEADER_FULL_NAME];
    const [first, last] = fullName.split(DELIMITER);
    return {first, last};
  }

  // implement your serialization logic
  encode(value: NameAspect): aspects.Raw {
    return {
      [HTTP_HEADER_FULL_NAME]: `${value.first}${DELIMITER}${value.last}`
    };
  }
}

export const NameAspect = new NameAspectCodec();
``` 

_lib/express-app.ts_ (using your aspect)
```typescript
import {AspectStore} from '..';
import {NameAspect} from "./lib/NameAspect";
import * as express from 'express';

type HasAspects = {
  aspects: AspectStore
}

// in your express route
app.get('/my-endpoint', (req: express.Request & HasAspects, res: express.Response, next: express.NextFunction) => {
  // read incoming value
  const name: NameAspect = req.aspects.get(NameAspect);
  
  // now let's override it.
  const aspects: AspectStore = req.aspects.withAspect(NameAspect, {first: 'Itay', last: 'Chechanovsky'});
});
```


  
