# wix-aspects

Commons for aspects - base `Aspect` class, aspect-store builder.

**Attention:** no aspect outside of the platform should extend the base `Aspect` class, since these are deprecated aspects.

If you have a valid use case for custom aspect, implement [decoder](#decoder) and encoder and use [`AspectStore#get`](#aspect-store-get) 
and [`AspectStore#withAspect`](#aspectstorewithaspectencoder-encodert-value-t-aspectstore) APIs.

Read [here](./raw-aspects.md) for explanation and detailed example. 
 
In **tests** the [@wix/wix-aspects-testkit](../../testing/wix-aspects-testkit) can be used to build an aspect store using convenient builder methods.

## install

```bash
npm install --save @wix/wix-aspects
```

## usage

Given you want to create a user agent aspect that provides user-agent:

```js
const Aspect = require('@wix/wix-aspects').Aspect;

class UserAgentAspect extends Aspect {
  constructor(requestData) {
    super('user-agent', requestData);
    this._aspect = { userAgent: requestData.headers['user-agent'] };
  }
  
  get userAgent() {
    return this._aspect.userAgent;
  }
}

module.exports = requestData => new UserAgentAspect(requestData); 
```

Then you can use this aspect to build a store:

```js
const aspects = require('@wix/wix-aspects'),
  userAgentAspect = require('user-agent-aspect');

module.exports = requestData => {
    const storeBuilder = aspects.createStoreBuilder([data => userAgentAspect(data)]);
    const store = storeBuilder.build(requestData);
    return store['user-agent-aspect'];
} 
```

## Api

### createStoreBuilder(aspectBuilders, opts): StoreBuilder
Instantiates a new `StoreBuilder` for given aspect builders and options

Parameters:
 - `aspectBuilders` - array of aspect builder functions.
 - `opts.whitelist` - array of strings - list of whitelisted cookie and headers names for raw aspect.
 - `opts.whitelistPrefixes` - array of strings - list of whitelisted prefixes of cookie and headers names for raw aspect.
 - `opts.whitelistQueryParams` - array of strings - list of whitelisted query param names for raw aspect. 
 - `opts.passThroughHeaders` - array of strings - list of whitelisted header names, which will be passed through upon downstream calls without any access and/or mutation. Supports wildcards via [matcher](https://www.npmjs.com/package/matcher) lib.
 - `opts.augmenters` - optional, array of [`Augmenter<T>`](#augmenter) instances
 - `opts.decoderContext` - optional, additional context for [decoder](#decoder)
 - `opts.whitelistsProvider` - A function returning the whitelists to use. if passed, then any values passed in `opts.whitelist`, `opts.whitelistPrefixes`, `opts.whitelistQueryParams` is ignored.
    Note that this function runs every time an aspect store is built


### StoreBuilder#build(requestData): AspectStore
Builds AspectStore for given request data.

### createEmptyStore(): AspectStore
Creates an _empty_ AspectStore.

### isValidStore(aspects): boolean
Checks that the `aspects` object is an instance of an AspectStore.

### utils.resolveCookieDomain(url): String
Resolves a domain to set on cookie from provided url, ex. `.wix.com`.

Supported domains are: `wix.com`, `editorx.com`, `wixsite.com` and `<staging>.wixpress.com`.

Defaults to `wix.com` upon no match.

### DEFAULT_WHITELIST: String[]
Exported header name whitelist for development environment.

### DEFAULT_WHITELIST_QUERY_PARAMS: String[]
Exported query param whitelist for development environment. 

### Aspect(name, requestData)
Base class for all aspects.

#### Aspect.name: String
Returns a name of an aspect

#### Aspect.import(data)
Mutate aspect by providing it `data` in a following format:
 - headers - optional, map of headers;
 - cookies - optional, map of cookies;

This allows to mutate/augment aspect during its lifetime by importing headers/cookies from intermediate http/rpc calls.

#### Aspect.export(): Object
Export content of aspect.

Response: 
    - object containing:
    - headers: object containing headers, ex. '{key: 'value'}';
    - cookies: array containing cookie object in a format:
        - name: cookie name;
        - value: cookie value;
        - properties: object that conforms to: [express cookie properties](http://expressjs.com/en/4x/api.html#res.cookie).

### AspectStore class

#### AspectStore#broadcast(encoder: Encoder\<T\>, value: T): void
**deprecated** - use [`AspectStore#withAspect`](#aspectstorewithaspectencoder-encodert-value-t-aspectstore) instead.

Add new or replace existing raw aspect value. This value won't be available via [`#get`](#aspect-store-get) API and holds only for outbound calls (RPC/Greyhound).

#### AspectStore#withAspect(encoder: Encoder\<T\>, value: T): AspectStore
Create a new instance of `AspectStore` with added (replaced if defined) aspect value. This value won't be available via [`#get`](#aspect-store-get) API and holds only for outbound calls (RPC/Greyhound).

#### AspectStore#withoutAspect(encoder: DropSupport): AspectStore
Create a new instance of `AspectStore` with removed aspect - will be removed in outgoing calls only. 

#### <a name="aspect-store-get"></a>AspectStore#get(decoder: Decoder\<T\>): T
Get raw aspect value for given [decoder](#decoder) instance.

#### AspectStore#volatile: { [string]: any }
Data bag for incoming request bound data.

**Attention: to be used only inside the platform code** 

#### AspectStore#withNewVolatile({clearResponseAspects = false}): AspectStore
Creates a _shallow_ copy of the passed AspectStore with a *deep* copy of the `volatile` data bag.
Accepts options:
 - `clearResponseAspects` - (_boolean_, optional) - when set to `true`, the response aspects will not be copied from the original aspects but a new Response Aspects store will be created (default to `false`) 

#### AspectStore#responseAspects: ResponseAspects
***[For internal infrastructural libraries use ONLY]***

Returns an instance of the `ResponseAspects` object associated with this aspects store. 

### `RawAspect`

#### `RawAspect#_augment(inbound: object): void`
**INTERNAL API! DO NOT USE!!!**

Augments `raw.inbound` with additional data resolved at later stage (see [wix-bootstrap-bi-page-view](../../bootstrap/wix-bootstrap-bi-page-view)).

#### `RawAspect#_decrease(key: string): void`
**INTERNAL API! DO NOT USE!!!**

Removes given `key` from `raw.inbound`.

<a name="ra"></a>
#### `ResponseAspects` 
The storage for back-propagated aspects (like _Petri_). 
More info about _Response Aspects_ is available [here](https://github.com/wix-private/server-infra/blob/master/framework/grpc/infra/README-aspects.md#response-aspects-only-for-core-libraries).

##### ResponseAspects#appendAspect(aspect, opts: object)
Appends a response aspect to the local (mutable) aspects map.

 - `aspect`  - an aspect to add to the store

`opts` should contain:
 - `encoder` - instance of [`Decoder`](#decoder)    
 - `decoder` - an object containing method `decode({string: string}): aspect ` - accepting aspect's representation as a flat object with both key and value being strings, and returning the decoded aspect.
 - `mergeFn` - a function accepting two aspects and returning an aspect representing the result of merging those two.
 
##### ResponseAspects#appendRemoteAspects(remoteResponseAspects: [object])
Appends a passed array of remote aspects to the remote store (where each added item is immutable).

 - `remoteResponseAspects` - an array of flat object with key and value being strings representing encoded aspect 

##### ResponseAspects#aspect(opts: object): aspect
Retrieves an aspect from the remote aspects store (both local and remote) by applying passed options. 
Return an aspect or `undefined` if the aspect was not found available.

opts` should contain:
 - `decoder` - instance of [`Decoder`](#decoder)
 - `mergeFn` - a function accepting two aspects and returning an aspect representing the result of merging those two.
 
##### ResponseAspects#dump(): [object]
Returns and array of flat objects representing response aspects. Array contains both local and remote aspects. Local aspects (if exist) are added at the beginning of the array.

##### Augmenter
Useful for augmenting the `AspectStore` with additional synthetic values (ie the `request_id` - either in headers/query params or generated if missing in the incoming message/request) 

```typescript
  export interface Augmenter<T> {
    decoder: Decoder<T>;
    encoder: Encoder<T>;
    resolver: (value: T, store: AspectStore) => T;
  }
```           

##### Decoder

Decoder used to read aspect from the `AspectStore` via [`AspectStore#get`](#aspect-store-get) API.

```typescript
export interface Decoder<T> {
  decode(data: Raw, options: DecoderOptions): T;
}

type Raw = { [key: string]: string };

interface DecoderOptions {
  readonly store: AspectStore;
  readonly http?: HttpData;
  readonly context?: DecoderContext
}

export interface HttpData {
  readonly query?: { [k: string]: string | string[] };
  readonly url?: string;
  readonly originalUrl?: string;
  readonly remoteAddress?: string;
  readonly remotePort?: number;
}

interface LanguageResolver {
  additionalLanguages(): string[];
  regionalLanguages(): string[];
}

interface DecoderContext {
  readonly languageResolver: LanguageResolver;
}
```

where `decode` method arguments are:
 - `data: Raw` - dictionary of whitelisted aspects
 - `options.store: AspectStore` - instance of current [`AspectStore`](#aspectstore-class)
 - `options.http?: HttpData` - additional data available **in HTTP flows only** (eg express.js, protobuf-REST, JSON-RPC)
 - `options.context?: DecoderContext` - additional context for decoder which is not part of the incoming request

<a name="aspectless"></a> 
### EXPERIMENTAL: Aspectless

Aspectless refers to using bootstrap APIs without `aspects`, thus reducing "aspects-pollution" in your code.   
Aspectless APIs allow you to avoid passing the aspects to every piece of code that might need it and instead relay on the framework to use the implicit "current" aspects.

If you need to modify the aspects in any way (server-signing / custom-aspects / etc.) you can set the "current" aspects using [`AspectsContext`](#aspects-context).
  
The following APIs will try to use `AspectsContext.current()` when called without aspects:
* [grpc-client](../../rpc/wix-grpc-client#aspectless-client)
* [json-rpc-client](../../rpc/wix-json-rpc-client#aspectless-client)
* [Greyhound Producers](../../bootstrap-plugins/greyhound/wix-bootstrap-greyhound#aspectless-producer)

<a name="aspects-context"></a> 
### EXPERIMENTAL: AspectsContext

`AspectsContext` provides some static utilities for interacting with the "current" aspects.  

*"current"* aspects are the aspects currently stored in the `AsyncLocalStorage` managed by `AspectsContext`.  
 They are available throughout the execution of your code, sync and async.  

[`AspectsContext.runWithAspects`](#aspects-context-runWithAspects) runs `callback` in a context where [Aspectless](#aspectless) APIs are available.

<a name="aspects-context-availability"></a>
The following APIs use `AspectsContext.runWithAspects()` to allow using supported APIs in an [Aspectless](#aspectless) manner:
* `express` - route handlers
* `json-rpc-server` - method implementations
* `grpc-server` - method implementations
* in [Greyhound](../../bootstrap-plugins/greyhound/wix-bootstrap-greyhound#aspectless) `Consumer`/`TypedConsumer`/`LegacyConsumer`
 
*"current"* aspects are not available:
* in Greyhound `BatchedConsumer`
* async flows (e.g. `setTimeout` and friends) that did not originate from a context where "current" aspects are available.

*"current"* aspects are set by the framework and are equal to the `aspects` you get in your handler code.
```typescript
import {AspectsContext} from '@wix/wix-aspects';

// gRPC/JSON-RPC server
export class SomeService extends com.wix.Service { 
  sayHello(aspects: AspectStore, req: com.wix.Request): Promise<com.wix.Response> {
    // AspectsContext.current() === aspects  
  }
}

// Express server
app.get('/my-route', (req, res) => {
  // AspectsContext.current() === req.aspects
});
```

### API

#### `AspectsContext.current(): AspectStore | undefined`

Returns the *"current"* aspects or `undefined` if not available.

<a name="aspects-context-runWithAspects"></a>
#### `AspectsContext.runWithAspects<T>(aspects: AspectStore, callback: () => T): T`
#### `AspectsContext.runWithAspects<T>(aspects: Promise<AspectStore>, callback: () => T): Promise<T>`

When `aspects` is a valid `AspectStore` we run `callback` synchronously with `aspects` available as `AspectsContext.current()` for the execution of `callback` and all asynchronous operations created within `callback` and return `callback`s return value.

If `aspects` is a `Promise<AspectStore>`, we first resolve the promise, then call run `callback` as above.   
In this case `runWithAspects` returns a promise of the return value of `callback`.  

#### `AspectsContext.runWithoutAspects<T>(fn: () => T): T`

Runs `callback` synchronously with `AspectsContext.current() === undefined` for the execution of `callback` and all asynchronous operations created within `callback` and return `callback`s return value.  

_AspectsContext API Example:_
```typescript
const aspects: AspectStore = AspectsContext.current();
const myAspectsWithCustomData: AspectStore = aspects.withAspect({encode: ...}, data);

// AspectsContext.current() === aspects

const res = await AspectsContext.runWithAspects(myAspectsWithCustomData, async () => {
    // AspectsContext.current() === myAspectsWithCustomData

    await AspectsContext.runWithoutAspects(() => {
        // AspectsContext.current() === undefined
        // Aspectless gRPC will fail with "Unable to retrieve valid aspects for call" 
        return myGrpcClient.sayHello({greeting: 'hello'});
    });

    // AspectsContext.current() === myAspectsWithCustomData
    // Aspectless gRPC call will use AspectsContext.current(), therefore using myAspectsWithCustomData
    return myGrpcClient.sayHello({greeting: 'hello'}); 
});

// AspectsContext.current() === aspects
```

### Aspect(name, requestData)
Base class for all aspects.

#### Aspect.name: String
Returns a name of an aspect

#### Aspect.import(data)
Mutate aspect by providing it `data` in a following format:
 - headers - optional, map of headers;
 - cookies - optional, map of cookies;

This allows to mutate/augment aspect during its lifetime by importing headers/cookies from intermediate http/rpc calls.

#### Aspect.export(): Object
Export content of aspect.

Response: 
    - object containing:
    - headers: object containing headers, ex. '{key: 'value'}';
    - cookies: array containing cookie object in a format:
        - name: cookie name;
        - value: cookie value;
        - properties: object that conforms to: [express cookie properties](http://expressjs.com/en/4x/api.html#res.cookie).

