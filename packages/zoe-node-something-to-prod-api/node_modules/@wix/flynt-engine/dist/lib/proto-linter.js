"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtoLinter = void 0;
const index_1 = require("../index");
const assert_1 = __importDefault(require("assert"));
const lint_rule_context_1 = require("./lint-rule-context");
const stateful_lint_rule_context_1 = require("./stateful/stateful-lint-rule-context");
const debug_1 = __importDefault(require("debug"));
const rule_severity_1 = require("./rule-severity");
const log = (0, debug_1.default)('wix:flynt:proto-linter');
class ProtoLinter {
    constructor(config) {
        (0, assert_1.default)(config.catalog, 'catalog is required');
        (0, assert_1.default)(config.rules, 'rules config is required');
        this._config = config;
    }
    async lint(proto, prevProto) {
        this.validateProtoModule(proto, 'proto');
        this.validateProtoModule(prevProto, 'prevProto');
        const catalog = await this.getCatalog();
        const loadedRules = await Promise.all(catalog.ruleDefinitions.map(ruleDef => this.loadRule(ruleDef)));
        const enabledRules = loadedRules.filter(loadedRule => loadedRule.severity !== index_1.Severity.Off);
        log('loading and running all rules');
        const results = (await Promise.all(enabledRules.map(loadedRule => this.executeRule(loadedRule, catalog, proto, prevProto)))).filter(notEmpty);
        log('preparing results');
        const res = {
            executionErrors: extractAndFlatten(results, res => res.executionErrors),
            results: extractAndFlatten(results, res => res.results).sort(compareFileNameAndRuleId),
            disabled: extractAndFlatten(results, res => res.disabled),
        };
        log('finished running all rules');
        return res;
    }
    async loadRule(ruleDef) {
        const rule = await ruleDef.getRule();
        const severity = this.getSeverity(ruleDef, rule);
        return { ruleDef, rule, ...severity };
    }
    async executeRule(loadedRule, catalog, proto, prevProto) {
        const { rule, ruleDef } = loadedRule;
        try {
            if (rule.stateful && !prevProto) {
                return;
            }
            const runResults = await this.runRule(rule, ruleDef, proto, prevProto);
            let results = [];
            if (runResults.lintResults.length > 0) {
                const ruleDocPath = await ruleDef.getDocPath();
                const ruleDoc = catalog.getDocUrl(ruleDocPath);
                const { severity, gracePeriod } = loadedRule;
                results = runResults.lintResults.map(ruleResult => ({ ...ruleResult, severity, gracePeriod, ruleId: ruleDef.name, ruleDoc, strict: rule.strict }));
                if (!rule.stateful && rule.breakIfNew && severity !== index_1.Severity.Error && prevProto) {
                    await this.updateNewResultsToError(results, rule, ruleDef, prevProto);
                }
            }
            const disabled = runResults.disabledReports.map(disabledReport => ({ ...disabledReport, ruleId: ruleDef.name }));
            return {
                results,
                disabled,
                executionErrors: [],
            };
        }
        catch (err) {
            console.error(`error in rule ${ruleDef.name}`, err);
            return {
                results: [],
                disabled: [],
                executionErrors: [{ ruleId: ruleDef.name, error: `${err}`, }],
            };
        }
    }
    runRule(rule, ruleDef, proto, prevProto) {
        let ctx;
        if (rule.stateful) {
            (0, assert_1.default)(prevProto);
            ctx = new stateful_lint_rule_context_1.StatefulLintRuleContextImpl(ruleDef.name, rule, { cwd: proto.moduleDir, protoDir: proto.protoDir }, proto.st, prevProto.st);
        }
        else {
            ctx = new lint_rule_context_1.StaticLintRuleContextImpl(ruleDef.name, rule, { cwd: proto.moduleDir, protoDir: proto.protoDir }, proto.st);
        }
        return ctx.run();
    }
    async updateNewResultsToError(results, rule, ruleDef, proto) {
        const ruleResults = await this.runRule(rule, ruleDef, proto);
        const oldResultIds = new Set(ruleResults.lintResults.map(res => res.resultId).filter(notEmpty));
        results.forEach(res => {
            if (res.resultId && !oldResultIds.has(res.resultId)) {
                res.severity = index_1.Severity.Error;
            }
        });
    }
    validateProtoModule(proto, name) {
        if (proto) {
            (0, assert_1.default)(proto.st, `${name}.st is required`);
            (0, assert_1.default)(proto.moduleDir, `${name}.moduleDir is required`);
            (0, assert_1.default)(proto.protoDir, `${name}.protoDir is required`);
        }
    }
    getSeverity(ruleDef, rule) {
        if (!rule.strict) {
            const ruleConfigSeverity = this._config.rules[ruleDef.name];
            if (ruleConfigSeverity) {
                return { severity: ruleConfigSeverity };
            }
            const defaultSeverity = this._config.severity;
            if (defaultSeverity) {
                return { severity: defaultSeverity };
            }
        }
        return (0, rule_severity_1.getRuleSeverity)(rule, this._config.date);
    }
    async getCatalog() {
        if (typeof this._config.catalog === 'string') {
            log(`loading catalog ${this._config.catalog}`);
            const { FsCatalog } = await Promise.resolve().then(() => __importStar(require('./fs-catalog')));
            return new FsCatalog(this._config.catalog);
        }
        else {
            log('using preloaded catalog');
            return this._config.catalog;
        }
    }
}
exports.ProtoLinter = ProtoLinter;
function compareFileNameAndRuleId(a, b) {
    return (a.filePath || '').localeCompare(b.filePath || '') ||
        a.ruleId.localeCompare(b.ruleId);
}
function notEmpty(t) {
    return !!t;
}
function extractAndFlatten(results, map) {
    return results.map(map).flat();
}
//# sourceMappingURL=proto-linter.js.map