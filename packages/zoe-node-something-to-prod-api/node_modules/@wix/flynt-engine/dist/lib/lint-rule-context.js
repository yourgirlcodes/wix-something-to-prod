"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticLintRuleContextImpl = exports.LintRuleContextImpl = void 0;
const proto_syntax_tree_1 = require("@wix/proto-syntax-tree");
const comment_parser_1 = require("./comment-parser");
class LintRuleContextImpl {
    constructor(ruleName, rule, config, st) {
        this._errMessage = rule.description;
        this._ruleName = ruleName;
        this._config = config;
        this.st = st;
        this.results = [];
        this.disabledReports = [];
        this.rule = rule;
    }
    get moduleDir() {
        return this._config.cwd;
    }
    get protoDir() {
        return this._config.protoDir;
    }
    async run() {
        await this.runRule();
        return {
            lintResults: this.results,
            disabledReports: this.disabledReports,
        };
    }
    report({ errorAt, message } = {}) {
        let srcCodeInfo;
        if (errorAt) {
            if ('sourceCode' in errorAt) {
                srcCodeInfo = errorAt.sourceCode;
            }
            else {
                srcCodeInfo = errorAt;
            }
        }
        message = message || this._errMessage;
        if (srcCodeInfo) {
            const location = {
                resultId: srcCodeInfo.fqn,
                filePath: srcCodeInfo.container.file.path,
                line: srcCodeInfo.startLine,
                column: srcCodeInfo.startColumn,
            };
            const disableLocation = this.checkIfCurrentRuleDisabled(srcCodeInfo);
            if (disableLocation) {
                const disabledBy = {
                    id: disableLocation.fqn,
                    line: disableLocation.startLine,
                };
                this.disabledReports.push({ ...location, disabledBy });
            }
            else {
                this.results.push({ ...location, message });
            }
        }
        else {
            this.results.push({ message });
        }
    }
    visitFrom(node, visitor) {
        if (node.file.protoFolder === proto_syntax_tree_1.ProtoFolderType.MainProtoFolder) {
            (0, proto_syntax_tree_1.visitSyntaxTreeFrom)(node, this.skipNonLintedElements(visitor));
        }
    }
    visit(visitor) {
        (0, proto_syntax_tree_1.visitSyntaxTree)(this.st, this.skipNonLintedElements(visitor));
    }
    skipNonLintedElements(visitor) {
        return (0, proto_syntax_tree_1.skip)(visitor, {
            visitFile(file) {
                return file.protoFolder === proto_syntax_tree_1.ProtoFolderType.MainProtoFolder;
            },
            visitMessage(message) {
                return !message.isMapEntry;
            },
            visitOneof(oneof) {
                if (oneof.fields.length === 1 && oneof.fields[0].proto3Optional) {
                    return false;
                }
            }
        });
    }
    assert(value, rep = {}) {
        if (!value) {
            this.report(rep);
        }
        return !!value;
    }
    reportIf(value, rep = {}) {
        if (value) {
            this.report(rep);
        }
        return !!value;
    }
    checkIfCurrentRuleDisabled(sourceCodeInfo) {
        if (!this.rule.strict) {
            if ((0, comment_parser_1.isRuleDisabled)(sourceCodeInfo, this._ruleName)) {
                return sourceCodeInfo;
            }
            else if ((0, comment_parser_1.isRuleDisabled)(sourceCodeInfo.container.file.detailedSourceCode.syntax, this._ruleName)) {
                return sourceCodeInfo.container.file.detailedSourceCode.syntax;
            }
        }
    }
    assertTypeExists(fqn, typeName, rep = {}) {
        let message = (rep.message || '') + ` - Invalid fqn: ${fqn}`;
        this.assert(fqn, { ...rep, message });
        if (fqn) {
            if (typeName !== proto_syntax_tree_1.TypeName.File && !fqn.startsWith('.')) {
                fqn = '.' + fqn;
            }
            message = (rep.message || '') + ` - Type not found: ${fqn}`;
            const type = this.st.findType(fqn);
            this.assert(type, { ...rep, message });
            if (type) {
                message = (rep.message || '') + ` - Expected ${fqn} to be a ${typeName} but it is a ${type.typeName}`;
                this.assert(type.typeName === typeName, { ...rep, message });
            }
        }
    }
}
exports.LintRuleContextImpl = LintRuleContextImpl;
class StaticLintRuleContextImpl extends LintRuleContextImpl {
    async runRule() {
        await this.rule.run(this);
    }
}
exports.StaticLintRuleContextImpl = StaticLintRuleContextImpl;
//# sourceMappingURL=lint-rule-context.js.map