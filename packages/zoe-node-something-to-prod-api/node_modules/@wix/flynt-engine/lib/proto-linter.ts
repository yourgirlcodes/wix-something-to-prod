import {
  Catalog,
  GracePeriod,
  LintConfig,
  Linter,
  LintResult,
  LintResults,
  LintRule,
  ProtoModule,
  RuleDefinition,
  Severity,
  StaticLintRule
} from '../index';
import assert from 'assert';
import {RunResults, StaticLintRuleContextImpl} from './lint-rule-context';
import {StatefulLintRuleContextImpl} from './stateful/stateful-lint-rule-context';
import debug from 'debug';
import {getRuleSeverity} from './rule-severity';
import {Mutable} from 'type-fest';

const log = debug('wix:flynt:proto-linter');

type LoadedRule = {
  ruleDef: RuleDefinition;
  rule: LintRule;
  severity: Severity;
  gracePeriod?: GracePeriod;
};

export class ProtoLinter implements Linter {
  private readonly _config: LintConfig;

  constructor(config: LintConfig) {
    assert(config.catalog, 'catalog is required');
    assert(config.rules, 'rules config is required');
    this._config = config;
  }

  async lint(proto: ProtoModule, prevProto?: ProtoModule): Promise<LintResults> {
    this.validateProtoModule(proto, 'proto');
    this.validateProtoModule(prevProto, 'prevProto');

    const catalog = await this.getCatalog();
    //load all rules
    const loadedRules = await Promise.all(catalog.ruleDefinitions.map(ruleDef => this.loadRule(ruleDef)));
    //Filter disabled rules
    const enabledRules = loadedRules.filter(loadedRule => loadedRule.severity !== Severity.Off);

    log('loading and running all rules');
    const results = (await Promise.all(enabledRules.map(loadedRule => this.executeRule(loadedRule, catalog, proto, prevProto)))).filter(notEmpty);

    log('preparing results');
    const res: LintResults = {
      executionErrors: extractAndFlatten(results, res => res.executionErrors),
      results: extractAndFlatten(results, res => res.results).sort(compareFileNameAndRuleId),
      disabled: extractAndFlatten(results, res => res.disabled),
    };
    log('finished running all rules');
    return res;
  }

  private async loadRule(ruleDef: RuleDefinition): Promise<LoadedRule> {
    const rule = await ruleDef.getRule();
    const severity = this.getSeverity(ruleDef, rule);
    return {ruleDef, rule, ...severity};
  }

  private async executeRule(loadedRule: LoadedRule, catalog: Catalog, proto: ProtoModule, prevProto: ProtoModule | undefined): Promise<LintResults | undefined> {
    const {rule, ruleDef} = loadedRule;
    try {
      if (rule.stateful && !prevProto) {
        return;
      }

      const runResults = await this.runRule(rule, ruleDef, proto, prevProto);

      let results: LintResult[] = [];
      if (runResults.lintResults.length > 0) {
        const ruleDocPath = await ruleDef.getDocPath();
        const ruleDoc = catalog.getDocUrl(ruleDocPath);
        const {severity, gracePeriod} = loadedRule;
        results = runResults.lintResults.map(ruleResult => ({...ruleResult, severity, gracePeriod, ruleId: ruleDef.name, ruleDoc, strict: rule.strict}));

        if (!rule.stateful && rule.breakIfNew && severity !== Severity.Error && prevProto) {
          await this.updateNewResultsToError(results, rule, ruleDef, prevProto);
        }
      }
      const disabled = runResults.disabledReports.map(disabledReport => ({...disabledReport, ruleId: ruleDef.name}));

      return {
        results,
        disabled,
        executionErrors: [],
      };

    } catch (err) {
      console.error(`error in rule ${ruleDef.name}`, err);
      return {
        results: [],
        disabled: [],
        executionErrors: [{ruleId: ruleDef.name, error: `${err}`,}],
      };
    }
  }

  private runRule(rule: LintRule, ruleDef: RuleDefinition, proto: ProtoModule, prevProto?: ProtoModule): Promise<RunResults> {
    let ctx;
    if (rule.stateful) {
      assert(prevProto);
      ctx = new StatefulLintRuleContextImpl(ruleDef.name, rule, {cwd: proto.moduleDir, protoDir: proto.protoDir}, proto.st, prevProto.st);
    } else {
      ctx = new StaticLintRuleContextImpl(ruleDef.name, rule, {cwd: proto.moduleDir, protoDir: proto.protoDir}, proto.st);
    }
    return ctx.run();
  }

  private async updateNewResultsToError(results: Mutable<LintResult>[], rule: StaticLintRule, ruleDef: RuleDefinition, proto: ProtoModule) {
    const ruleResults = await this.runRule(rule, ruleDef, proto);
    const oldResultIds = new Set(ruleResults.lintResults.map(res => res.resultId).filter(notEmpty));
    results.forEach(res => {
      if (res.resultId && !oldResultIds.has(res.resultId)) {
        res.severity = Severity.Error;
      }
    });
  }

  private validateProtoModule(proto: ProtoModule | undefined, name: string) {
    if (proto) {
      assert(proto.st, `${name}.st is required`);
      assert(proto.moduleDir, `${name}.moduleDir is required`);
      assert(proto.protoDir, `${name}.protoDir is required`);
    }
  }

  private getSeverity(ruleDef: RuleDefinition, rule: LintRule): {severity: Severity; gracePeriod?: GracePeriod} {
    if (!rule.strict) {
      const ruleConfigSeverity = this._config.rules[ruleDef.name];
      if (ruleConfigSeverity) {
        return {severity: ruleConfigSeverity};
      }

      const defaultSeverity = this._config.severity;
      if (defaultSeverity) {
        return {severity: defaultSeverity};
      }
    }

    return getRuleSeverity(rule, this._config.date);
  }

  private async getCatalog(): Promise<Catalog> {
    if (typeof this._config.catalog === 'string') {
      log(`loading catalog ${this._config.catalog}`);
      const {FsCatalog} = await import('./fs-catalog');
      return new FsCatalog(this._config.catalog);
    } else {
      log('using preloaded catalog');
      return this._config.catalog;
    }
  }
}

// function isRuleError(res: LintResult[] | RuleError | undefined): res is RuleError {
//   return (res !== undefined && 'error' in res);
// }
//
// function isLintResult(res: LintResult[] | RuleError | undefined): res is LintResult[] {
//   return Array.isArray(res);
// }

function compareFileNameAndRuleId(a: LintResult, b: LintResult) {
  return (a.filePath || '').localeCompare(b.filePath || '') ||
    a.ruleId.localeCompare(b.ruleId);
}

function notEmpty<T>(t: T | undefined): t is T {
  return !!t;
}

function extractAndFlatten<T, U>(results: T[], map: (value: T) => U[]): U[] {
  return results.map(map).flat();
}
