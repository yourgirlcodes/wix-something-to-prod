import {Type, TypeName, VisitMethods, Visitor, visitorContainerMethods, visitorMethods} from '@wix/proto-syntax-tree';
import {AddedVisitor, ModifiedVisitor, RemovedVisitor, ShouldVisit, StatefulVisitor} from '../stateful/rule-api';
import {NewStateProvider, PrevStateProvider} from './state-provider';

type VisitFunc = (elem: Type) => void;
type StatefulVisitFunc = (elem: Type, prevState?: Type) => void | boolean;
type VisitWithParent = (elem: Type, parent?: Type) => void;
type ShouldVisitFunc = (elem: Type) => boolean;

type NotUndef<F> = F extends undefined ? never : F;

export type ShouldVisitMethods = {
  [K in keyof ShouldVisit]-?: NotUndef<ShouldVisit[K]> extends (elem: infer E) => boolean ? K : never
}[keyof ShouldVisit];

const shouldVisitMap: Record<VisitMethods, ShouldVisitMethods | undefined> = {
  visitFile: 'shouldVisitFile',
  visitService: 'shouldVisitService',
  visitMessage: 'shouldVisitMessage',
  visitEnum: 'shouldVisitEnum',
  visitMethod: undefined,
  visitField: undefined,
  visitOneof: undefined,
  visitEnumValue: undefined,
  visitExtension: undefined,
};

function getShouldVisitMethod(visitor: ShouldVisit, method: VisitMethods) {
  const shouldVisitMethod = shouldVisitMap[method];
  if (shouldVisitMethod) {
    return visitor[shouldVisitMethod] as ShouldVisitFunc;
  }
}

//Description: Visitor which visits all current nodes and provide both current state and prev state of a node (if it exists)
//New nodes will be visited but removed nodes will not be visited
//Optimization: If a Visit method does not need the previous state, this adapter will not try to retrieve it
//How:
//When visiting the "current" tree:
//if the target visit method accepts previous state:
// - check if previous state exists and pass it to the method otherwise pass undefined
//if the target visit method does not accept previous state:
// - pass current node
export function adaptStatefulVisitor(visitor: StatefulVisitor, ctx: PrevStateProvider): Visitor {
  const result: Visitor = {};

  for (const method of visitorMethods) {
    const func = visitor[method] as StatefulVisitFunc;
    if (func) {
      if (func.length === 1) {
        //This is a visit method in the form `visit(elem: ..)` so no need to get previous state
        result[method] = function (elem) {
          return func.call(visitor, elem);
        };
      } else {
        //This is a visit method in the form `visit(elem: .., prevElem: ...)` so previous state is needed
        result[method] = function (elem) {
          const prevState = ctx.getPrevState(elem);
          return func.call(visitor, elem, prevState);
        };
      }

    }
  }
  return result;
}

//Description: Visitor which visits only nodes which have both current state and prev state
//New nodes and removed nodes will not be visited
//Note: We do not really check is a node was modified. This is the responsibility of user code
//How:
//When visiting the "current" tree:
//If a target visit method is implemented, check if previous state exists
//If previous state exists, call the target visit method and pass it the previous state
//If a shouldVisit method is implemented and returns false, an element and its children are skipped
export function adaptModifiedVisitor(visitor: ModifiedVisitor, ctx: PrevStateProvider): Visitor {
  const result: Visitor = {};

  for (const method of visitorMethods) {
    const func = visitor[method] as StatefulVisitFunc;
    const shouldVisit = getShouldVisitMethod(visitor, method);
    if (func) {
      result[method] = function (elem) {
        if (shouldVisit && !shouldVisit.call(visitor, elem)) {
          return false;
        }
        const prevState = ctx.getPrevState(elem);
        if (prevState) {
          return func.call(visitor, elem, prevState);
        }
      };
    } else if (shouldVisit) {
      result[method] = function (elem) {
        return shouldVisit.call(visitor, elem);
      };
    }
  }
  return result;
}

//Description: Visitor which visits only new nodes. We treat nodes as new if they do not have a prev state
//If a new node has sub nodes (for example when adding a new proto message with fields), only the container
//will be visited (i.e. the message).
//How:
//When visiting the "current" tree:
//If the visitor implemented a visit method OR the method is a container visit method
//Check if a previous state exists and if it does not exist:
//- If a target visit method is implemented call it and return false to skip sub elements
//- If a target visit method is not implemented just return false to skip sub elements
//If a shouldVisit method is implemented and returns false, an element and its children are skipped
export function adaptAddedVisitor(visitor: AddedVisitor, ctx: PrevStateProvider): Visitor {
  const result: Visitor = {};

  for (const method of visitorMethods) {
    const func = visitor[method] as VisitFunc;
    const shouldVisit = getShouldVisitMethod(visitor, method);
    if (func) {
      result[method] = function (elem) {
        if (shouldVisit && !shouldVisit.call(visitor, elem)) {
          return false;
        }
        const prevState = ctx.getPrevState(elem);
        if (!prevState) {
          func.call(visitor, elem);
          return false;
        }
      };
    } else {
      const isContainer = visitorContainerMethods.includes(method);
      if (isContainer || shouldVisit) {
        result[method] = function (elem) {
          if (shouldVisit && !shouldVisit.call(visitor, elem)) {
            return false;
          }
          if (isContainer && !ctx.getPrevState(elem)) {
            return false;
          }
        };
      }
    }
  }
  return result;
}

//Description: Visitor which visits only removed nodes. We treat nodes as removed if they do not have a new state
//If a removed node has sub nodes (for example when removing a proto message with fields), only the container
//will be visited (i.e. the message). The visit method receives the removed node and the *current* parent from
//where it was removed
//Optimization: If a Visit method does not need the parent state, this adapter will not try to retrieve it
//How:
//When visiting the "previous" tree:
//If the visitor implemented a visit method OR the method is a container visit method
//Check if a new state exists and if it does not exist:
//- If a target visit method is implemented call it and return false to skip sub elements
//- If a target visit method is not implemented just return false to skip sub elements
//If a shouldVisit method is implemented and returns false, an element and its children are skipped
export function adaptRemovedVisitor(visitor: RemovedVisitor, ctx: NewStateProvider): Visitor {
  const result: Visitor = {};

  for (const method of visitorMethods) {
    const func = visitor[method] as VisitWithParent;
    const shouldVisit = getShouldVisitMethod(visitor, method);
    if (func) {
      result[method] = function (elem) {
        if (shouldVisit && !shouldVisit.call(visitor, elem)) {
          return false;
        }
        const newState = ctx.getNewState(elem);
        if (!newState) {
          if (elem.typeName === TypeName.File || func.length === 1) {
            func.call(visitor, elem);
          } else {
            const parent = ctx.getNewState(elem.parent);
            func.call(visitor, elem, parent);
          }
          return false;
        }
      };
    } else {
      const isContainer = visitorContainerMethods.includes(method);
      if (isContainer || shouldVisit) {
        result[method] = function (elem) {
          if (shouldVisit && !shouldVisit.call(visitor, elem)) {
            return false;
          }
          if (isContainer && !ctx.getNewState(elem)) {
            return false;
          }
        };
      }
    }
  }
  return result;
}
