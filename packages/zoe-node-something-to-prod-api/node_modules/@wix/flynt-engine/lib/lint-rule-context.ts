import {
  Message,
  Oneof,
  ProtoFile,
  ProtoFolderType,
  skip,
  SourceCodeInfo,
  SyntaxTree,
  SyntaxTreeContainers,
  TypeName,
  Visitor,
  visitSyntaxTree,
  visitSyntaxTreeFrom
} from '@wix/proto-syntax-tree';
import {LintReport, LintRuleContext} from './rule-api';
import {isRuleDisabled} from './comment-parser';
import {LintRule, StaticLintRule} from '../index';

export interface LintRuleContextConfig {
  cwd: string;
  protoDir: string;
}

export interface ReportLocation {
  readonly resultId?: string;
  readonly filePath?: string;
  readonly line?: number;
  readonly column?: number;
}

export interface RuleReport extends ReportLocation {
  readonly message: string;
}

export interface DisabledReport extends Required<ReportLocation> {
  readonly disabledBy: DisableLocation;
}

export interface DisableLocation {
  readonly id: string;
  readonly line: number;
}

export type RunResults = {
  lintResults: RuleReport[];
  disabledReports: DisabledReport[];
};

export abstract class LintRuleContextImpl<T extends LintRule> implements LintRuleContext {
  constructor(ruleName: string, rule: T, config: LintRuleContextConfig, st: SyntaxTree) {
    this._errMessage = rule.description;
    this._ruleName = ruleName;
    this._config = config;
    this.st = st;
    this.results = [];
    this.disabledReports = [];
    this.rule = rule;
  }

  private readonly _ruleName: string;
  private readonly _errMessage: string;
  private readonly _config: LintRuleContextConfig;
  protected readonly rule: T;
  readonly results: RuleReport[];
  readonly disabledReports: DisabledReport[];
  readonly st: SyntaxTree;

  get moduleDir() {
    return this._config.cwd;
  }

  get protoDir() {
    return this._config.protoDir;
  }

  async run(): Promise<RunResults> {
    await this.runRule();
    return {
      lintResults: this.results,
      disabledReports: this.disabledReports,
    };
  }

  abstract runRule(): void | Promise<void>;

  report({errorAt, message}: LintReport = {}): void {
    let srcCodeInfo: SourceCodeInfo | undefined;
    if (errorAt) {
      if ('sourceCode' in errorAt) {
        srcCodeInfo = errorAt.sourceCode;
      } else {
        srcCodeInfo = errorAt;
      }
    }

    message = message || this._errMessage;
    if (srcCodeInfo) {
      const location = {
        resultId: srcCodeInfo.fqn,
        filePath: srcCodeInfo.container.file.path,
        line: srcCodeInfo.startLine,
        column: srcCodeInfo.startColumn,
      };

      const disableLocation = this.checkIfCurrentRuleDisabled(srcCodeInfo);
      if (disableLocation) {
        const disabledBy = {
          id: disableLocation.fqn,
          line: disableLocation.startLine,
        };
        this.disabledReports.push({...location, disabledBy});
      } else {
        this.results.push({...location, message});
      }
    } else {
      this.results.push({message});
    }
  }

  visitFrom(node: SyntaxTreeContainers, visitor: Visitor) {
    if (node.file.protoFolder === ProtoFolderType.MainProtoFolder) {
      visitSyntaxTreeFrom(node, this.skipNonLintedElements(visitor));
    }
  }

  visit(visitor: Visitor): void {
    visitSyntaxTree(this.st, this.skipNonLintedElements(visitor));
  }

  protected skipNonLintedElements(visitor: Visitor) {
    //This is a specialized visitor that skips elements from include files and generated types
    return skip(visitor, {
      visitFile(file: ProtoFile) {
        return file.protoFolder === ProtoFolderType.MainProtoFolder;
      },

      visitMessage(message: Message) {
        return !message.isMapEntry;
      },

      visitOneof(oneof: Oneof) {
        if (oneof.fields.length === 1 && oneof.fields[0].proto3Optional) {
          return false;
        }
      }
    });
  }

  assert<T>(value: T, rep: LintReport = {}): value is NonNullable<T> {
    if (!value) {
      this.report(rep);
    }
    return !!value;
  }

  reportIf<T>(value: T, rep: LintReport = {}): value is NonNullable<T> {
    if (value) {
      this.report(rep);
    }
    return !!value;
  }

  private checkIfCurrentRuleDisabled(sourceCodeInfo: SourceCodeInfo) {
    if (!this.rule.strict) {
      if (isRuleDisabled(sourceCodeInfo, this._ruleName)) {
        return sourceCodeInfo;
      } else if (isRuleDisabled(sourceCodeInfo.container.file.detailedSourceCode.syntax, this._ruleName)) {
        return sourceCodeInfo.container.file.detailedSourceCode.syntax;
      }
    }
  }

  assertTypeExists(fqn: string, typeName: TypeName, rep: LintReport = {}): void {
    let message = (rep.message || '') + ` - Invalid fqn: ${fqn}`;
    this.assert(fqn, {...rep, message});

    if (fqn) {
      if (typeName !== TypeName.File && !fqn.startsWith('.')) {
        fqn = '.' + fqn;
      }

      message = (rep.message || '') + ` - Type not found: ${fqn}`;
      const type = this.st.findType(fqn);
      this.assert(type, {...rep, message});
      if (type) {
        message = (rep.message || '') + ` - Expected ${fqn} to be a ${typeName} but it is a ${type.typeName}`;
        this.assert(type.typeName === typeName, {...rep, message});
      }
    }
  }
}

export class StaticLintRuleContextImpl extends LintRuleContextImpl<StaticLintRule> {
  async runRule() {
    await this.rule.run(this);
  }
}
