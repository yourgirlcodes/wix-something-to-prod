import {generateSyntaxTreeFromSource} from '@wix/proto-syntax-tree';
import {RuleReport, StaticLintRuleContextImpl} from './lint-rule-context';
import {LintRule, RuleDefinition} from '../index';
import path from 'path';
import fs from 'fs';
import {StatefulLintRuleContextImpl} from './stateful/stateful-lint-rule-context';

export interface TestDefinition {
  name: string;
  path: string;
  expectedResult: TestResult;
  skip?: boolean;
}

export enum TestResult {Pass = 'pass', Fail = 'fail'}

export class RuleTestRunner {
  private readonly ruleDef: RuleDefinition;
  private readonly test: TestDefinition;

  constructor(ruleDef: RuleDefinition, test: TestDefinition) {
    this.ruleDef = ruleDef;
    this.test = test;
  }

  get expectedResultsFile() {
    return path.join(this.test.path, 'expectedResults.json');
  }

  static stateFolders(test: TestDefinition) {
    return {
      current: path.join(test.path, 'current'),
      previous: path.join(test.path, 'previous'),
    };
  }

  async run(): Promise<RunResult> {
    let rule: LintRule;
    try {
      rule = await this.ruleDef.getRule();
    } catch (err) {
      throw new Error(`rule "${this.ruleDef.name} failed to load: ${err}`);
    }

    Object.freeze(rule);

    let ctx;
    let protoDir: string;

    if (rule.stateful) {
      const stateFolders = RuleTestRunner.stateFolders(this.test);
      protoDir = stateFolders.current;
      const st = await generateSyntaxTreeFromSource(protoDir);
      const prevSt = await generateSyntaxTreeFromSource(stateFolders.previous);
      ctx = new StatefulLintRuleContextImpl(this.ruleDef.name, rule,{cwd: protoDir, protoDir}, st, prevSt);
    } else {
      protoDir = this.test.path;
      const st = await generateSyntaxTreeFromSource(protoDir);
      ctx = new StaticLintRuleContextImpl(this.ruleDef.name, rule,{cwd: protoDir, protoDir}, st);
    }
    const ruleResults = await ctx.run();

    const results = ruleResults.lintResults.map(res => ({...res, filePath: toShortPath(protoDir, res.filePath)}));

    let expectedResults: RuleReport[] = [];
    if (this.test.expectedResult === TestResult.Fail) {
      if (fs.existsSync(this.expectedResultsFile)) {
        expectedResults = JSON.parse(fs.readFileSync(this.expectedResultsFile, 'utf-8'));
      } else {
        if (results.length > 0) {
          fs.writeFileSync(this.expectedResultsFile, JSON.stringify(results, null, 2) + '\n', {});
          expectedResults = results;
        }
      }
    }
    return {
      ruleResults: results,
      expectedResults,
    };
  }
}

export interface RunResult {
  ruleResults: RuleReport[];
  expectedResults: RuleReport[];
}

function toShortPath(cwd: string, filePath: string | undefined) {
  if (filePath) {
    const relPath = path.relative(cwd, filePath);
    if (!relPath.startsWith('..')) {
      return relPath;
    }
    return filePath;
  }
}
