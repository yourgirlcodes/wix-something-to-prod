import {BaseCatalogImpl} from './catalog';
import glob from 'glob';
import {RuleDefinitionImpl} from './rule-definition';
import assert from 'assert';
import path from 'path';
import fs from 'fs';
import {isWebUri} from 'valid-url';

export class FsCatalog extends BaseCatalogImpl {
  private readonly ruleNames = new Set<string>();
  private readonly catalogDocUrl?: string;

  constructor(catalogDir: string) {
    super(catalogDir);
    this.catalogDocUrl = this.getCatalogDocUrl();
    this.loadRuleDefinitions();
  }

  loadRuleDefinitions() {
    const ruleDirs = this.getRuleDirs();
    for (const ruleDir of ruleDirs) {
      this.addRuleDef(ruleDir);
    }
  }

  private getRuleDirs() {
    return glob.sync('./*/*/', {cwd: this.catalogDir, absolute: true});
  }

  addRuleDef(ruleDir: string) {
    const ruleDef = new RuleDefinitionImpl(ruleDir);
    assert(!this.ruleNames.has(ruleDef.name), `A rule with the name ${ruleDef.name} already exists`);
    this.ruleNames.add(ruleDef.name);
    this.ruleDefinitions.push(ruleDef);
  }

  getDocUrl(ruleDocPath: string) {
    assert(ruleDocPath, 'ruleDocPath must be a non empty string');
    if (isWebUri(ruleDocPath)) {
      return ruleDocPath;
    }
    const docsUrl = this.catalogDocUrl;
    if (docsUrl) {
      const relPath = path.relative(this.catalogDir, ruleDocPath);
      return docsUrl + relPath;
    }
    return ruleDocPath;
  }

  private getCatalogDocUrl() {
    const pkjJson = path.join(this.catalogDir, 'catalog.json');
    if (fs.existsSync(pkjJson)) {
      const doc = JSON.parse(fs.readFileSync(pkjJson, 'utf-8')).docs as string;
      if (doc.endsWith('/')) {
        return doc;
      } else {
        return doc + '/';
      }
    }
  }
}
