import {RuleDefinition, Severity, StaticLintRule} from '../index';
import glob from 'glob';
import path from 'path';
import {RuleTestRunner, TestDefinition, TestResult} from './rule-test-runner';
import fs from 'fs';

export class RuleValidator {
  constructor(private readonly rule: RuleDefinition) {
  }

  hasAllTestTypes(): boolean {
    let fail = false;
    let pass = false;

    for (const test of this.getTests()) {
      if (test.expectedResult === TestResult.Pass) {
        pass = true;
      } else {
        fail = true;
      }
      if (pass && fail) {
        break;
      }
    }

    return pass && fail;
  }

  getTests(): TestDefinition[] {
    const allTests = this.findTests(TestResult.Pass);
    allTests.push(...this.findTests(TestResult.Fail));
    return allTests;
  }

  private findTests(testResult: TestResult) {
    const dirs = glob.sync(`./${testResult}?(_*|-*)/`, {cwd: this.rule.path, absolute: true});
    return dirs.map(dir => {
      const name = path.basename(dir);
      const skip = name.endsWith('.skip') || undefined;
      return {name, path: dir, expectedResult: testResult, skip};
    });
  }

  private async tryLoadRule() {
    try {
      return await this.rule.getRule();
    } catch {
      //
    }
  }

  async validateLoadRule() {
    try {
      await this.rule.getRule();
    } catch (err: any) {
      throw new Error(`Rule could not be loaded. Details: ${err.stack || err}`);
    }
  }

  async validateRuleDefinition() {
    const rule = await this.rule.getRule();
    if (rule.graceUntil) {
      this.validateGrace(rule.graceUntil);
    }
    if (!rule.stateful) {
      this.validateBreakIfNew(rule);
    }
  }

  async validateDocPath() {
    const docPath = await this.rule.getDocPath();
    if (!docPath) {
      throw new Error('Rule documentation: A rule should provide a README.md doc or a moreInfoUrl.\nMore details: https://github.com/wix-private/flynt#rule-documentation');
    }
  }

  async validateFolderStructure() {
    if (!this.hasAllTestTypes()) {
      throw new Error('Rule tests: A rule should provide at least one "pass" and one "fail" tests.\nMore details: https://github.com/wix-private/flynt#create-a-sample-passing-and-failing-proto');
    }
    const rule = await this.tryLoadRule();
    if (rule && rule.stateful) {
      for (const test of this.getTests()) {
        const {current, previous} = RuleTestRunner.stateFolders(test);
        if (!fs.existsSync(current)) {
          throw new Error(`Rule state folders: test "${test.name}" should contain a "current" proto folder\nMore details:  https://github.com/wix-private/flynt#create-a-sample-passing-and-failing-proto`);
        }
        if (!fs.existsSync(previous)) {
          throw new Error(`Rule state folders: test "${test.name}" should contain a "previous" proto folder\nMore details:  https://github.com/wix-private/flynt#create-a-sample-passing-and-failing-proto`);
        }
      }
    }
  }

  async validateTest(test: TestDefinition): Promise<void> {
    const tester = new RuleTestRunner(this.rule, test);
    const results = await tester.run();

    if (test.expectedResult === TestResult.Pass) {
      if (results.ruleResults.length > 0) {
        throw new Error(`Test should have passed but it failed with the following errors: ${JSON.stringify(results.ruleResults, null, 1)}`);
      }
    } else {
      if (results.ruleResults.length === 0) {
        throw new Error('Test should have failed but it passed');
      }
    }

    //Validate that results equal expectedResults
    //Allow expectedResults to contain only a subset of the results
    //Allow expectedResults.message to contain a regexp
    expect(results.ruleResults).toEqual(results.expectedResults.map(res => {
      if (res.message && res.message.startsWith('/') && res.message.endsWith('/')) {
        return expect.objectContaining({
          ...res,
          message: expect.stringMatching(res.message.slice(1, -1)),
        });
      } else {
        return expect.objectContaining(res);
      }
    }));
  }

  private validateGrace(graceUntil: Date) {
    if (graceUntil.getUTCHours() + graceUntil.getUTCMinutes() + graceUntil.getUTCSeconds() > 0) {
      throw new Error('Grace period time must be 00:00:00 UTC. Make sure you are using the following date format "YYYY-MM-DD"');
    }
  }

  private validateBreakIfNew(rule: StaticLintRule) {
    if (rule.breakIfNew) {
      if (rule.severity === Severity.Error) {
        throw new Error('Rule defined with breakIfNew should use "Warning" severity');
      }
      if (rule.graceUntil) {
        throw new Error('Rule defined with breakIfNew should not define a grace period');
      }
    }
  }
}
