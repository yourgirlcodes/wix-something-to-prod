import {CatalogImpl} from './catalog';
import assert from 'assert';
import fs from 'fs';
import path from 'path';
import glob from 'glob';
import {RuleValidator} from './rule-validator';
import {RuleDefinition} from '../index';

export interface ValidationFilter {
  (ruleDef: RuleDefinition): boolean;
}

const validateAll: ValidationFilter = () => true;

export function validate(catalog: CatalogImpl, validationFilter: ValidationFilter = validateAll): void {
  describe('catalog validation', () => {
    it('validation should not throw any errors', () => {
      expect(() => new CatalogValidator(catalog).validate()).not.toThrow();
    });
  });

  describe('rules', () => {
    for (const ruleDef of catalog.ruleDefinitions) {
      if (validationFilter(ruleDef)) {
        const ruleValidator = new RuleValidator(ruleDef);

        describe(`rule "${ruleDef.name}"`, () => {
          describe('definition', () => {
            it('is loaded correctly', async () => {
              //If this fails it means we could not load and run your rule. See the error for more details
              await ruleValidator.validateLoadRule();
            });

            it('is defined correctly', async () => {
              //If this fails it the rule is not properly defined. See the error message for more details
              await ruleValidator.validateRuleDefinition();
            });

            it('should provide a README.md doc or a moreInfoUrl', async () => {
              await ruleValidator.validateDocPath();
            });

            it('validate rule folder structure', async () => {
              await ruleValidator.validateFolderStructure();
            });
          });

          describe('execution', () => {
            for (const test of ruleValidator.getTests()) {
              const run = test.skip ? it.skip : it;

              run(`test "${test.name}" should ${test.expectedResult}`, async () => {
                //If your test fails here then the "expectedResults.json" you provided is different from the results the linter returned
                await ruleValidator.validateTest(test);
              });
            }
          });
        });
      }
    }
  });
}

export class CatalogValidator {
  constructor(private readonly catalog: CatalogImpl) {
  }

  validate() {
    assert(fs.existsSync(this.catalog.catalogDir), `The rules catalog dir ${path.resolve(this.catalog.catalogDir)} does not exist`);
    assert(this.catalog.ruleDefinitions.length > 0, `The rules catalog in ${this.catalog.catalogDir} is empty`);
    assert(this.validateNoTopLevelRules(), 'rules should be located under categories');
  }

  validateNoTopLevelRules() {
    const topLevel = glob.sync('./*/*.*', {cwd: this.catalog.catalogDir});
    return (topLevel.length === 0);
  }
}
