import path from 'path';
import assert from 'assert';
import {LintRule, RuleDefinition} from '../index';
import fs from 'fs';

export class RuleDefinitionImpl implements RuleDefinition {
  private _rule: Promise<LintRule> | undefined;
  readonly name: string;
  readonly path: string;

  constructor(ruleDir: string, ruleModule?: any) {
    assert(ruleDir, 'ruleDir is required');
    this.path = ruleDir;
    this.name = path.basename(ruleDir);
    if (ruleModule) {
      this._rule = Promise.resolve(ruleModule).then(module => module.rule);
    }
  }

  private resolveRuleModule(ruleDir: string) {
    try {
      const resolved = require.resolve(path.resolve(ruleDir));
      return resolved;
    } catch (err: any) {
      throw new Error(`Invalid rule located under ${ruleDir}.
      Make sure the rule has an index.js file (or index.ts during development)
      error: ${err.toString()}`);
    }
  }

  private async loadRule(): Promise<LintRule> {
    const resolved = this.resolveRuleModule(this.path);
    let ruleModule: any;
    try {
      ruleModule = await import (resolved);
    } catch (err) {
      console.error(err);
      throw err;
    }
    const rule = ruleModule.rule;
    assert(rule, `no rule is exported from ${resolved}`);
    this.validateRule(rule);
    return rule;
  }

  validateRule(rule: LintRule) {
    assert(rule.description && typeof rule.description === 'string', 'rule description is required');
    assert(rule.run && typeof rule.run === 'function', 'rule must implement a run function');
  }

  async getRule(): Promise<LintRule> {
    if (!this._rule) {
      this._rule = this.loadRule();
    }
    return await this._rule;
  }

  async getDocPath() {
    const readMePath = path.join(this.path, 'README.md');
    if (fs.existsSync(readMePath)) {
      return readMePath;
    }
    const rule = await this.getRule();
    return rule.moreInfoUrl!;
  }
}
