import {RuleDefinitionImpl} from '../lib/rule-definition';
import {LintRule, LintRuleContext, RuleDefinition, Severity, StatefulLintRuleContext} from '../index';
import {RuleTestRunner, RunResult, TestDefinition, TestResult} from '../lib/rule-test-runner';
import fs from 'fs';
import path from 'path';
import {RuleReport} from '../lib/lint-rule-context';

describe('rule tester', () => {
  describe('rule context', () => {
    describe('static rules', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Pass,
        path: './test/rules/no-digits/pass',
      };

      it('calls run with correct context', async () => {
        const run = jest.fn();
        const ruleDef = createRuleDefinition(false, run);

        const runner = new RuleTestRunner(ruleDef, testDef);
        await runner.run();
        expect(run).toHaveBeenCalledWith(
          expect.objectContaining<Partial<LintRuleContext>>({
            st: expect.anything(),
            moduleDir: testDef.path,
          })
        );
      });
    });

    describe('stateful rules', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Pass,
        path: './test/rules/stateful/stateful-rule/pass',
      };

      it('calls run with both syntax tree states', async () => {
        const run = jest.fn();
        const ruleDef = createRuleDefinition(true, run);

        const runner = new RuleTestRunner(ruleDef, testDef);
        await runner.run();
        expect(run).toHaveBeenCalledWith(
          expect.objectContaining<Partial<StatefulLintRuleContext>>({
            st: expect.anything(),
            prevSt: expect.anything(),
            moduleDir: path.join(testDef.path, 'current'),
          })
        );
      });
    });
  });

  describe('rule state', () => {
    const testDef: TestDefinition = {
      name: 'some-name',
      expectedResult: TestResult.Pass,
      path: './test/rules/no-digits/pass',
    };

    it('severity can not be changed during run', async () => {
      const rule: LintRule = {
        severity: Severity.Warning,
        description: 'some-description',
        run() {
          this.severity = Severity.Error;
        }
      };
      const ruleDef = createRuleDefinition(false, rule);

      const runner = new RuleTestRunner(ruleDef, testDef);
      await expect(runner.run()).rejects.toThrow(/read only/);
    });

    it('rule is not allowed to change state after it is loaded', async () => {
      const rule = {
        state: 50,
        description: 'some-description',
        run() {
          this.state += 1;
        }
      };
      const ruleDef = createRuleDefinition(false, rule);

      const runner = new RuleTestRunner(ruleDef, testDef);
      await expect(runner.run()).rejects.toThrow(/read only/);
    });
  });

  describe('static rules', () => {
    const ruleDef = new RuleDefinitionImpl('./test/rules/no-digits');

    describe('pass', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Pass,
        path: './test/rule-tests/no-digits-pass',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      afterAll(() => {
        if (fs.existsSync(runner.expectedResultsFile)) {
          fs.rmSync(runner.expectedResultsFile);
        }
      });

      it('returns empty results', async () => {
        expect(runResult.ruleResults).toEqual([]);
        expect(runResult.expectedResults).toEqual([]);
      });

      it('does not generate expectedResults file', async () => {
        expect(fs.existsSync(runner.expectedResultsFile)).toBe(false);
      });
    });

    describe('pass - but expected to fail', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Fail,
        path: './test/rule-tests/no-digits-pass',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      afterAll(() => {
        if (fs.existsSync(runner.expectedResultsFile)) {
          fs.rmSync(runner.expectedResultsFile);
        }
      });

      it('returns empty results', async () => {
        expect(runResult.ruleResults).toEqual([]);
        expect(runResult.expectedResults).toEqual([]);
      });

      it('does not generate expectedResults file', async () => {
        expect(fs.existsSync(runner.expectedResultsFile)).toBe(false);
      });
    });

    describe('fail - without results file', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Fail,
        path: './test/rule-tests/no-digits-fail-no-results',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      afterAll(() => {
        if (fs.existsSync(runner.expectedResultsFile)) {
          fs.rmSync(runner.expectedResultsFile);
        }
      });

      it('returns expected results', async () => {
        expect(runResult.ruleResults).toEqual<RuleReport[]>([
          {
            line: 6,
            column: 10,
            filePath: 'fail.proto',
            message: 'digits not allowed in field names',
            resultId: '.com.wix.Message.str_field_1.(name)',
          },
        ]);

        expect(runResult.expectedResults).toEqual<RuleReport[]>([
          {
            line: 6,
            column: 10,
            filePath: 'fail.proto',
            message: 'digits not allowed in field names',
            resultId: '.com.wix.Message.str_field_1.(name)',
          }
        ]);
      });

      it('generates expectedResults file', async () => {
        expect(fs.existsSync(runner.expectedResultsFile)).toBe(true);
        const expectedJson = JSON.parse(fs.readFileSync(runner.expectedResultsFile, 'utf-8'));
        expect(expectedJson).toEqual<RuleReport[]>([
          {
            line: 6,
            column: 10,
            filePath: 'fail.proto',
            message: 'digits not allowed in field names',
            resultId: '.com.wix.Message.str_field_1.(name)',
          }
        ]);
      });

    });

    describe('fail - with existing results file', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Fail,
        path: './test/rule-tests/no-digits-fail-with-results',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      it('returns expected results', async () => {
        expect(runResult.ruleResults).toEqual<RuleReport[]>([
          {
            line: 6,
            column: 10,
            filePath: 'fail.proto',
            message: 'digits not allowed in field names',
            resultId: '.com.wix.Message.str_field_1.(name)',
          },
        ]);

        expect(runResult.expectedResults).toEqual<RuleReport[]>([
          {
            line: 1,
            column: 1,
            filePath: 'x.proto',
            message: 'xyz',
          },
        ]);
      });

      it('does not override expectedResults file', async () => {
        expect(fs.existsSync(runner.expectedResultsFile)).toBe(true);
        const expectedJson = JSON.parse(fs.readFileSync(runner.expectedResultsFile, 'utf-8'));
        expect(expectedJson).toEqual([
          {
            line: 1,
            column: 1,
            filePath: 'x.proto',
            message: 'xyz'
          },
        ]);
      });
    });
  });

  describe('stateful rules', () => {
    const ruleDef = new RuleDefinitionImpl('./test/rules/stateful/stateful-rule');

    describe('pass', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Pass,
        path: './test/rules/stateful/stateful-rule/pass',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      it('returns empty results', async () => {
        expect(runResult.ruleResults).toEqual([]);
        expect(runResult.expectedResults).toEqual([]);
      });
    });

    describe('fail', () => {
      const testDef: TestDefinition = {
        name: 'some-name',
        expectedResult: TestResult.Pass,
        path: './test/rules/stateful/stateful-rule/fail',
      };
      const runner = new RuleTestRunner(ruleDef, testDef);

      let runResult: RunResult;

      beforeAll(async () => {
        runResult = await runner.run();
      });

      it('returns expected results', async () => {
        expect(runResult.ruleResults).toEqual<RuleReport[]>([
          {
            line: 7,
            column: 3,
            filePath: 'message.proto',
            message: 'field leading comment should never decrease in length',
            resultId: '.com.wix.Message.str_field',
          },
        ]);
      });
    });

  });
});

function createRuleDefinition(stateful: boolean, rule: LintRule): RuleDefinition;
function createRuleDefinition(stateful: boolean, run: () => void): RuleDefinition;
function createRuleDefinition(stateful: boolean, runOrRule: (() => void) | LintRule) {
  const rule: LintRule = typeof runOrRule === 'function' ? {
    description: 'some-description',
    stateful,
    run: runOrRule
  } : runOrRule;

  return {
    name: 'some-name', path: 'some-path',
    async getRule() {
      return rule;
    },

    async getDocPath() {
      return '';
    }
  };
}
