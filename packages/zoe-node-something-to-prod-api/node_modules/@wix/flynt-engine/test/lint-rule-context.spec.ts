import {Field, generateSyntaxTreeFromSource, Message, ProtoFile, ProtoFolderType, Service, SyntaxTree, TypeName} from '@wix/proto-syntax-tree';
import {StaticLintRuleContextImpl} from '../lib/lint-rule-context';
import {StaticLintRule} from '../index';

describe('LintRuleContext', () => {
  const defConfig = {cwd: '/cwd', protoDir: '/proto'};
  let st: SyntaxTree;
  let ctx: StaticLintRuleContextImpl;

  beforeAll(async () => {
    st = await generateSyntaxTreeFromSource('./test/modules/simple');
  });

  beforeEach(() => {
    ctx = new StaticLintRuleContextImpl('some-rule-id', fakeRule('default error message'), defConfig, st);
  });

  it('basics', async () => {
    expect(ctx.st).toEqual(st);
    expect(ctx.moduleDir).toEqual(defConfig.cwd);
    expect(ctx.protoDir).toEqual(defConfig.protoDir);
    expect(ctx.results).toEqual([]);
  });

  describe('report', () => {
    it('reports without source info if type not provided', () => {
      ctx.report();
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].message).toEqual('default error message');

      expect(ctx.results[0].filePath).toBeUndefined();
      expect(ctx.results[0].resultId).toBeUndefined();
      expect(ctx.results[0].column).toBeUndefined();
      expect(ctx.results[0].line).toBeUndefined();
    });

    it('reports custom message', () => {
      ctx.report({message: 'custom message'});
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].message).toEqual('custom message');
    });

    it('reports a proto type', () => {
      const svc = st.getService('.com.wix.SomeService');
      ctx.report({errorAt: svc});

      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(svc.file.path);
      expect(ctx.results[0].resultId).toEqual(svc.fqn);
      expect(ctx.results[0].line).toEqual(svc.sourceCode.startLine);
      expect(ctx.results[0].column).toEqual(svc.sourceCode.startColumn);
      expect(ctx.results[0].message).toEqual('default error message');
    });

    it('reports both type and message', () => {
      const svc = st.getService('.com.wix.SomeService');
      ctx.report({errorAt: svc, message: 'custom error message'});

      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(svc.file.path);
      expect(ctx.results[0].resultId).toEqual(svc.fqn);
      expect(ctx.results[0].line).toEqual(svc.sourceCode.startLine);
      expect(ctx.results[0].column).toEqual(svc.sourceCode.startColumn);
      expect(ctx.results[0].message).toEqual('custom error message');
    });

    it('can also report on options', () => {
      const method = st.getMethod('.com.wix.SomeService.Method');
      const required = method.options.getOptions('.wix.api.required');
      const opt = required[1];
      ctx.report({errorAt: opt, message: 'value should point to a valid field'});
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(opt.file.path);
      expect(ctx.results[0].resultId).toEqual(opt.fqn);
      expect(ctx.results[0].message).toMatch(/valid field/);
    });

    it('can also report on source code details', () => {
      const file = st.files[1];

      ctx.report({errorAt: file.detailedSourceCode.syntax});
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(file.path);
      expect(ctx.results[0].resultId).toEqual(file.fqn + '.(syntax)');
      expect(ctx.results[0].line).toEqual(file.detailedSourceCode.syntax.startLine);
      expect(ctx.results[0].column).toEqual(file.detailedSourceCode.syntax.startColumn);
      expect(ctx.results[0].message).toEqual('default error message');
    });

    describe('disabled rules', () => {
      describe('when disabled on a specific element', () => {
        let ctx: StaticLintRuleContextImpl;

        beforeEach(() => {
          ctx = new StaticLintRuleContextImpl('disabled-rule-2', fakeRule('error'), defConfig, st);
        });

        it('suppress report when reporting on element', async () => {
          const elem = st.getMessage('.com.wix.MethodResponse');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(0);
          expect(ctx.disabledReports).toHaveLength(1);
          expect(ctx.disabledReports[0].filePath).toEqual(elem.file.path);
          expect(ctx.disabledReports[0].resultId).toEqual(elem.fqn);
          expect(ctx.disabledReports[0].line).toEqual(elem.sourceCode.startLine);
          expect(ctx.disabledReports[0].column).toEqual(elem.sourceCode.startColumn);
          expect(ctx.disabledReports[0].disabledBy).toEqual({
            id: elem.fqn,
            line: elem.sourceCode.startLine,
          });
        });

        it('does not suppress report if the rule is marked "strict"', async () => {
          ctx = new StaticLintRuleContextImpl('disabled-rule-2', fakeRule('error', {strict: true}), defConfig, st);
          const elem = st.getMessage('.com.wix.MethodResponse');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(1);
        });

        it('does not suppress report when reporting on a different element', async () => {
          const elem = st.getField('.com.wix.MethodResponse.field');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(1);
        });

        it('does not suppress report if reporting without element', async () => {
          ctx.report();
          expect(ctx.results).toHaveLength(1);
        });

        it('does not suppress report when reporting with a different rule', async () => {
          ctx = new StaticLintRuleContextImpl('rule-1', fakeRule('error'), defConfig, st);
          const elem = st.getMessage('.com.wix.MethodResponse');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(1);
        });
      });

      describe('when disabled on file level', () => {
        let ctx: StaticLintRuleContextImpl;

        beforeEach(() => {
          ctx = new StaticLintRuleContextImpl('disabled-rule-1', fakeRule('error'), defConfig, st);
        });

        it('suppress report if rule is reported on element from that file', async () => {
          const elem = st.getService('.com.wix.SomeService');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(0);
          expect(ctx.disabledReports).toHaveLength(1);
          expect(ctx.disabledReports[0].filePath).toEqual(elem.file.path);
          expect(ctx.disabledReports[0].resultId).toEqual(elem.fqn);
          expect(ctx.disabledReports[0].line).toEqual(elem.sourceCode.startLine);
          expect(ctx.disabledReports[0].column).toEqual(elem.sourceCode.startColumn);
          expect(ctx.disabledReports[0].disabledBy).toEqual({
            id: elem.file.detailedSourceCode.syntax.fqn,
            line: elem.file.detailedSourceCode.syntax.startLine,
          });
        });

        it('does not suppress report if reporting on element from a different file', async () => {
          const elem = st.getMessage('.com.wix.MethodResponse');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(1);
        });

        it('does not suppress report if reporting without element', async () => {
          ctx.report();
          expect(ctx.results).toHaveLength(1);
        });

        it('does not suppress report if reporting with a different rule', async () => {
          ctx = new StaticLintRuleContextImpl('rule-1', fakeRule('error'), defConfig, st);
          const elem = st.getService('.com.wix.SomeService');
          ctx.report({errorAt: elem});
          expect(ctx.results).toHaveLength(1);
        });
      });
    });
  });

  describe('assert', () => {
    it('does not report when value is truthy', () => {
      ctx.assert(st.getType('.com.wix.SomeService').sourceCode);
      expect(ctx.results).toHaveLength(0);
    });

    it('reports default when value is falsy and no type is passed', () => {
      ctx.assert(st.findType('not-existing'));
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].message).toEqual('default error message');
      expect(ctx.results[0].filePath).toBeUndefined();
    });

    it('reports the passed info when value is falsy', () => {
      const file = st.files[1];
      ctx.assert(file.package === 'xxx', {errorAt: file, message: 'package name should be "xxx"'});
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(file.path);
      expect(ctx.results[0].message).toMatch(/xxx/);
    });

    it('returns a boolean from assert', async () => {
      expect(ctx.assert(1)).toEqual(true);
      expect(ctx.assert(null)).toEqual(false);
    });
  });

  describe('assertTypeExists', () => {
    describe('fqn', () => {
      it('asserts a type exists', async () => {
        ctx.assertTypeExists('.com.wix.SomeEnum', TypeName.Enum);
        expect(ctx.results).toHaveLength(0);
      });

      it('asserts a type exists when an fqn is used without a dot prefix', async () => {
        ctx.assertTypeExists('com.wix.SomeEnum', TypeName.Enum);
        expect(ctx.results).toHaveLength(0);
      });

      it('adds a dot prefix to the fqn', async () => {
        ctx.assertTypeExists('xxx.yyy', TypeName.Enum);
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/\.xxx\.yyy/);
      });

      it('does not add a dot prefix to the fqn for files', async () => {
        ctx.assertTypeExists('xxx.yyy', TypeName.File);
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/\sxxx\.yyy/);
      });

      it('reports an error if fqn is undefined', async () => {
        ctx.assertTypeExists(undefined as any, TypeName.Message);
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/Invalid fqn/);
      });
    });

    describe('without a message', () => {
      it('reports an error if type exists but have a different typeName', async () => {
        ctx.assertTypeExists('com.wix.SomeEnum', TypeName.Message);
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/Expected.*SomeEnum.*Message.*Enum/);
      });

      it('reports an error if the fqn does not exists', async () => {
        ctx.assertTypeExists('com.wix.NoName', TypeName.Message);
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/Type not found.*NoName/);
      });
    });

    describe('with a message', () => {
      it('reports an error if type exists but have a different typeName', async () => {
        ctx.assertTypeExists('com.wix.SomeEnum', TypeName.Message, {message: 'My Message'});
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/My Message.*Expected.*SomeEnum.*Message.*Enum/);
      });

      it('reports an error if the fqn does not exists', async () => {
        ctx.assertTypeExists('com.wix.NoName', TypeName.Message, {message: 'My Message'});
        expect(ctx.results).toHaveLength(1);
        expect(ctx.results[0].message).toMatch(/My Message.*Type not found.*NoName/);
      });
    });
  });

  describe('reportIf', () => {
    it('does not report when value is false', () => {
      ctx.reportIf(!st.getType('.com.wix.SomeService').sourceCode);
      expect(ctx.results).toHaveLength(0);
    });

    it('reports default when value is true and no type is passed', () => {
      ctx.reportIf(!st.findType('not-existing'));
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].message).toEqual('default error message');
      expect(ctx.results[0].filePath).toBeUndefined();
    });

    it('reports the passed info when value is truthy', () => {
      const file = st.files[1];
      ctx.reportIf(file.package !== 'xxx', {errorAt: file, message: 'package name should be "xxx"'});
      expect(ctx.results).toHaveLength(1);
      expect(ctx.results[0].filePath).toEqual(file.path);
      expect(ctx.results[0].message).toMatch(/xxx/);
    });

    it('returns a boolean from reportIf', async () => {
      expect(ctx.reportIf(1)).toEqual(true);
      expect(ctx.reportIf(null)).toEqual(false);
    });
  });

  describe('visitor', () => {
    it('iterates using the passed visitor', async () => {
      const services: string[] = [];
      ctx.visit({
        visitService(service: Service) {
          services.push(service.name);
        }
      });

      expect(services).toEqual(['SomeOtherService', 'SomeService']);
    });

    describe('skips non linted elements', () => {
      it('skips include files', async () => {
        const messages: string[] = [];
        ctx.visit({
          visitMessage(message: Message) {
            messages.push(message.name);
          }
        });

        expect(messages).toEqual(['MethodRequest', 'MethodResponse', 'NestedMessage']);
      });

      describe('visitFrom', () => {
        it('skips include files', async () => {
          const allFiles = [];
          const mainProtoFiles: ProtoFile[] = [];
          for (const file of st.files) {
            allFiles.push(file);
            ctx.visitFrom(file, {
              visitFile(f: ProtoFile) {
                mainProtoFiles.push(f);
              }
            });
          }

          //This just confirms that we saw at least one Main proto folder file and one Include file
          expect(allFiles.find(f => f.protoFolder === ProtoFolderType.MainProtoFolder)).toBeDefined();
          expect(allFiles.find(f => f.protoFolder === ProtoFolderType.IncludeProtoFolder)).toBeDefined();

          //This confirms that during visit we only saw Main proto folder files
          expect(mainProtoFiles.find(f => f.protoFolder === ProtoFolderType.MainProtoFolder)).toBeDefined();
          expect(mainProtoFiles.find(f => f.protoFolder === ProtoFolderType.IncludeProtoFolder)).toBeUndefined();
        });

        it('skips elements from include files', async () => {
          const methodWithGoogleRequest = st.getMethod('.com.wix.SomeService.MethodWithGoogleRequest');
          const visited: string[] = [];
          ctx.visitFrom(methodWithGoogleRequest.request, {
            visitMessage(message) {
              visited.push(message.name);
            },

            visitField(field: Field) {
              visited.push(field.name);
            }
          });

          //visitMessage and visitField should not be called because message is from a non linted file
          expect(visited).toHaveLength(0);
        });
      });

      describe('generated types', () => {
        beforeAll(async () => {
          st = await generateSyntaxTreeFromSource('./test/modules/gen');
        });

        it('does not visit generated types', async () => {
          const messages: string[] = [];
          const fields: string[] = [];
          ctx.visit({
            visitMessage(message: Message) {
              messages.push(message.name);
            },

            visitField(field: Field) {
              fields.push(field.name);
            },

            visitOneof() {
              fail('generated optional oneOf should not be visited');
            }
          });

          expect(fields).toEqual(['field1', 'mapField', 'some_field']);
          expect(messages).toEqual(['SomeMessage']);
        });

        it('does not visit generated types with partial visitor', async () => {
          const mainFile = st.files[0];
          const messages: string[] = [];
          const fields: string[] = [];
          ctx.visitFrom(mainFile, {
            visitMessage(message: Message) {
              messages.push(message.name);
            },

            visitField(field: Field) {
              fields.push(field.name);
            },

            visitOneof() {
              fail('generated optional oneOf should not be visited');
            }
          });

          expect(fields).toEqual(['field1', 'mapField', 'some_field']);
          expect(messages).toEqual(['SomeMessage']);
        });

      });
    });
  });
});

function fakeRule(description: string, opts?: Partial<StaticLintRule>): StaticLintRule {
  return {
    ...opts,
    description,
    run() {
    }
  };
}
