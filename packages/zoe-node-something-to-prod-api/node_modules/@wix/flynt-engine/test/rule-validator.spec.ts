import path from 'path';
import {RuleValidator} from '../lib/rule-validator';
import {RuleDefinitionImpl} from '../lib/rule-definition';
import {TestResult} from '../lib/rule-test-runner';
import {RuleDefinition, Severity, StaticLintRule} from '../index';
import fs from 'fs';

describe('rule validator', () => {
  function testDir(ruleDir: string, relPath: string) {
    return path.resolve(path.join(ruleDir, relPath));
  }

  describe('get test list', () => {
    it('should return an empty test list for a definition without tests', async () => {
      const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/rule-with-no-tests'));
      const tests = ruleDef.getTests();
      expect(tests).toHaveLength(0);
    });

    it('should return the test list', async () => {
      const ruleDir = './test/rules/rule-with-all-tests';
      const ruleDef = new RuleValidator(new RuleDefinitionImpl(ruleDir));
      expect(ruleDef.hasAllTestTypes()).toBe(true);
      const tests = ruleDef.getTests();
      expect(tests).toHaveLength(4);
      expect(tests).toContainEqual({name: 'fail', path: testDir(ruleDir, 'fail'), expectedResult: TestResult.Fail});
      expect(tests).toContainEqual({name: 'fail_another', path: testDir(ruleDir, 'fail_another'), expectedResult: TestResult.Fail});
      expect(tests).toContainEqual({name: 'pass-ok', path: testDir(ruleDir, 'pass-ok'), expectedResult: TestResult.Pass});
      expect(tests).toContainEqual({name: 'pass-2.skip', path: testDir(ruleDir, 'pass-2.skip'), expectedResult: TestResult.Pass, skip: true});
    });

    it('should return the test list even when some test kinds do not exist', async () => {
      const ruleDir = './test/rules/rule-with-some-tests';
      const ruleDef = new RuleValidator(new RuleDefinitionImpl(ruleDir));
      const tests = ruleDef.getTests();
      expect(tests).toHaveLength(1);
      expect(tests).toContainEqual({name: 'fail', path: testDir(ruleDir, 'fail'), expectedResult: TestResult.Fail});
    });
  });

  describe('load rule', () => {
    it('fails if a rule can not be loaded', async () => {
      const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/rule-with-error'));
      await expect(ruleDef.validateLoadRule()).rejects.toThrow(/Rule could not be loaded/);
    });

    it('succeeds if a rule is loaded', async () => {
      const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
      await expect(ruleDef.validateLoadRule()).resolves.not.toThrow();
    });
  });

  describe('validate rule definition', () => {
    describe('validate grace', () => {
      it('fails if grace period does not use UTC date', async () => {
        const ruleDef = new RuleValidator(fakeRule({
          graceUntil: new Date('2022-05-01T00:00:00+03:00')
        }));
        await expect(ruleDef.validateRuleDefinition()).rejects.toThrow(/Grace period time.*UTC/);
      });

      it('succeeds if grace period defined correctly', async () => {
        const ruleDef = new RuleValidator(fakeRule({
          graceUntil: new Date('2022-05-01')
        }));
        await expect(ruleDef.validateRuleDefinition()).resolves.not.toThrow();
      });
    });

    describe('breakIfNew', () => {
      it('fails if grace period defined with breakIfNew', async () => {
        const ruleDef = new RuleValidator(fakeRule({
          graceUntil: new Date('2022-05-01'),
          breakIfNew: true,
        }));
        await expect(ruleDef.validateRuleDefinition()).rejects.toThrow(/breakIfNew.*grace period/i);
      });

      it('fails if severity error defined with breakIfNew', async () => {
        const ruleDef = new RuleValidator(fakeRule({
          severity: Severity.Error,
          breakIfNew: true,
        }));
        await expect(ruleDef.validateRuleDefinition()).rejects.toThrow(/breakIfNew.*severity/i);
      });

      it('succeeds if breakIfNew defined', async () => {
        const ruleDef = new RuleValidator(fakeRule({
          breakIfNew: true
        }));
        await expect(ruleDef.validateRuleDefinition()).resolves.not.toThrow();
      });
    });
  });

  describe('validateTest', () => {
    describe('basic functionality', () => {
      afterAll(async () => {
        if (fs.existsSync('./test/rules/no-digits/fail/expectedResults.json')) {
          fs.rmSync('./test/rules/no-digits/fail/expectedResults.json');
        }
      });

      it('fail test which fails correctly', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'fail', path: './test/rules/no-digits/fail', expectedResult: TestResult.Fail};
        await expect(ruleDef.validateTest(testDef)).resolves.not.toThrow();
      });

      it('pass test which passes correctly', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'pass', path: './test/rules/no-digits/pass', expectedResult: TestResult.Pass};
        await expect(ruleDef.validateTest(testDef)).resolves.not.toThrow();
      });

      it('fail test which passes', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'fail', path: './test/rules/no-digits/fail-test-which-passes', expectedResult: TestResult.Fail};
        await expect(ruleDef.validateTest(testDef)).rejects.toThrow(/should.*fail.*but.*pass/);
      });

      it('pass test which fails', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'pass', path: './test/rules/no-digits/pass-test-which-fails', expectedResult: TestResult.Pass};
        await expect(ruleDef.validateTest(testDef)).rejects.toThrow(/should.*pass.*but.*fail/);
      });
    });

    describe('expected results file', () => {
      it('test with correct expected results', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'fail', path: './test/rules/no-digits/fail-correct-results', expectedResult: TestResult.Fail};
        await expect(ruleDef.validateTest(testDef)).resolves.not.toThrow();
      });

      it('test with wrong line in expected results', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'fail', path: './test/rules/no-digits/fail-incorrect-results-line', expectedResult: TestResult.Fail};
        await expect(ruleDef.validateTest(testDef)).rejects.toThrow(/line/);
      });

      it('allows results file to contain a subset of the result', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
        const testDef = {name: 'fail', path: './test/rules/no-digits/fail-correct-results-subset', expectedResult: TestResult.Fail};
        await expect(ruleDef.validateTest(testDef)).resolves.not.toThrow();
      });

      describe('message regex', () => {
        it('allows results message to hold a regex', async () => {
          const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
          const testDef = {name: 'fail', path: './test/rules/no-digits/fail-correct-results-regex', expectedResult: TestResult.Fail};
          await expect(ruleDef.validateTest(testDef)).resolves.not.toThrow();
        });

        it('fails if message regex does not match result', async () => {
          const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/no-digits'));
          const testDef = {name: 'fail', path: './test/rules/no-digits/fail-incorrect-results-regex', expectedResult: TestResult.Fail};
          await expect(ruleDef.validateTest(testDef)).rejects.toThrow(/StringMatching/);
        });
      });
    });
  });

  describe('doc Path', () => {
    it('should succeed if rule has moreInfoUrl or README', async () => {
      const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/with-readme'));
      await expect(ruleDef.validateDocPath()).resolves.not.toThrow();

      const ruleDef2 = new RuleValidator(new RuleDefinitionImpl('./test/rules/with-more-info'));
      await expect(ruleDef2.validateDocPath()).resolves.not.toThrow();
    });

    it('should fail if rule does not have moreInfoUrl or README', async () => {
      const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/without-doc-path'));
      await expect(ruleDef.validateDocPath()).rejects.toThrow(/Rule documentation/);
    });
  });

  describe('validate structure', () => {
    describe('validate test folders', () => {
      it('should fail if a rule is defined without passing tests', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/without-passing-tests'));
        await expect(ruleDef.validateFolderStructure()).rejects.toThrow(/Rule tests/);
      });

      it('should fail if a rule is defined without failing tests', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/without-fail-tests'));
        await expect(ruleDef.validateFolderStructure()).rejects.toThrow(/Rule tests/);
      });

      it('should pass if a rule is defined with all test types', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/rule-with-all-tests'));
        await expect(ruleDef.validateFolderStructure()).resolves.not.toThrow();
      });
    });

    describe('validate state folders for stateful rules', () => {
      it('should fail if a rule is defined without current proto folder', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/stateful/fail-without-current'));
        await expect(ruleDef.validateFolderStructure()).rejects.toThrow(/Rule state folders.*fail-some-test.*current/);
      });

      it('should fail if a rule is defined without previous proto folder', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/stateful/pass-without-previous'));
        await expect(ruleDef.validateFolderStructure()).rejects.toThrow(/Rule state folders.*pass-it-forward.*previous/);
      });

      it('should pass if a rule is defined with both current and previous proto folders', async () => {
        const ruleDef = new RuleValidator(new RuleDefinitionImpl('./test/rules/stateful/stateful-rule'));
        await expect(ruleDef.validateFolderStructure()).resolves.not.toThrow();
      });
    });
  });
});


function fakeRule(rule: Omit<StaticLintRule, 'run' | 'description'> | Omit<StaticLintRule, 'run' | 'description'>): RuleDefinition {
  const ruleRun = {
    description: 'some-description',
    run() {
    }
  };

  return {
    name: 'some-name',
    path: 'foo/bar',
    async getDocPath(): Promise<string> {
      return 'doc/path';
    },

    async getRule() {
      return Object.assign(ruleRun, rule);
    }
  };
}
