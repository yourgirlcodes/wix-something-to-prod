import {ProtoLinter} from '../lib/proto-linter';
import {generateSyntaxTreeFromSource, SyntaxTree} from '@wix/proto-syntax-tree';
import {linter, LintResult, LintResults, PreLoadedCatalog, Severity} from '../index';
import path from 'path';
import {getCatalogInfo} from './catalogs/test-catalog/gen-index';

describe('proto linter', () => {
  describe('validations', () => {
    it('required fields', async () => {
      expect(() => new ProtoLinter({catalog: '', rules: {}})).toThrow(/catalog.*required/);
      expect(() => new ProtoLinter({catalog: 'x', rules: null as any})).toThrow(/rule.*required/);
      const linter = new ProtoLinter({catalog: 'x', rules: {}});
      await expect(linter.lint({st: null as any, moduleDir: 'x', protoDir: 'y'})).rejects.toThrow(/proto.st.*required/);
      await expect(linter.lint({st: {} as any, moduleDir: '', protoDir: 'y'})).rejects.toThrow(/proto.moduleDir.*required/);
      await expect(linter.lint({st: {} as any, moduleDir: 'x', protoDir: null as any})).rejects.toThrow(/proto.protoDir.*required/);
      const validProtoModule = {st: {} as any, moduleDir: 'x', protoDir: 'y'};
      await expect(linter.lint(validProtoModule, {st: null as any, moduleDir: 'x', protoDir: 'y'})).rejects.toThrow(/prevProto.st.*required/);
      await expect(linter.lint(validProtoModule, {st: {} as any, moduleDir: '', protoDir: 'y'})).rejects.toThrow(/prevProto.moduleDir.*required/);
      await expect(linter.lint(validProtoModule, {st: {} as any, moduleDir: 'x', protoDir: null as any})).rejects.toThrow(/prevProto.protoDir.*required/);
    });
  });

  describe('lint', () => {
    const moduleDir = './test/modules/test-module';
    const protoDir = './test/modules/test-module/proto';
    const msgsFullPath = path.resolve(protoDir, 'com/wix/messages.proto');
    const svcFullPath = path.resolve(protoDir, 'com/wix/service.proto');
    const catalogInfo = getCatalogInfo();

    const testData = [
      {catalog: './test/catalogs/test-catalog'},
      {catalog: new PreLoadedCatalog('./test/catalogs/test-catalog', catalogInfo)}
    ];

    describe.each(testData)('catalog type %s', (test) => {
      describe('stateless', () => {
        let st: SyntaxTree;
        let res: LintResults;

        beforeAll(async () => {
          st = await generateSyntaxTreeFromSource(protoDir);
          const l = linter({catalog: test.catalog, rules: {}});
          res = await l.lint({st, moduleDir, protoDir});
        });

        describe('report', () => {
          it('returns expected report', async () => {
            //test-module is a module with 2 files
            //catalog contains 6 rules:
            // "non-proto-rule" reports 1 issue not related to proto
            // "single-service" reports 3 issues and 1 issue is disabled via comment
            // "invalid-field-name" reports 4 issues
            // "error-rule" always fails
            // "error-stateful-rule" and "stateful-rule" should not run in this mode
            expect(res.results).toHaveLength(8);
            const nonProtoErrors = res.results.filter(res => res.ruleId === 'non-proto-rule');
            expect(nonProtoErrors).toHaveLength(1);
            expect(nonProtoErrors[0].filePath).toBeUndefined();
            expect(nonProtoErrors[0].ruleDoc).toEqual('https://github.com/wix-private/flynt/tree/master/packages/engine/test/catalogs/test-catalog/category-name/non-proto-rule/README.md');

            const singleServiceErrors = res.results.filter(res => res.ruleId === 'single-service');
            expect(singleServiceErrors).toHaveLength(3);
            expect(singleServiceErrors[0].ruleDoc).toEqual('http://www.single-service.com');
            expect(singleServiceErrors.filter(res => res.filePath === svcFullPath)).toHaveLength(1);
            expect(singleServiceErrors.filter(res => res.filePath === msgsFullPath)).toHaveLength(2);

            const invalidFieldError = res.results.filter(res => res.ruleId === 'invalid-field-name');
            expect(invalidFieldError).toHaveLength(4);
            expect(invalidFieldError[0].ruleDoc).toEqual('http://www.invalid-field-name.com');
            expect(invalidFieldError.filter(res => res.filePath === svcFullPath)).toHaveLength(2);
            expect(invalidFieldError.filter(res => res.filePath === msgsFullPath)).toHaveLength(2);

            expect(res.disabled).toHaveLength(1);
            const disabledSingleServiceErrors = res.disabled.filter(res => res.ruleId === 'single-service');
            expect(disabledSingleServiceErrors).toHaveLength(1);
            expect(disabledSingleServiceErrors[0].resultId).toEqual('.com.wix.SomeService6');
            expect(disabledSingleServiceErrors[0].disabledBy.id).toEqual('.com.wix.SomeService6');
            expect(disabledSingleServiceErrors[0].line).toEqual(disabledSingleServiceErrors[0].disabledBy.line);
          });

          it('returns a list of execution errors along with reports', async () => {
            expect(res.executionErrors).toHaveLength(1);
            expect(res.executionErrors[0]).toEqual({
              ruleId: 'error-rule',
              error: expect.stringMatching(/xxx/),
            });
          });

          it('returns reports sorted by file name the by ruleId', async () => {
            const fileNames = res.results.map(res => ({filePath: res.filePath, ruleId: res.ruleId}));
            expect(fileNames).toEqual([
              {ruleId: 'non-proto-rule'},
              {filePath: msgsFullPath, ruleId: 'invalid-field-name'},
              {filePath: msgsFullPath, ruleId: 'invalid-field-name'},
              {filePath: msgsFullPath, ruleId: 'single-service'},
              {filePath: msgsFullPath, ruleId: 'single-service'},
              {filePath: svcFullPath, ruleId: 'invalid-field-name'},
              {filePath: svcFullPath, ruleId: 'invalid-field-name'},
              {filePath: svcFullPath, ruleId: 'single-service'},
            ]);
          });
        });

        describe('severity', () => {
          it('reports default severity', async () => {
            expect(res.results.find(r => r.ruleId === 'single-service')).toMatchObject({
              severity: Severity.Warning
            });
          });

          it('report severity defined on rule', async () => {
            expect(res.results.find(r => r.ruleId === 'invalid-field-name')).toMatchObject({
              severity: Severity.Error
            });
          });

          it('report severity according to config rule severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {'single-service': Severity.Error}});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results.find(r => r.ruleId === 'single-service')).toMatchObject({
              severity: Severity.Error
            });
          });

          it('report severity according to config default severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {}, severity: Severity.Error});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results.find(r => r.ruleId === 'single-service')).toMatchObject({
              ruleId: 'single-service', severity: Severity.Error
            });
          });

          it('rule config severity has precedence over default severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {'single-service': Severity.Error}, severity: Severity.Warning});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results.find(r => r.ruleId === 'single-service')).toMatchObject({
              ruleId: 'single-service', severity: Severity.Error
            });
          });

        });

        describe('disabled rules', () => {
          it('rule with severity off ', async () => {
            const l1 = linter({catalog: test.catalog, rules: {}});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results.filter(r => r.ruleId === 'disabled-rule')).toHaveLength(0);
          });

          it('disable rule via rule config severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {'single-service': Severity.Off}});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.executionErrors.filter(r => r.ruleId === 'error-rule')).toHaveLength(1);
            expect(res1.results.filter(r => r.ruleId === 'single-service')).toHaveLength(0);
            expect(res1.executionErrors.filter(r => r.ruleId === 'single-service')).toHaveLength(0);

            const l2 = linter({catalog: test.catalog, rules: {'error-rule': Severity.Off}});
            const res2 = await l2.lint({st, moduleDir, protoDir});
            expect(res2.results.filter(r => r.ruleId === 'single-service')).toHaveLength(3);
            expect(res2.results.filter(r => r.ruleId === 'error-rule')).toHaveLength(0);
            expect(res2.executionErrors.filter(r => r.ruleId === 'error-rule')).toHaveLength(0);
          });

          it('disables rule via default severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {}, severity: Severity.Off});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results).toHaveLength(0);
            expect(res1.executionErrors).toHaveLength(0);
          });

          it('rule config severity has precedence over default severity', async () => {
            const l1 = linter({catalog: test.catalog, rules: {'single-service': Severity.Warning}, severity: Severity.Off});
            const res1 = await l1.lint({st, moduleDir, protoDir});
            expect(res1.results.every(r => r.ruleId === 'single-service')).toBeTruthy();
            expect(res1.executionErrors).toHaveLength(0);
          });
        });

      });

      describe('stateful', () => {
        const prevModuleDir = './test/modules/test-module-prev';
        const prevProtoDir = './test/modules/test-module-prev/proto';

        let res: LintResults;

        beforeAll(async () => {
          const st = await generateSyntaxTreeFromSource(protoDir);
          const prevSt = await generateSyntaxTreeFromSource(prevProtoDir);
          const l = linter({catalog: test.catalog, rules: {}});
          res = await l.lint({st, moduleDir, protoDir}, {st: prevSt, moduleDir: prevModuleDir, protoDir: prevProtoDir});
        });

        describe('report', () => {
          it('returns expected report', async () => {
            //test-module is a module with 2 files
            //catalog contains 6 rules:
            // "non-proto-rule" reports 1 issue not related to proto
            // "single-service" reports 3 issues
            // "invalid-field-name" reports 4 issues
            // "stateful-rule" should report 1 issue
            // "error-rule" always fails
            expect(res.results).toHaveLength(9);
            const nonProtoErrors = res.results.filter(res => res.ruleId === 'non-proto-rule');
            expect(nonProtoErrors).toHaveLength(1);
            expect(nonProtoErrors[0].filePath).toBeUndefined();
            expect(nonProtoErrors[0].ruleDoc).toEqual('https://github.com/wix-private/flynt/tree/master/packages/engine/test/catalogs/test-catalog/category-name/non-proto-rule/README.md');

            const singleServiceErrors = res.results.filter(res => res.ruleId === 'single-service');
            expect(singleServiceErrors).toHaveLength(3);
            expect(singleServiceErrors[0].ruleDoc).toEqual('http://www.single-service.com');
            expect(singleServiceErrors.filter(res => res.filePath === svcFullPath)).toHaveLength(1);
            expect(singleServiceErrors.filter(res => res.filePath === msgsFullPath)).toHaveLength(2);

            const invalidFieldError = res.results.filter(res => res.ruleId === 'invalid-field-name');
            expect(invalidFieldError).toHaveLength(4);
            expect(invalidFieldError[0].ruleDoc).toEqual('http://www.invalid-field-name.com');
            expect(invalidFieldError.filter(res => res.filePath === svcFullPath)).toHaveLength(2);
            expect(invalidFieldError.filter(res => res.filePath === msgsFullPath)).toHaveLength(2);

            const statefulRule = res.results.filter(res => res.ruleId === 'stateful-rule');
            expect(statefulRule).toHaveLength(1);
            expect(statefulRule[0].ruleDoc).toEqual('http://www.field-number-changed.com');
            expect(statefulRule.filter(res => res.filePath === svcFullPath)).toHaveLength(0);
            expect(statefulRule.filter(res => res.filePath === msgsFullPath)).toHaveLength(1);
          });

          it('returns a list of execution errors along with reports', async () => {
            expect(res.executionErrors).toHaveLength(2);
            const statelessRuleError = res.executionErrors.find(res => res.ruleId === 'error-rule');
            expect(statelessRuleError).toEqual({
              ruleId: 'error-rule',
              error: expect.stringMatching(/xxx/),
            });

            const statefulRuleError = res.executionErrors.find(res => res.ruleId === 'error-stateful-rule');
            expect(statefulRuleError).toEqual({
              ruleId: 'error-stateful-rule',
              error: expect.stringMatching(/yyy/),
            });
          });
        });
      });
    });
  });

  describe('strict', () => {
    const moduleDir = './test/modules/strict';
    const protoDir = './test/modules/strict/proto';
    let st: SyntaxTree;

    describe('stateless', () => {
      beforeAll(async () => {
        st = await generateSyntaxTreeFromSource(protoDir);
      });

      it('strict rules severity can not be changed', async () => {
        const l1 = linter({
          catalog: './test/catalogs/test-strict',
          rules: {
            'strict-rule': Severity.Warning,
            'non-strict-rule': Severity.Warning,
          }
        });
        const res = await l1.lint({st, moduleDir, protoDir});
        console.log(JSON.stringify(res, null, 1));
        expect(res.results).toEqual([
          expect.objectContaining({
            ruleId: 'non-strict-rule',
            severity: Severity.Warning,
          }),
          expect.objectContaining({
            ruleId: 'strict-rule',
            severity: Severity.Error,
            strict: true,
          })
        ]);
      });

      it('strict rules can not be disabled via rules config', async () => {
        const l1 = linter({
          catalog: './test/catalogs/test-strict',
          rules: {
            'strict-rule': Severity.Off,
            'non-strict-rule': Severity.Off,
          }
        });
        const res = await l1.lint({st, moduleDir, protoDir});
        console.log(JSON.stringify(res, null, 1));
        expect(res.results).toEqual([
          expect.objectContaining({
            ruleId: 'strict-rule',
            severity: Severity.Error,
            strict: true,
          })
        ]);
      });

      it('strict rules can not be disabled via default severity', async () => {
        const l1 = linter({catalog: './test/catalogs/test-strict', severity: Severity.Off, rules: {}});
        const res = await l1.lint({st, moduleDir, protoDir});
        console.log(JSON.stringify(res, null, 1));
        expect(res.results).toEqual([
          expect.objectContaining({
            ruleId: 'strict-rule',
            severity: Severity.Error,
            strict: true,
          })
        ]);
      });
    });
  });

  describe('grace period', () => {
    const moduleDir = './test/modules/test-module';
    const protoDir = './test/modules/test-module/proto';
    let st: SyntaxTree;
    let res: LintResults;

    describe('default date', () => {
      beforeAll(async () => {
        st = await generateSyntaxTreeFromSource(protoDir);
        const l = linter({catalog: './test/catalogs/test-grace-catalog', rules: {}});
        res = await l.lint({st, moduleDir, protoDir});
      });

      it('rule still in grace period should be reported as warning', async () => {
        expect(res.results.find(r => r.ruleId === 'error-severity-grace-until-year-9999')).toMatchObject<Partial<LintResult>>({
          severity: Severity.Warning, gracePeriod: {
            severityAfterGrace: Severity.Error, graceUntil: new Date('9999-01-01')
          }
        });
      });

      it('rule which passed grace period should be reported as error', async () => {
        expect(res.results.find(r => r.ruleId === 'error-severity-grace-until-year-2000')).toMatchObject({
          severity: Severity.Error
        });
      });
    });

    describe('fake date in the future', () => {
      beforeAll(async () => {
        st = await generateSyntaxTreeFromSource(protoDir);
        const l = linter({catalog: './test/catalogs/test-grace-catalog', rules: {}, date: new Date('10000-01-01')});
        res = await l.lint({st, moduleDir, protoDir});
      });

      it('as if we are in year 10000', async () => {
        expect(res.results.find(r => r.ruleId === 'error-severity-grace-until-year-9999')).toMatchObject({
          severity: Severity.Error
        });
      });
    });

    describe('fake date in the past', () => {
      beforeAll(async () => {
        st = await generateSyntaxTreeFromSource(protoDir);
        const l = linter({catalog: './test/catalogs/test-grace-catalog', rules: {}, date: new Date('1999-01-01')});
        res = await l.lint({st, moduleDir, protoDir});
      });

      it('as if we are in year 1999', async () => {
        expect(res.results.find(r => r.ruleId === 'error-severity-grace-until-year-2000')).toMatchObject<Partial<LintResult>>({
          severity: Severity.Warning, gracePeriod: {
            severityAfterGrace: Severity.Error, graceUntil: new Date('2000-01-01')
          }
        });
      });
    });
  });

  describe('errorIfNew', () => {
    const moduleDir = './test/modules/test-module';
    const protoDir = './test/modules/test-module/proto';
    let st: SyntaxTree;
    let res: LintResults;

    describe('stateless', () => {
      beforeAll(async () => {
        st = await generateSyntaxTreeFromSource(protoDir);
        const l = linter({catalog: './test/catalogs/test-error-if-new-catalog', rules: {}});
        res = await l.lint({st, moduleDir, protoDir});
      });

      it('reports all issues as warnings', async () => {
        expect(res.executionErrors).toEqual([]);
        expect(res.results).toEqual([
          expect.objectContaining<Partial<LintResult>>({
            ruleId: 'invalid-field-number',
            severity: Severity.Warning,
            resultId: '.com.wix.MethodRequest.new_field',
          }),
          expect.objectContaining<Partial<LintResult>>({
            ruleId: 'invalid-field-number',
            severity: Severity.Warning,
            resultId: '.com.wix.MethodResponse.existing_field',
          }),
        ]);
      });
    });

    describe('stateful', () => {
      const prevModuleDir = './test/modules/test-module-prev';
      const prevProtoDir = './test/modules/test-module-prev/proto';

      let res: LintResults;

      beforeAll(async () => {
        const st = await generateSyntaxTreeFromSource(protoDir);
        const prevSt = await generateSyntaxTreeFromSource(prevProtoDir);
        const l = linter({catalog: './test/catalogs/test-error-if-new-catalog', rules: {}});
        res = await l.lint({st, moduleDir, protoDir}, {st: prevSt, moduleDir: prevModuleDir, protoDir: prevProtoDir});
      });

      it('reports new issues as errors', async () => {
        expect(res.executionErrors).toEqual([]);
        expect(res.results).toEqual([
          expect.objectContaining<Partial<LintResult>>({
            ruleId: 'invalid-field-number',
            severity: Severity.Error,
            resultId: '.com.wix.MethodRequest.new_field',
          }),
          expect.objectContaining<Partial<LintResult>>({
            ruleId: 'invalid-field-number',
            severity: Severity.Warning,
            resultId: '.com.wix.MethodResponse.existing_field',
          }),
        ]);
      });
    });

  });

});
