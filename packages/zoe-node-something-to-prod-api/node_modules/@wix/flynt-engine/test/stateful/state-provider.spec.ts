import {genSt} from '@wix/proto-syntax-tree/dev';
import {SyntaxTree} from '@wix/proto-syntax-tree';
import {StateProvider} from '../../lib/stateful/state-provider';

describe('state provider', () => {
  let stateSt: SyntaxTree;
  let stateProvider: StateProvider;

  beforeAll(async () => {
    stateSt = await genSt(`
      service Service {
        rpc Method (Message) returns (Message) {
        }
      }

      message Message {
        oneof one_of {
          int32 int_field = 1;
        }
        string str_field = 2;

        message NestedMessage {
          enum NestedEnum {
             NESTED_VAL = 0;
          }
        }
      }

      message Message2 {
        Enum enum_field = 1;
      }

      enum Enum {
        VAL = 0;
        VAL_1 = 1;
      }
      `);
    stateProvider = new StateProvider(stateSt);
  });

  it('returns prev state based on fqn', async () => {
    const st = await genSt(`
      message Message {
        message NestedMessage {
          enum NestedEnum {
             NESTED_VAL = 0;
          }
        }
      }
    `);

    const msg = st.getMessage('.foo.bar.Message.NestedMessage');
    const prevMsg = stateProvider.getState(msg);

    expect(prevMsg).toEqual(stateSt.getMessage('.foo.bar.Message.NestedMessage'));
  });

  it('returns undefined if fqn was not found in previous state', async () => {
    const st = await genSt(`
      message MessageFoo {
      }
    `);

    const msg = st.getMessage('.foo.bar.MessageFoo');
    const prevMsg = stateProvider.getState(msg);

    expect(prevMsg).toBeUndefined();
  });

  it('returns undefined if fqn exists in previous state but is of a different type', async () => {
    const st = await genSt(`
      message Message {
        message NestedMessage {
          message NestedEnum {
          }
        }
      }
    `);

    const msg = st.getMessage('.foo.bar.Message.NestedMessage.NestedEnum');
    const prevMsg = stateProvider.getState(msg);

    expect(prevMsg).toBeUndefined();
  });
});
