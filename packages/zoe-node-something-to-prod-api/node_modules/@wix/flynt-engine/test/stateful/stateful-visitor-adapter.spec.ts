import {ProtoFile, SyntaxTree, TypeName, visitSyntaxTree} from '@wix/proto-syntax-tree';
import {adaptAddedVisitor, adaptModifiedVisitor, adaptRemovedVisitor, adaptStatefulVisitor} from '../../lib/stateful/stateful-visitor-adapter';
import {genSt} from '@wix/proto-syntax-tree/dev';
import {StatefulLoggingVisitor} from '../test-utils';
import {NewStateProvider, PrevStateProvider} from '../../lib/stateful/state-provider';

describe('stateful visitor adapters', () => {
  let st: SyntaxTree;

  const undefinedStateProvider: PrevStateProvider & NewStateProvider = {
    getPrevState: _ => undefined, //returns undefined as "PrevState"
    getNewState: _ => undefined, //returns undefined as "Newtate"
  };

  const sameStateProvider: PrevStateProvider & NewStateProvider = {
    getPrevState: type => type, //returns the same node as "PrevState"
    getNewState: type => type, //returns the same node as "NewState"
  };

  beforeAll(async () => {
    st = await genSt(`
      service Service {
        rpc Method (Message) returns (Message) {
        }
        rpc Method1 (Message) returns (Message) {
        }
      }

      message Message {
        oneof one_of {
          int32 field = 1;
        }

        message NestedMessage {
        }

        enum NestedEnum {
           NESTED_VAL = 0;
        }
      }

      message Message2 {

      }

      enum Enum {
        VAL = 0;
      }
      `);
  });

  describe('all nodes adapter', () => {
    it('ensure all elements are visited and receive same node as prev state', async () => {

      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptStatefulVisitor(statefulVisitor, sameStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['singleFile.proto [File]', 'singleFile.proto'],
        ['.foo.bar.Service [Service]', '.foo.bar.Service'],
        ['.foo.bar.Service.Method [Method]', '.foo.bar.Service.Method'],
        ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service.Method1'],
        ['.foo.bar.Message [Message]', '.foo.bar.Message'],
        ['.foo.bar.Message.NestedMessage [Message]', '.foo.bar.Message.NestedMessage'],
        ['.foo.bar.Message.NestedEnum [Enum]', '.foo.bar.Message.NestedEnum'],
        ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]', '.foo.bar.Message.NestedEnum.NESTED_VAL'],
        ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message.one_of'],
        ['.foo.bar.Message.field [Field]', '.foo.bar.Message.field'],
        ['.foo.bar.Message2 [Message]', '.foo.bar.Message2'],
        ['.foo.bar.Enum [Enum]', '.foo.bar.Enum'],
        ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum.VAL'],
      ]);

    });

    it('ensure all elements are visited and receive undefined as prev state', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptStatefulVisitor(statefulVisitor, undefinedStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['singleFile.proto [File]', undefined],
        ['.foo.bar.Service [Service]', undefined],
        ['.foo.bar.Service.Method [Method]', undefined],
        ['.foo.bar.Service.Method1 [Method]', undefined],
        ['.foo.bar.Message [Message]', undefined],
        ['.foo.bar.Message.NestedMessage [Message]', undefined],
        ['.foo.bar.Message.NestedEnum [Enum]', undefined],
        ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]', undefined],
        ['.foo.bar.Message.one_of [Oneof]', undefined],
        ['.foo.bar.Message.field [Field]', undefined],
        ['.foo.bar.Message2 [Message]', undefined],
        ['.foo.bar.Enum [Enum]', undefined],
        ['.foo.bar.Enum.VAL [EnumValue]', undefined],
      ]);
    });

    it('skips elements if visitor returns false', async () => {
      const visited: string[] = [];
      visitSyntaxTree(st,
        adaptStatefulVisitor({
          visitMessage(elem): boolean | void {
            visited.push(elem.fqn);
            return false;
          },
          visitField(elem) {
            visited.push(elem.fqn);
          }
        }, undefinedStateProvider)
      );

      expect(visited).toEqual([
        '.foo.bar.Message',
        '.foo.bar.Message2',
      ]);

    });

    it('ensure getPrevState is called only for implemented visit methods', async () => {
      const visited: string[] = [];
      const getPrevCalls: string[] = [];
      visitSyntaxTree(st,
        adaptStatefulVisitor({
          visitService(svc, prev) {
            visited.push(prev!.fqn);
          }
        }, {
          getPrevState: type => {
            getPrevCalls.push(type.fqn);
            return type;
          }
        })
      );

      expect(visited).toEqual(['.foo.bar.Service']);
      expect(getPrevCalls).toEqual(['.foo.bar.Service']);
    });

    it('ensure getPrevState is not called if visit methods do not accept previous state', async () => {
      const visited: string[] = [];
      visitSyntaxTree(st,
        adaptStatefulVisitor({
          visitService(svc) {
            visited.push(svc.fqn);
          }
        }, {
          getPrevState: _ => {
            fail('This should not happen');
          }
        })
      );

      expect(visited).toEqual(['.foo.bar.Service']);
    });
  });

  describe('modified elements adapter', () => {
    it('all elements are visited when prev state exists', async () => {

      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, sameStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['singleFile.proto [File]', 'singleFile.proto'],
        ['.foo.bar.Service [Service]', '.foo.bar.Service'],
        ['.foo.bar.Service.Method [Method]', '.foo.bar.Service.Method'],
        ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service.Method1'],
        ['.foo.bar.Message [Message]', '.foo.bar.Message'],
        ['.foo.bar.Message.NestedMessage [Message]', '.foo.bar.Message.NestedMessage'],
        ['.foo.bar.Message.NestedEnum [Enum]', '.foo.bar.Message.NestedEnum'],
        ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]', '.foo.bar.Message.NestedEnum.NESTED_VAL'],
        ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message.one_of'],
        ['.foo.bar.Message.field [Field]', '.foo.bar.Message.field'],
        ['.foo.bar.Message2 [Message]', '.foo.bar.Message2'],
        ['.foo.bar.Enum [Enum]', '.foo.bar.Enum'],
        ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum.VAL'],
      ]);

    });

    it('no elements are visited when prev state is undefined', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, undefinedStateProvider));

      expect(statefulVisitor.visited).toEqual([]);
    });

    it('skips elements if visitor returns false', async () => {
      const visited: string[] = [];
      visitSyntaxTree(st,
        adaptModifiedVisitor({
          visitMessage(elem): boolean | void {
            visited.push(elem.fqn);
            return false;
          },
          visitField(elem) {
            visited.push(elem.fqn);
          }
        }, sameStateProvider)
      );

      expect(visited).toEqual([
        '.foo.bar.Message',
        '.foo.bar.Message2',
      ]);

    });

    it('ensure getPrevState is called only for implemented visit methods', async () => {
      const visited: string[] = [];
      const getPrevCalls: string[] = [];
      visitSyntaxTree(st,
        adaptModifiedVisitor({
          visitService(svc, prev) {
            visited.push(prev!.fqn);
          }
        }, {
          getPrevState: type => {
            getPrevCalls.push(type.fqn);
            return type;
          }
        })
      );

      expect(visited).toEqual(['.foo.bar.Service']);
      expect(getPrevCalls).toEqual(['.foo.bar.Service']);
    });

    it('ensure getPrevState is called even if visit methods do not accept previous state', async () => {
      const visited: string[] = [];
      const getPrevCalls: string[] = [];
      visitSyntaxTree(st,
        adaptModifiedVisitor({
          visitService(svc) {
            visited.push(svc.fqn);
          }
        }, {
          getPrevState: type => {
            getPrevCalls.push(type.fqn);
            return type;
          }
        })
      );

      expect(visited).toEqual(['.foo.bar.Service']);
      expect(getPrevCalls).toEqual(['.foo.bar.Service']);
    });

    describe('skip', () => {
      it('no elements are visited if shouldVisitFile returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();

        statefulVisitor.shouldVisitFile = () => false;

        visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, sameStateProvider));

        expect(statefulVisitor.visited).toEqual([]);
      });

      it('no services/methods are visited if shouldVisitService returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitService = () => false;

        visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, sameStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['singleFile.proto [File]', 'singleFile.proto'],
          ['.foo.bar.Message [Message]', '.foo.bar.Message'],
          ['.foo.bar.Message.NestedMessage [Message]', '.foo.bar.Message.NestedMessage'],
          ['.foo.bar.Message.NestedEnum [Enum]', '.foo.bar.Message.NestedEnum'],
          ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]', '.foo.bar.Message.NestedEnum.NESTED_VAL'],
          ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message.one_of'],
          ['.foo.bar.Message.field [Field]', '.foo.bar.Message.field'],
          ['.foo.bar.Message2 [Message]', '.foo.bar.Message2'],
          ['.foo.bar.Enum [Enum]', '.foo.bar.Enum'],
          ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum.VAL'],
        ]);
      });

      it('no messages/fields/oneofs/nested enums are visited if shouldVisitMessage returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitMessage = () => false;

        visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, sameStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['singleFile.proto [File]', 'singleFile.proto'],
          ['.foo.bar.Service [Service]', '.foo.bar.Service'],
          ['.foo.bar.Service.Method [Method]', '.foo.bar.Service.Method'],
          ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service.Method1'],
          ['.foo.bar.Enum [Enum]', '.foo.bar.Enum'],
          ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum.VAL'],
        ]);
      });

      it('no enum/enum-values are visited if shouldVisitEnum returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitEnum = () => false;

        visitSyntaxTree(st, adaptModifiedVisitor(statefulVisitor, sameStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['singleFile.proto [File]', 'singleFile.proto'],
          ['.foo.bar.Service [Service]', '.foo.bar.Service'],
          ['.foo.bar.Service.Method [Method]', '.foo.bar.Service.Method'],
          ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service.Method1'],
          ['.foo.bar.Message [Message]', '.foo.bar.Message'],
          ['.foo.bar.Message.NestedMessage [Message]', '.foo.bar.Message.NestedMessage'],
          ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message.one_of'],
          ['.foo.bar.Message.field [Field]', '.foo.bar.Message.field'],
          ['.foo.bar.Message2 [Message]', '.foo.bar.Message2'],
        ]);
      });

      it('skips specific elements', async () => {
        const visited: string[] = [];
        visitSyntaxTree(st, adaptModifiedVisitor({
          visitEnumValue(enumValue) {
            visited.push(enumValue.fqn);
          },
          shouldVisitEnum(enm): boolean {
            return enm.name === 'NestedEnum';
          }
        }, sameStateProvider));

        expect(visited).toEqual([
          '.foo.bar.Message.NestedEnum.NESTED_VAL',
        ]);
      });
    });

  });

  describe('added elements adapter', () => {
    it('no elements are visited when prev state exists', async () => {

      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, sameStateProvider));

      expect(statefulVisitor.visited).toEqual([]);

    });

    it('leaf elements are visited if prev state did not exist', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const prevStateProvider: PrevStateProvider = {
        //returns undefined for fields
        getPrevState: type => type.typeName === TypeName.Field ? undefined : type
      };

      visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['.foo.bar.Message.field [Field]'],
      ]);
    });

    it('container elements are visited if prev state did not exist but leaf elements are skipped', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const prevStateProvider: PrevStateProvider = {
        //returns undefined for messages
        getPrevState: type => type.typeName === TypeName.Message ? undefined : type
      };

      visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['.foo.bar.Message [Message]'],
        ['.foo.bar.Message2 [Message]'],
      ]);
    });

    it('file is visited if prev state did not exist but entire hierarchy beneath it is skipped', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const prevStateProvider: PrevStateProvider = {
        //returns undefined for file
        getPrevState: type => type.typeName === TypeName.File ? undefined : type
      };

      visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['singleFile.proto [File]'],
      ]);
    });

    it('nothing is visited if container is new but visitor is implemented only for leaf elements', async () => {
      const visited: string[] = [];

      const prevStateProvider: PrevStateProvider = {
        //returns undefined for messages
        getPrevState: type => type.typeName === TypeName.Message ? undefined : type
      };

      visitSyntaxTree(st,
        adaptAddedVisitor({
          visitField(elem) {
            visited.push(elem.fqn);
          }
        }, prevStateProvider)
      );

      expect(visited).toEqual([]);

    });

    it('child elements are visited if parent is not new but skipped if parent is new', async () => {
      const visited: string[] = [];

      const prevStateProvider: PrevStateProvider = {
        //returns undefined for messages and enums
        getPrevState: type => type.typeName === TypeName.Message || type.typeName === TypeName.Enum ? undefined : type
      };

      visitSyntaxTree(st,
        adaptAddedVisitor({
          visitEnum(elem) {
            visited.push(elem.fqn);
          }
        }, prevStateProvider)
      );

      expect(visited).toEqual([
        '.foo.bar.Enum',
      ]);

    });

    describe('skip', () => {
      it('no elements are visited if shouldVisitFile returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitFile = () => false;

        const prevStateProvider: PrevStateProvider = {
          //returns undefined for leafs
          getPrevState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

        expect(statefulVisitor.visited).toEqual([]);
      });

      it('no methods are visited if shouldVisitService returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitService = () => false;

        const prevStateProvider: PrevStateProvider = {
          //returns undefined for leafs
          getPrevState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]'],
          ['.foo.bar.Message.one_of [Oneof]'],
          ['.foo.bar.Message.field [Field]'],
          ['.foo.bar.Enum.VAL [EnumValue]'],
        ]);
      });

      it('no fields/oneofs/nested enums are visited if shouldVisitMessage returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitMessage = () => false;

        const prevStateProvider: PrevStateProvider = {
          //returns undefined for leafs
          getPrevState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Service.Method [Method]'],
          ['.foo.bar.Service.Method1 [Method]'],
          ['.foo.bar.Enum.VAL [EnumValue]'],
        ]);
      });

      it('no enum values are visited if shouldVisitEnum returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitEnum = () => false;

        const prevStateProvider: PrevStateProvider = {
          //returns undefined for leafs
          getPrevState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptAddedVisitor(statefulVisitor, prevStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Service.Method [Method]'],
          ['.foo.bar.Service.Method1 [Method]'],
          ['.foo.bar.Message.one_of [Oneof]'],
          ['.foo.bar.Message.field [Field]'],
        ]);
      });

      it('skips specific elements', async () => {
        const visited: string[] = [];

        const prevStateProvider: PrevStateProvider = {
          //returns undefined for leafs
          getPrevState: type => type.typeName === TypeName.EnumValue ? undefined : type
        };

        visitSyntaxTree(st, adaptAddedVisitor({
          visitEnumValue(enumValue) {
            visited.push(enumValue.fqn);
          },
          shouldVisitEnum(enm): boolean {
            return enm.name === 'NestedEnum';
          }
        }, prevStateProvider));

        expect(visited).toEqual([
          '.foo.bar.Message.NestedEnum.NESTED_VAL',
        ]);
      });
    });
  });

  describe('removed elements adapter', () => {
    it('no elements are visited when new state exists', async () => {

      const statefulVisitor = new StatefulLoggingVisitor();

      visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, sameStateProvider));

      expect(statefulVisitor.visited).toEqual([]);

    });

    it('leaf elements are visited if new state does not exist', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const newStateProvider: NewStateProvider = {
        //returns undefined for leafs
        getNewState: type => type.typeName === TypeName.Field ? undefined : type
      };

      visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['.foo.bar.Message.field [Field]', '.foo.bar.Message'],
      ]);
    });

    it('container elements are visited if new state does not exist but leaf elements are skipped', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const newStateProvider: NewStateProvider = {
        //returns undefined for messages
        getNewState: type => type.typeName === TypeName.Message ? undefined : type
      };

      visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['.foo.bar.Message [Message]', 'singleFile.proto'],
        ['.foo.bar.Message2 [Message]', 'singleFile.proto'],
      ]);
    });

    it('file is visited if new state does not exist but entire hierarchy beneath it is skipped', async () => {
      const statefulVisitor = new StatefulLoggingVisitor();

      const newStateProvider: NewStateProvider = {
        //returns undefined for file
        getNewState: type => type.typeName === TypeName.File ? undefined : type
      };

      visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

      expect(statefulVisitor.visited).toEqual([
        ['singleFile.proto [File]'],
      ]);
    });

    it('nothing is visited if container is removed but visitor is implemented only for leaf elements', async () => {
      const visited: string[] = [];

      const newStateProvider: NewStateProvider = {
        //returns undefined for messages
        getNewState: type => type.typeName === TypeName.Message ? undefined : type
      };

      visitSyntaxTree(st,
        adaptRemovedVisitor({
          visitField(elem) {
            visited.push(elem.fqn);
          }
        }, newStateProvider)
      );

      expect(visited).toEqual([]);
    });

    it('child elements are visited if parent is not removed but skipped if parent is removed', async () => {
      const visited: string[] = [];

      const newStateProvider: NewStateProvider = {
        //returns undefined for messages and enums
        getNewState: type => type.typeName === TypeName.Message || type.typeName === TypeName.Enum ? undefined : type
      };

      visitSyntaxTree(st,
        adaptRemovedVisitor({
          visitEnum(elem) {
            visited.push(elem.fqn);
          }
        }, newStateProvider)
      );

      expect(visited).toEqual([
        '.foo.bar.Enum',
      ]);

    });

    describe('parent', () => {
      it('when file is removed no parent is passed', async () => {
        const visited: string[] = [];

        const newStateProvider: NewStateProvider = {
          //returns undefined for messages
          getNewState: type => type.typeName === TypeName.File ? undefined : type
        };

        visitSyntaxTree(st,
          adaptRemovedVisitor({
            //@ts-expect-error visitFile should accept only a single parameter
            visitFile(file: ProtoFile, parent: any) {
              visited.push(file.fqn);
              expect(parent).toBeUndefined();
              expect(arguments.length).toEqual(1);
            }
          }, newStateProvider)
        );
        expect(visited).toEqual(['singleFile.proto']);
      });

      it('when message is removed from file, file is passed as parent', async () => {
        const visited: string[] = [];

        const newStateProvider: NewStateProvider = {
          //returns undefined for files
          getNewState: type => type.typeName === TypeName.Message ? undefined : type
        };

        visitSyntaxTree(st,
          adaptRemovedVisitor({
            visitMessage(message, parent) {
              visited.push(message.fqn);
              expect(parent.typeName).toEqual(TypeName.File);
            }
          }, newStateProvider)
        );
        expect(visited).toEqual([
          '.foo.bar.Message',
          '.foo.bar.Message2',
        ]);
      });

      it('when nested message is removed , parent message is passed as parent', async () => {
        const visited: string[] = [];

        const newStateProvider: NewStateProvider = {
          //returns undefined for nested messages
          getNewState: type => type.typeName === TypeName.Message && type.parent.typeName === TypeName.Message ? undefined : type
        };

        visitSyntaxTree(st,
          adaptRemovedVisitor({
            visitMessage(message, parent) {
              visited.push(message.fqn);
              expect(parent.typeName).toEqual(TypeName.Message);
            }
          }, newStateProvider)
        );
        expect(visited).toEqual([
          '.foo.bar.Message.NestedMessage',
        ]);
      });
    });

    describe('skip', () => {
      it('no elements are visited if shouldVisitFile returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitFile = () => false;

        const newStateProvider: NewStateProvider = {
          //returns undefined for leafs
          getNewState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

        expect(statefulVisitor.visited).toEqual([]);
      });

      it('no methods are visited if shouldVisitService returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitService = () => false;

        const newStateProvider: NewStateProvider = {
          //returns undefined for leafs
          getNewState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Message.NestedEnum.NESTED_VAL [EnumValue]', '.foo.bar.Message.NestedEnum'],
          ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message'],
          ['.foo.bar.Message.field [Field]', '.foo.bar.Message'],
          ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum']
        ]);
      });

      it('no fields/oneofs/nested enums are visited if shouldVisitMessage returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitMessage = () => false;

        const newStateProvider: NewStateProvider = {
          //returns undefined for leafs
          getNewState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Service.Method [Method]', '.foo.bar.Service'],
          ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service'],
          ['.foo.bar.Enum.VAL [EnumValue]', '.foo.bar.Enum']
        ]);
      });

      it('no enum values are visited if shouldVisitEnum returns false', async () => {
        const statefulVisitor = new StatefulLoggingVisitor();
        statefulVisitor.shouldVisitEnum = () => false;

        const newStateProvider: NewStateProvider = {
          //returns undefined for leafs
          getNewState: type => [TypeName.Field, TypeName.EnumValue, TypeName.Oneof, TypeName.Method].includes(type.typeName) ? undefined : type
        };

        visitSyntaxTree(st, adaptRemovedVisitor(statefulVisitor, newStateProvider));

        expect(statefulVisitor.visited).toEqual([
          ['.foo.bar.Service.Method [Method]', '.foo.bar.Service'],
          ['.foo.bar.Service.Method1 [Method]', '.foo.bar.Service'],
          ['.foo.bar.Message.one_of [Oneof]', '.foo.bar.Message'],
          ['.foo.bar.Message.field [Field]', '.foo.bar.Message'],
        ]);
      });

      it('skips specific elements', async () => {
        const visited: string[] = [];

        const newStateProvider: NewStateProvider = {
          //returns undefined for leafs
          getNewState: type => type.typeName === TypeName.EnumValue ? undefined : type
        };

        visitSyntaxTree(st, adaptRemovedVisitor({
          visitEnumValue(enumValue) {
            visited.push(enumValue.fqn);
          },
          shouldVisitEnum(enm): boolean {
            return enm.name === 'NestedEnum';
          }
        }, newStateProvider));

        expect(visited).toEqual([
          '.foo.bar.Message.NestedEnum.NESTED_VAL',
        ]);
      });
    });
  });
});

