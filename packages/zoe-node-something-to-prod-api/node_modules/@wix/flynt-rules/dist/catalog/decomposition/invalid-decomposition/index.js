"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rule = void 0;
const flynt_engine_1 = require("@wix/flynt-engine");
const wix_protos_1 = require("@wix/wix-protos");
const fqdn_utils_1 = require("../../fqdn-utils");
exports.rule = {
    description: 'Message must conform to decomposition rules',
    moreInfoUrl: 'https://bo.wix.com/wix-docs/rnd/platformization-guidelines/common-proto-messages-usage-patterns#platformization-guidelines_common-proto-messages-usage-patterns_diverting-from-the-common-definition-de-composition',
    run(ctx) {
        function assertValidDecomposite(message, decompositeOf) {
            const result = ctx.st.findType(decompositeOf) ||
                getCommon().findType(decompositeOf);
            if (ctx.assert(result, {
                errorAt: message,
                message: `Could not find decomposition source: ${decompositeOf}`,
            })) {
                if (result.typeName !== flynt_engine_1.TypeName.Message) {
                    ctx.report({
                        errorAt: message,
                        message: `Invalid decomposition. Source must be a 'Message' but found '${result.typeName}'`,
                    });
                    return undefined;
                }
                return result;
            }
        }
        function assertFieldTypesAreCompatible(fieldType, sourceFieldType, field, sourceField) {
            const report = {
                errorAt: field,
                message: `Invalid field type for '${field.name}'. Expected '${sourceFieldType.toString()}' but found '${fieldType.toString()}'`,
            };
            if (ctx.assert(fieldType.kind === sourceFieldType.kind, report)) {
                switch (fieldType.kind) {
                    case flynt_engine_1.FieldKind.Repeated:
                        assertFieldTypesAreCompatible(fieldType.elementType, sourceFieldType.elementType, field, sourceField);
                        break;
                    case flynt_engine_1.FieldKind.Wrapper:
                        ctx.assert(fieldType.type === sourceFieldType.type, report);
                        break;
                    case flynt_engine_1.FieldKind.Primitive:
                        ctx.assert(fieldType.type === sourceFieldType.type, report);
                        break;
                    case flynt_engine_1.FieldKind.Enum:
                        break;
                    case flynt_engine_1.FieldKind.Message:
                        assertMessageFieldsAreCompatible(fieldType.message, sourceFieldType.message, field);
                        break;
                }
            }
        }
        function assertMessageFieldsAreCompatible(message, sourceMessage, field) {
            if (message.fqn !== sourceMessage.fqn) {
                const isDecompositionMessage = message.options.getTypedOption(wix_protos_1.wix.api.decomposite_of);
                ctx.assert(isDecompositionMessage?.value && (0, fqdn_utils_1.fqnsEqual)(isDecompositionMessage?.value, sourceMessage.fqn), {
                    errorAt: field,
                    message: `Field must be a decomposite of ${sourceMessage.fqn}`
                });
            }
        }
        function assertFieldAreCompatible(field, sourceField) {
            ctx.assert(field.number === sourceField.number, {
                errorAt: field,
                message: `Field '${field.name}' has a different field number than the source field in '${(0, fqdn_utils_1.toLocalFqn)(sourceField.parent.fqn)}'`,
            });
            assertFieldTypesAreCompatible(field.fieldType, sourceField.fieldType, field, sourceField);
        }
        ctx.visit({
            visitMessage(message) {
                const isDecompositionMessage = message.options.getTypedOption(wix_protos_1.wix.api.decomposite_of);
                if (isDecompositionMessage && isDecompositionMessage.value) {
                    const sourceMsg = assertValidDecomposite(message, isDecompositionMessage.value);
                    if (sourceMsg) {
                        const decompositionFieldsOptions = sourceMsg.options.getTypedOption(wix_protos_1.wix.api.decomposition_minimum_fields);
                        if (decompositionFieldsOptions.length) {
                            const messageFieldNames = new Set(message.fields.map(field => field.name));
                            const isDecompositionSatisfied = decompositionFieldsOptions.find(decompositionOptions => decompositionOptions.value.field && decompositionOptions.value.field.every(field => messageFieldNames.has(field)));
                            ctx.assert(isDecompositionSatisfied, {
                                errorAt: message,
                                message: `Message fields must satisfy at least one of the 'decomposition_minimum_fields' defined: ${decompositionFieldsOptions.map(fs => (fs.value.field || [])).join(' ; ')}`
                            });
                        }
                        for (const field of message.fields) {
                            const sourceField = sourceMsg.fields.byName(field.name);
                            if (ctx.assert(sourceField, {
                                errorAt: field,
                                message: `Decomposition message should not define additional fields. Field '${field.name}' is not defined in the source message '${(0, fqdn_utils_1.toLocalFqn)(sourceMsg.fqn)}'`
                            })) {
                                assertFieldAreCompatible(field, sourceField);
                            }
                        }
                    }
                }
            },
        });
    }
};
let commonSt;
function getCommon() {
    if (!commonSt) {
        commonSt = (0, wix_protos_1.getCommonSt)();
    }
    return commonSt;
}
//# sourceMappingURL=index.js.map