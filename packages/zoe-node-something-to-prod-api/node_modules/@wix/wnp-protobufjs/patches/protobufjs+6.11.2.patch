diff --git a/node_modules/protobufjs/index.d.ts b/node_modules/protobufjs/index.d.ts
index bbe6432..48c1c8b 100644
--- a/node_modules/protobufjs/index.d.ts
+++ b/node_modules/protobufjs/index.d.ts
@@ -870,7 +870,7 @@ export abstract class ReflectionObject {
     public options?: { [k: string]: any };
 
     /** Parsed Options. */
-    public parsedOptions?: { [k: string]: any[] };
+    public parsedOptions?: ({ [k: string]: any})[];
 
     /** Unique name within its namespace. */
     public name: string;
@@ -1071,6 +1071,9 @@ export interface IParseOptions {
 
     /** Use trailing comment when both leading comment and trailing comment exist. */
     preferTrailingComment?: boolean;
+
+    /** function to use when camel casing a field name */
+    camelCase?: (str: string) => string;
 }
 
 /** Options modifying the behavior of JSON serialization. */
@@ -1663,9 +1666,10 @@ export class Type extends NamespaceBase {
     /**
      * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
      * @param object Plain object to convert
+     * @param [options] Conversion options
      * @returns Message instance
      */
-    public fromObject(object: { [k: string]: any }): Message<{}>;
+    public fromObject(object: { [k: string]: any }, options?: IConversionOptions): Message<{}>;
 
     /**
      * Creates a plain object from a message of this type. Also converts values to other types if specified.
diff --git a/node_modules/protobufjs/index.js b/node_modules/protobufjs/index.js
index 042042a..2be31c3 100644
--- a/node_modules/protobufjs/index.js
+++ b/node_modules/protobufjs/index.js
@@ -2,3 +2,6 @@
 
 "use strict";
 module.exports = require("./src/index");
+module.exports.util.isNode = true;
+
+require('./ext/descriptor');
diff --git a/node_modules/protobufjs/src/common.js b/node_modules/protobufjs/src/common.js
index 489ee1c..750adb7 100644
--- a/node_modules/protobufjs/src/common.js
+++ b/node_modules/protobufjs/src/common.js
@@ -52,7 +52,7 @@ common("any", {
      */
     Any: {
         fields: {
-            type_url: {
+            typeUrl: {
                 type: "string",
                 id: 1
             },
diff --git a/node_modules/protobufjs/src/converter.js b/node_modules/protobufjs/src/converter.js
index 44d952e..dd0b753 100644
--- a/node_modules/protobufjs/src/converter.js
+++ b/node_modules/protobufjs/src/converter.js
@@ -35,7 +35,7 @@ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
         } else gen
             ("if(typeof d%s!==\"object\")", prop)
                 ("throw TypeError(%j)", field.fullName + ": object expected")
-            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
+            ("m%s=types[%i].fromObject(d%s, o)", prop, fieldIndex, prop);
     } else {
         var isUnsigned = false;
         switch (field.type) {
@@ -59,7 +59,7 @@ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
             case "sint64":
             case "fixed64":
             case "sfixed64": gen
-                ("if(util.Long)")
+                ("if(o.longs!==String && util.Long)")
                     ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                 ("else if(typeof d%s===\"string\")", prop)
                     ("m%s=parseInt(d%s,10)", prop, prop)
@@ -97,7 +97,9 @@ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
 converter.fromObject = function fromObject(mtype) {
     /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
     var fields = mtype.fieldsArray;
-    var gen = util.codegen(["d"], mtype.name + "$fromObject")
+    var gen = util.codegen(["d", "o"], mtype.name + "$fromObject")
+    ("if(!o)")
+      ("o={}")
     ("if(d instanceof this.ctor)")
         ("return d");
     if (!fields.length) return gen
@@ -239,7 +241,7 @@ converter.toObject = function toObject(mtype) {
             if (field.resolvedType instanceof Enum) gen
         ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
             else if (field.long) gen
-        ("if(util.Long){")
+        ("if(o.longs!==String && util.Long){")
             ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
             ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
         ("}else")
diff --git a/node_modules/protobufjs/src/field.js b/node_modules/protobufjs/src/field.js
index 20c1cd2..2be3730 100644
--- a/node_modules/protobufjs/src/field.js
+++ b/node_modules/protobufjs/src/field.js
@@ -35,7 +35,9 @@ var ruleRe = /^required|optional|repeated$/;
  * @throws {TypeError} If arguments are invalid
  */
 Field.fromJSON = function fromJSON(name, json) {
-    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
+    const field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
+    field.parsedOptions = json.parsedOptions;
+    return field;
 };
 
 /**
@@ -250,7 +252,8 @@ Field.prototype.toJSON = function toJSON(toJSONOptions) {
         "id"      , this.id,
         "extend"  , this.extend,
         "options" , this.options,
-        "comment" , keepComments ? this.comment : undefined
+        "comment" , keepComments ? this.comment : undefined,
+        "parsedOptions"  , this.parsedOptions,
     ]);
 };
 
diff --git a/node_modules/protobufjs/src/method.js b/node_modules/protobufjs/src/method.js
index 18a6ab2..3a53560 100644
--- a/node_modules/protobufjs/src/method.js
+++ b/node_modules/protobufjs/src/method.js
@@ -122,7 +122,9 @@ function Method(name, type, requestType, responseType, requestStream, responseSt
  * @throws {TypeError} If arguments are invalid
  */
 Method.fromJSON = function fromJSON(name, json) {
-    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
+    const method = new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
+    method.rawOptions = json.rawOptions;
+    return method;
 };
 
 /**
diff --git a/node_modules/protobufjs/src/namespace.js b/node_modules/protobufjs/src/namespace.js
index 88837a5..65b54bf 100644
--- a/node_modules/protobufjs/src/namespace.js
+++ b/node_modules/protobufjs/src/namespace.js
@@ -320,12 +320,79 @@ Namespace.prototype.resolveAll = function resolveAll() {
  */
 Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
 
+    if (typeof filterTypes === 'boolean') {
+        parentAlreadyChecked = filterTypes;
+        filterTypes = undefined;
+    } else if (filterTypes && !Array.isArray(filterTypes)) {
+        filterTypes = [filterTypes];
+    }
+
+    if (util.isString(path) && path.length) {
+        if (path === '.') {
+            return this.root;
+        }
+        path = path.split('.');
+    } else if (!path.length) {
+        return this;
+    }
+
+
+    // Start at root if path is absolute
+    if (path[0] === '') {
+        return this.root.lookup(path.slice(1), filterTypes);
+    }
+
+    // Test if the first part matches any nested object, and if so, traverse if path contains more
+    var found = this.get(path[0]);
+    if (found) {
+        if (path.length === 1) {
+            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) {
+                return found;
+            }
+        } else {
+            if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) {
+                return found;
+            } else if (this.root.strictMode) { /* Diff #1 */
+                return null;
+            }
+        }
+    }/* Diff #2 */
+
+    // If there hasn't been a match, try again at the parent
+    if (this.parent === null || parentAlreadyChecked) {
+        return null;
+    }
+    return this.parent.lookup(path, filterTypes);
+};
+
+Namespace.prototype.lookupOrThrow = function lookupOrThrow(path, filterTypes, errorMsg) {
+    var found = this.lookup(path, filterTypes);
+    if (!found) {
+        //To help devs fix their currently working protos, use the old logic and provide hints what to fix
+        const wronglyFound = this.lookupOld(path, filterTypes);
+        if (wronglyFound) {
+            //Prefer short namespace form (i.e. com.wix.Message) rather than global scoped namespace (i.e. .com.wix.Message)
+            const alternativeName = wronglyFound.fullName.substr(1);
+            if (this.lookup(alternativeName, filterTypes)) {
+                errorMsg += ' Did you mean ' + alternativeName;
+            } else {
+                errorMsg += ' Did you mean ' + wronglyFound.fullName;
+            }
+        }
+        throw Error(errorMsg);
+    }
+    return found;
+};
+
+//This is the original version of `Namespace#lookup` from protobufjs with all calls to `.lookup` modified to call `.lookupOld`
+/* eslint-disable */ //added to keep source code as close as possible to original form
+Namespace.prototype.lookupOld = function lookup(path, filterTypes, parentAlreadyChecked) {
     /* istanbul ignore next */
     if (typeof filterTypes === "boolean") {
         parentAlreadyChecked = filterTypes;
         filterTypes = undefined;
     } else if (filterTypes && !Array.isArray(filterTypes))
-        filterTypes = [ filterTypes ];
+        filterTypes = [filterTypes];
 
     if (util.isString(path) && path.length) {
         if (path === ".")
@@ -336,7 +403,7 @@ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChe
 
     // Start at root if path is absolute
     if (path[0] === "")
-        return this.root.lookup(path.slice(1), filterTypes);
+        return this.root.lookupOld(path.slice(1), filterTypes);
 
     // Test if the first part matches any nested object, and if so, traverse if path contains more
     var found = this.get(path[0]);
@@ -344,19 +411,19 @@ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChe
         if (path.length === 1) {
             if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                 return found;
-        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
+        } else if (found instanceof Namespace && (found = found.lookupOld(path.slice(1), filterTypes, true)))
             return found;
 
-    // Otherwise try each nested namespace
+        // Otherwise try each nested namespace
     } else
         for (var i = 0; i < this.nestedArray.length; ++i)
-            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
+            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookupOld(path, filterTypes, true)))
                 return found;
 
     // If there hasn't been a match, try again at the parent
     if (this.parent === null || parentAlreadyChecked)
         return null;
-    return this.parent.lookup(path, filterTypes);
+    return this.parent.lookupOld(path, filterTypes);
 };
 
 /**
@@ -378,9 +445,7 @@ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChe
  * @throws {Error} If `path` does not point to a type
  */
 Namespace.prototype.lookupType = function lookupType(path) {
-    var found = this.lookup(path, [ Type ]);
-    if (!found)
-        throw Error("no such type: " + path);
+    var found = this.lookupOrThrow(path, [Type], 'no such type: ' + path);
     return found;
 };
 
@@ -392,9 +457,7 @@ Namespace.prototype.lookupType = function lookupType(path) {
  * @throws {Error} If `path` does not point to an enum
  */
 Namespace.prototype.lookupEnum = function lookupEnum(path) {
-    var found = this.lookup(path, [ Enum ]);
-    if (!found)
-        throw Error("no such Enum '" + path + "' in " + this);
+    var found = this.lookupOrThrow(path, [Enum], 'no such Enum: ' + path);
     return found;
 };
 
@@ -406,9 +469,7 @@ Namespace.prototype.lookupEnum = function lookupEnum(path) {
  * @throws {Error} If `path` does not point to a type or enum
  */
 Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
-    var found = this.lookup(path, [ Type, Enum ]);
-    if (!found)
-        throw Error("no such Type or Enum '" + path + "' in " + this);
+    var found = this.lookupOrThrow(path, [Type, Enum], 'no such Type or enum: ' + path);
     return found;
 };
 
@@ -420,9 +481,7 @@ Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
  * @throws {Error} If `path` does not point to a service
  */
 Namespace.prototype.lookupService = function lookupService(path) {
-    var found = this.lookup(path, [ Service ]);
-    if (!found)
-        throw Error("no such Service '" + path + "' in " + this);
+    var found = this.lookupOrThrow(path, [Service], 'no such service: ' + path);
     return found;
 };
 
diff --git a/node_modules/protobufjs/src/object.js b/node_modules/protobufjs/src/object.js
index bd04cec..f3e3bb4 100644
--- a/node_modules/protobufjs/src/object.js
+++ b/node_modules/protobufjs/src/object.js
@@ -180,9 +180,11 @@ ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet)
  * @param {string} name parsed Option name
  * @param {*} value Option value
  * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
+ * @param {string} comment Option comment
  * @returns {ReflectionObject} `this`
  */
-ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
+ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName, comment) {
+    var COMMENT_FIELD = '__comment';
     if (!this.parsedOptions) {
         this.parsedOptions = [];
     }
@@ -196,17 +198,21 @@ ReflectionObject.prototype.setParsedOption = function setParsedOption(name, valu
         if (opt) {
             // If we found an existing option - just merge the property value
             var newValue = opt[name];
+            var newComment = opt[COMMENT_FIELD];
             util.setProperty(newValue, propName, value);
+            util.setProperty(newComment, propName, comment);
         } else {
             // otherwise, create a new option, set it's property and add it to the list
             opt = {};
             opt[name] = util.setProperty({}, propName, value);
+            opt[COMMENT_FIELD] = util.setProperty({}, propName, comment);
             parsedOptions.push(opt);
         }
     } else {
         // Always create a new option when setting the value of the option itself
         var newOpt = {};
         newOpt[name] = value;
+        newOpt[COMMENT_FIELD] = comment;
         parsedOptions.push(newOpt);
     }
     return this;
diff --git a/node_modules/protobufjs/src/parse.js b/node_modules/protobufjs/src/parse.js
index 144feed..ebf4fa1 100644
--- a/node_modules/protobufjs/src/parse.js
+++ b/node_modules/protobufjs/src/parse.js
@@ -86,7 +86,13 @@ function parse(source, root, options) {
 
     var ptr = root;
 
-    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;
+    var applyCase = options.keepCase ? function(name) { return name; } : (options.camelCase || util.camelCase);
+
+    function skip_all(token, optional) {
+      if (skip(token, optional)) {
+        while (skip(token, true)) { /* loop */ }
+      }
+    }
 
     /* istanbul ignore next */
     function illegal(token, name, insideTryCatch) {
@@ -144,7 +150,7 @@ function parse(source, root, options) {
             else
                 target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
         } while (skip(",", true));
-        skip(";");
+        skip_all(";");
     }
 
     function parseNumber(token, insideTryCatch) {
@@ -214,7 +220,7 @@ function parse(source, root, options) {
             throw illegal(pkg, "name");
 
         ptr = ptr.define(pkg);
-        skip(";");
+        skip_all(";");
     }
 
     function parseImport() {
@@ -233,7 +239,7 @@ function parse(source, root, options) {
                 break;
         }
         token = readString();
-        skip(";");
+        skip_all(";");
         whichImports.push(token);
     }
 
@@ -246,7 +252,7 @@ function parse(source, root, options) {
         if (!isProto3 && syntax !== "proto2")
             throw illegal(syntax, "syntax");
 
-        skip(";");
+        skip_all(";");
     }
 
     function parseCommon(parent, token) {
@@ -254,7 +260,6 @@ function parse(source, root, options) {
 
             case "option":
                 parseOption(parent, token);
-                skip(";");
                 return true;
 
             case "message":
@@ -288,11 +293,11 @@ function parse(source, root, options) {
             var token;
             while ((token = next()) !== "}")
                 fnIf(token);
-            skip(";", true);
+            skip_all(";", true);
         } else {
             if (fnElse)
                 fnElse();
-            skip(";");
+            skip_all(";");
             if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                 obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
         }
@@ -380,7 +385,6 @@ function parse(source, root, options) {
             /* istanbul ignore else */
             if (token === "option") {
                 parseOption(field, token);
-                skip(";");
             } else
                 throw illegal(token);
 
@@ -426,7 +430,6 @@ function parse(source, root, options) {
 
                 case "option":
                     parseOption(type, token);
-                    skip(";");
                     break;
 
                 case "required":
@@ -481,7 +484,6 @@ function parse(source, root, options) {
             /* istanbul ignore else */
             if (token === "option") {
                 parseOption(field, token);
-                skip(";");
             } else
                 throw illegal(token);
 
@@ -501,7 +503,6 @@ function parse(source, root, options) {
         ifBlock(oneof, function parseOneOf_block(token) {
             if (token === "option") {
                 parseOption(oneof, token);
-                skip(";");
             } else {
                 push(token);
                 parseField(oneof, "optional");
@@ -521,7 +522,6 @@ function parse(source, root, options) {
           switch(token) {
             case "option":
               parseOption(enm, token);
-              skip(";");
               break;
 
             case "reserved":
@@ -549,7 +549,6 @@ function parse(source, root, options) {
             /* istanbul ignore else */
             if (token === "option") {
                 parseOption(dummy, token); // skip
-                skip(";");
             } else
                 throw illegal(token);
 
@@ -559,7 +558,7 @@ function parse(source, root, options) {
         parent.add(token, value, dummy.comment);
     }
 
-    function parseOption(parent, token) {
+    function parseOption(parent, token, isInline) {
         var isCustom = skip("(", true);
 
         /* istanbul ignore if */
@@ -568,6 +567,7 @@ function parse(source, root, options) {
 
         var name = token;
         var option = name;
+        var comment = cmnt();
         var propName;
 
         if (isCustom) {
@@ -583,7 +583,14 @@ function parse(source, root, options) {
         }
         skip("=");
         var optionValue = parseOptionValue(parent, name);
-        setParsedOption(parent, option, optionValue, propName);
+        var trailingLine = tn.line;
+        if (!isInline) {
+            skip_all(";");
+        }
+        if (preferTrailingComment) {
+            comment = cmnt(trailingLine) || comment;
+        }
+        setParsedOption(parent, option, optionValue, propName, comment);
     }
 
     function parseOptionValue(parent, name) {
@@ -612,7 +619,9 @@ function parse(source, root, options) {
                     value = [].concat(prevValue).concat(value);
                 result[propName] = value;
                 skip(",", true);
+                skip_all(";", true);
             }
+            setOption(parent, name, result);
             return result;
         }
 
@@ -627,15 +636,15 @@ function parse(source, root, options) {
             parent.setOption(name, value);
     }
 
-    function setParsedOption(parent, name, value, propName) {
+    function setParsedOption(parent, name, value, propName, comment) {
         if (parent.setParsedOption)
-            parent.setParsedOption(name, value, propName);
+            parent.setParsedOption(name, value, propName, comment);
     }
 
     function parseInlineOptions(parent) {
         if (skip("[", true)) {
             do {
-                parseOption(parent, "option");
+                parseOption(parent, "option", true);
             } while (skip(",", true));
             skip("]");
         }
@@ -704,7 +713,6 @@ function parse(source, root, options) {
             /* istanbul ignore else */
             if (token === "option") {
                 parseOption(method, token);
-                skip(";");
             } else
                 throw illegal(token);
 
@@ -781,7 +789,6 @@ function parse(source, root, options) {
             case "option":
 
                 parseOption(ptr, token);
-                skip(";");
                 break;
 
             default:
diff --git a/node_modules/protobufjs/src/tokenize.js b/node_modules/protobufjs/src/tokenize.js
index b55b292..f6cba4b 100644
--- a/node_modules/protobufjs/src/tokenize.js
+++ b/node_modules/protobufjs/src/tokenize.js
@@ -104,7 +104,7 @@ function tokenize(source, alternateCommentMode) {
         length = source.length,
         line = 1,
         commentType = null,
-        commentText = null,
+        comments = [],
         commentLine = 0,
         commentLineEmpty = false,
         commentIsLeading = false;
@@ -186,9 +186,15 @@ function tokenize(source, alternateCommentMode) {
             lines[i] = lines[i]
                 .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                 .trim();
-        commentText = lines
+        comments.push({
+          line,
+          isLeading,
+          commentType,
+          commentLineEmpty,
+          txt: lines
             .join("\n")
-            .trim();
+            .trim()
+        });
     }
 
     function isDoubleSlashCommentLine(startOffset) {
@@ -198,7 +204,7 @@ function tokenize(source, alternateCommentMode) {
         var lineText = source.substring(startOffset, endOffset);
         // look for 1 or 2 slashes since startOffset would already point past
         // the first slash that started the comment.
-        var isComment = /^\s*\/{1,2}/.test(lineText);
+        var isComment = /^\s*\/{1,2}[^*]/.test(lineText);
         return isComment;
     }
 
@@ -211,6 +217,15 @@ function tokenize(source, alternateCommentMode) {
         return endOffset;
     }
 
+    function findStartOfLine(cursor) {
+      // find start of cursor's line
+      var startOffset = cursor;
+      while (startOffset > 0 && charAt(startOffset) !== "\n") {
+        startOffset--;
+      }
+      return ++startOffset;
+    }
+
     /**
      * Obtains the next token.
      * @returns {string|null} Next token or `null` on eof
@@ -226,6 +241,7 @@ function tokenize(source, alternateCommentMode) {
             curr,
             start,
             isDoc,
+            isPureComment = true,
             isLeadingComment = offset === 0;
         do {
             if (offset === length)
@@ -267,8 +283,10 @@ function tokenize(source, alternateCommentMode) {
                         if (isDoubleSlashCommentLine(offset)) {
                             isDoc = true;
                             do {
+                                var lineStart = findStartOfLine(offset);
+                                isPureComment = isDoubleSlashCommentLine(lineStart);
                                 offset = findEndOfLine(offset);
-                                if (offset === length) {
+                                if (offset === length || !isPureComment) {
                                     break;
                                 }
                                 offset++;
@@ -374,17 +392,20 @@ function tokenize(source, alternateCommentMode) {
      */
     function cmnt(trailingLine) {
         var ret = null;
+        var cmt = null;
         if (trailingLine === undefined) {
-            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
-                ret = commentIsLeading ? commentText : null;
+            cmt = comments.find(x => x.line === line - 1);
+            if (cmt && (alternateCommentMode || cmt.commentType === "*" || cmt.commentLineEmpty)) {
+                ret = commentIsLeading ? cmt.txt : null;
             }
         } else {
             /* istanbul ignore else */
             if (commentLine < trailingLine) {
                 peek();
             }
-            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
-                ret = commentIsLeading ? null : commentText;
+            cmt = comments.find(x => x.line === trailingLine);
+            if (cmt && !cmt.commentLineEmpty && (alternateCommentMode || cmt.commentType === "/")) {
+                  ret = cmt.isLeading ? null : cmt.txt;
             }
         }
         return ret;
diff --git a/node_modules/protobufjs/src/type.js b/node_modules/protobufjs/src/type.js
index 2e7bda4..99dd9b3 100644
--- a/node_modules/protobufjs/src/type.js
+++ b/node_modules/protobufjs/src/type.js
@@ -532,10 +532,11 @@ Type.prototype.verify = function verify_setup(message) {
 /**
  * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
  * @param {Object.<string,*>} object Plain object to convert
+ * @param {IConversionOptions} [options] Conversion options
  * @returns {Message<{}>} Message instance
  */
-Type.prototype.fromObject = function fromObject(object) {
-    return this.setup().fromObject(object);
+Type.prototype.fromObject = function fromObject(object, options) {
+    return this.setup().fromObject(object, options);
 };
 
 /**
diff --git a/node_modules/protobufjs/src/wrappers.js b/node_modules/protobufjs/src/wrappers.js
index 097b8ff..4bec9ee 100644
--- a/node_modules/protobufjs/src/wrappers.js
+++ b/node_modules/protobufjs/src/wrappers.js
@@ -14,6 +14,7 @@ var Message = require("./message");
  * @typedef WrapperFromObjectConverter
  * @type {function}
  * @param {Object.<string,*>} object Plain object
+ * @param {IConversionOptions} [options] Conversion options
  * @returns {Message<{}>} Message instance
  * @this Type
  */
@@ -38,7 +39,7 @@ var Message = require("./message");
 // Custom wrapper for Any
 wrappers[".google.protobuf.Any"] = {
 
-    fromObject: function(object) {
+    fromObject: function(object, options) {
 
         // unwrap value type if mapped
         if (object && object["@type"]) {
@@ -56,7 +57,7 @@ wrappers[".google.protobuf.Any"] = {
                 }
                 return this.create({
                     type_url: type_url,
-                    value: type.encode(type.fromObject(object)).finish()
+                    value: type.encode(type.fromObject(object, options)).finish()
                 });
             }
         }
