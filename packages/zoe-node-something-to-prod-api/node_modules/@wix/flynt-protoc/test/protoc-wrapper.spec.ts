import path from 'path';
import tmp from 'tmp';
import fs from 'fs';
import {getProtoFiles, protoc} from '../lib/protoc';
import {getProtocExec} from '../lib/protoc';

describe('protoc', () => {

  const folderPath = (name: string) => path.join(__dirname, `protos/${name}`);

  const callProtoc = async (testFolder: string, includeFolders?: string[], opts?: Record<string, unknown>) => {
    const mainProtoFolder = folderPath(testFolder);
    includeFolders = [mainProtoFolder].concat(includeFolders || []).concat('./test/std-include');
    return await protoc({
      protoFiles: await getProtoFiles(mainProtoFolder),
      includeFolders,
      ...opts
    });
  };

  describe('validations', () => {

    it('should validate that the passed includeFolders is an array', async () => {
      await expect(protoc({protoFiles: ['simple-good'], includeFolders: 'foo' as any})).rejects.toThrow(/includeFolders .* array/);
    });
  });

  it('should pass validation for simple folder with proto files', async () => {
    await expect(callProtoc('simple-good')).resolves.not.toThrow();
  });

  it('should pass validation for simple folder with include files', async () => {
    await expect(callProtoc('include-good', ['./test/include'])).resolves.not.toThrow();
  });

  it.skip('should output descriptor files in json format', async () => {
    const {name: tmpPath} = tmp.fileSync({postfix: '.json'});
    await expect(callProtoc('simple-good', undefined, {
      outputFile: tmpPath,
      cliOptions: ['--include_imports', '--include_source_info']
    })).resolves.not.toThrow();

    const fileContent = fs.readFileSync(tmpPath);
    const json = JSON.parse(fileContent.toString());

    expect(json.file).toBeInstanceOf(Array);
  });

  it('should fail validation for simple folder with invalid proto file', () => {
    return expect(callProtoc('simple-bad')).rejects.toThrow(/Boo/);
  });

  it('should allow passing custom cli options', async () => {
    return expect(callProtoc('simple-good', undefined, {cliOptions: ['-$', 'param']})).rejects.toThrow(/Unknown.*flag/);
  });

  describe('set exec via env var', () => {
    beforeEach(() => {
      process.env.PROTOC = 'invalid-exe-name';
    });

    afterEach(() => {
      delete process.env.PROTOC;
    });

    it('should allow passing custom protoc executable', async () => {
      return expect(callProtoc('simple-good', undefined)).rejects.toThrow(/spawn.*invalid-exe-name/);
    });
  });

  it.skip('should fail if proto import conflict appears', async () => {
    return expect(callProtoc('include-conflict', [
      './test/include-1',
    ])).rejects.toThrow(/exists in multiple locations/);
  });


  describe('unsupported os/architecture', () => {
    let platform: string;

    beforeAll(() => {
      platform = process.platform;
    });

    afterAll(() => {
      updateProcessKey('platform', platform);
    });

    it('should fail meaningfully for unsupported platform/architecture', async () => {
      updateProcessKey('platform', 'MS-DOS');
      expect(() => getProtocExec()).toThrow(/unsupported.*DOS/);
    });

    function updateProcessKey(key: string, value: string) {
      Object.defineProperty(process, key, {
        value
      });
    }
  });
});
