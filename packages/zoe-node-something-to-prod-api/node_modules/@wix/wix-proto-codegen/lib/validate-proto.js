const visitor = require('./proto-ast-traverse'),
  {isValidPrimitiveType, isValidEnumType, getWixOptionsWithTypes} = require('./javascript/type-validator'),
  {findFieldIgnoreCasing} = require('./javascript/hacks'),
  {ValidationError} = require('./validation-error'),
  {util} = require('@wix/wix-proto-runtime-toolkit'),
  domainEvents = require('./validate-domain-events'),
  BigNumber = require('bignumber.js'),
  {validateMethod: validateGoogleHttpOptions} = require('./validate-http-options'),
  {validateOverlaps} = require('./validate-overlaps'),
  wixHttp = require('./validate-wix-http-options');

function validateProto(root, opts) {
  const paths = [];
  const validations = getWixValidations(root);

  visitor(root).visit({
    afterMethod: method => {
      validateMethodName(method);
      if (shouldValidateNode(method, opts, root)) {
        validateOption(method, validations, root);
        validateGoogleHttpOptions(method, paths);
        domainEvents.validateMethod(method);
      }
    },
    afterField: field => {
      if (shouldValidateNode(field, opts, root)) {
        validateOption(field, validations, root);
        wixHttp.validateField(field, root);
      }
    },
    afterType: type => {
      if (shouldValidateNode(type, opts, root)) {
        domainEvents.validateMessage(type);
        wixHttp.validateMessage(type);
      }
    }
  });

  validateOverlaps(paths);
}

function getWixValidations(root) {
  const wixApiNamespace = root.lookup('wix.api');
  return wixApiNamespace ? wixApiNamespace.nested : {};
}

function validateMethodName(method) {
  if (method.name === method.requestType || method.name === method.responseType) {
    throw new ValidationError(`name collision detected: method ${util.fqn(method.parent)}#${method.name} has message of the same name.`, method);
  }
}

function throwInvalidRequiredPathException(node, path, message) {
  throwInvalidOptionException(node, `value "${path}" provided for the option "required" ${message}`);
}

function isRequiredApplicable(fieldNode) {
  const hasDefaultValue = fieldNode.defaultValue !== null && fieldNode.defaultValue !== undefined;
  const isComplexType = fieldNode.type && fieldNode.resolvedType && fieldNode.resolvedType.constructor.name !== 'Enum';
  const isStringType = fieldNode.type === 'string';
  const isArray = fieldNode.repeated;
  const isMap = fieldNode.map;

  return !hasDefaultValue || isStringType || isComplexType || isArray || isMap;
}

function validateRequiredPath(node, root, path) {
  const segments = path.split('.');
  if (segments.length < 2) {
    throwInvalidRequiredPathException(node, path, 'is not a valid field path');
  }
  const type = segments[0];
  const requestType = node.requestType.split('.').pop();
  if (requestType !== type) {
    throwInvalidRequiredPathException(node, path, `starts with invalid type ${type}, expected ${node.requestType}`);
  }
  let typeNode = node.resolvedRequestType;
  let fieldNode;
  const fields = segments.slice(1);
  for (let field of fields) {
    fieldNode = findFieldIgnoreCasing(typeNode.oneofs, field) || findFieldIgnoreCasing(typeNode.fields, field);
    if (!fieldNode) {
      throwInvalidRequiredPathException(node, path, `refers to invalid field ${typeNode.name}.${field}`);
    }
    if (fieldNode.constructor.name !== 'OneOf') {
      typeNode = fieldNode.resolvedType;
    }
  }

  if (!isRequiredApplicable(fieldNode)) {
    throwInvalidRequiredPathException(node, path, `refers to a property of a primitive type having default value (type "${fieldNode.type}" defaults to "${fieldNode.defaultValue}")`);
  }
}

function withFullTypeNames(types) {
  return types.concat(types.filter(t => t.includes('.') && !t.startsWith('.')).map(t => `.${t}`));
}

function validOnTypes(validation, types) {
  const typesSet = new Set(withFullTypeNames(types));
  return {
    run(options, node) {
      if (!typesSet.has(node.type)) {
        throwInvalidOptionException(node, `"wix.api.${validation}" is not valid for a field of type ${node.type}`);
      }
    }
  };
}

function validOnString(validation) {
  return validOnTypes(validation, ['string', 'google.protobuf.StringValue']);
}

function validOnNumeric(validation) {
  return validOnTypes(validation, [
    'double',
    'float',
    'int32',
    'int64',
    'uint32',
    'uint64',
    'sint32',
    'sint64',
    'fixed32',
    'fixed64',
    'sfixed32',
    'sfixed64',
    'google.protobuf.DoubleValue',
    'google.protobuf.FloatValue',
    'google.protobuf.Int64Value',
    'google.protobuf.UInt64Value',
    'google.protobuf.Int32Value',
    'google.protobuf.UInt32Value',
  ]);
}

function validOnRepeated(validation) {
  return {
    run(option, node) {
      if (!node.repeated === true) {
        throwInvalidOptionException(node, `"wix.api.${validation}" is not valid for non-repeated field`);
      }
    }
  };
}

const OPTION_VALIDATIONS = {
  required: {
    run(option, node, root) {
      validateRequiredPath(node, root, option.value);
    }
  },
  permission: {
    run(option, node) {

      if (option.path.join('.') === 'name') {
        if (option.value === '') {
          throwInvalidPermissionOptionError('"name" must not be empty', node);
        }

        // TODO: Enable once WixEmployee BO are migrated to this format
        // Details: https://github.com/wix-platform/wix-node-platform/issues/4158
        // if (option.value.split('.').length !== 2) {
        //   throwInvalidPermissionOptionError('"name" must be in form "SCOPE.ACTION"', node);
        // }
      }
    }
  },
  decimalValue: {
    run(option, node) {
      validOnString('decimalValue').run(option, node);
      const name = option.path.join('.');
      if (['lt', 'lte', 'gt', 'gte'].includes(name)) {
        if (isNaN(new BigNumber(option.value))) {
          throwInvalidDecimalValueOption(node, name, option.value);
        }
      }
    }
  },
  format: validOnString('format'),
  minLength: validOnString('minLength'),
  maxLength: validOnString('maxLength'),
  min: validOnNumeric('min'),
  max: validOnNumeric('max'),
  minSize: validOnRepeated('minSize'),
  maxSize: validOnRepeated('maxSize'),
};

function throwInvalidDecimalValueOption(node, name, value) {
  throwInvalidOptionException(node, `value "${value}" provided for the option "${name}" must be a string representing a decimal number`);
}

function throwInvalidPermissionOptionError(details, node) {
  throw new ValidationError(`invalid "wix.api.permission" option detected in ${node.constructor.name.toLowerCase()} "${node.name}": ${details}`, node);
}

function shouldValidateNode(node, opts, root) {
  const skipList = opts.skipOptionsValidation;
  if (!skipList) {
    return true;
  }
  //if skipList is an empty array then it means to skip all modules
  if (skipList.length > 0) {
    const module = root.moduleForFile(node.filename);
    const moduleName = module && module.name;
    return !skipList.includes(moduleName);
  }
}

function validateOption(node, validations, root) {
  const options = getWixOptionsWithTypes(node);
  options.forEach(option => {
    if (!validations.hasOwnProperty(option.name)) {
      throwInvalidOptionException(node, `'${option.name}' is not a valid option.`);
    }

    const validationType = validations[option.name].type;
    validateTypeOrThrow(node, option, validationType, validations);

    executeSpecificValidation(option, node, root);
  });

  if (options.length > 0) {
    verifyNoMissingFields(options, validations, node);
  }
}

function executeSpecificValidation(option, node, root) {
  try {
    const optionValidation = OPTION_VALIDATIONS[option.name];
    if (optionValidation) {
      optionValidation.run(option, node, root);
    }
  } catch (err) {
    if (!err.node) {
      err.node = node;
    }
    throw err;
  }
}

function verifyNoMissingFields(options, validations, node) {

  function verifyField(type, values, optionName, path = []) {
    if (isComplexType(type)) {
      const isMandatory = field => field.required && field.defaultValue === null;
      const isNotSet = fieldName => !values.hasOwnProperty(fieldName);
      const isMissing = ([name, field]) => isMandatory(field) && isNotSet(name);

      const missingField = Object.entries(type.fields).find(isMissing);

      if (missingField) {
        throwInvalidOptionException(node, `field "${path.concat(missingField[0]).join('.')}" is missing (option "${optionName}")`);
      }

      Object.entries(values).forEach(([fieldName, subValues]) =>
        verifyField(
          findFieldIgnoreCasing(type.fields, fieldName).resolvedType,
          subValues,
          optionName,
          path.concat(fieldName)));
    }
  }


  // Create JSON object from provided (user defined in the proto) options
  const materializedOptions = {};
  options.forEach(opt => {
    const isLastField = idx => idx === opt.path.length;
    materializedOptions[opt.name] = materializedOptions[opt.name] || {};
    opt.path.reduce((acc, field, idx) => acc[field] = isLastField(idx) ? opt.value : acc[field] || {}, materializedOptions[opt.name]);
  });

  // Go over the provided options and check each one vs. options definitions (options type)
  Object.entries(materializedOptions).forEach(([optionName, values]) => {
    validations[optionName].resolve();
    verifyField(validations[optionName].resolvedType, values, optionName);
  });
}

function throwInvalidOptionException(node, message) {
  const nodeType = node.constructor.name.toLowerCase();
  throw new ValidationError(`invalid option detected in ${nodeType} "${node.name}": ${message}`, node);
}

function constructPartialPath(option, path) {
  return `.${option.path.slice(0, option.path.length - path.length).join('.')}`;
}

function typeErrorMessage(isComplex, option, path, validationType) {
  if (isComplex) {
    //object instead of primitive or enum value
    const partialPath = constructPartialPath(option, path);
    return `property "${path[0]}" provided for the option "${option.name}${partialPath}" is not of the expected type "${validationType}"`;
  } else {
    //incorrect primitive type or enum value
    const fullPath = option.path.length > 0 ? `.${option.path.join('.')}` : '';
    return `value "${option.value}" provided for the option "${option.name}${fullPath}" is not of the expected type "${validationType}"`;
  }
}

function validateTypeOrThrow(node, option, validationType, validations, path = option.path) {
  if (path.length === 0 && typeof option.value === 'object' && Object.keys(option.value).length === 0) {
    return;
  }
  const resolvedType = typeof validationType === 'string' ? validations[validationType] : validationType;
  const isComplex = path.length > 0;
  const isPrimitive = !isComplex && !resolvedType;
  const maybeEnum = !isComplex && !!resolvedType;

  const validComplexType = isComplex && isValidComplexOption(node, option, resolvedType, validations, path);
  const validPrimitive = isPrimitive && isValidPrimitiveType(option.value, validationType);
  const validEnum = maybeEnum && isValidEnumType(option.value, resolvedType);

  const typeIsValid = validPrimitive || validEnum || validComplexType;
  if (!typeIsValid) {
    throwInvalidOptionException(node, typeErrorMessage(isComplex, option, path, validationType));
  }
}

function isComplexType(resolvedType) {
  return resolvedType && resolvedType.constructor.name === 'Type';
}

function isValidComplexOption(node, option, resolvedType, validations, path) {
  if (!isComplexType(resolvedType)) {
    return false;
  }

  const field = findFieldIgnoreCasing(resolvedType.fields, path[0]);
  const fieldType = field && (field.resolve().resolvedType || field.type);

  if (!fieldType) {
    const partialPath = option.path.length !== path.length ? constructPartialPath(option, path) : '';
    throwInvalidOptionException(node, `unexpected property "${path[0]}" provided for the option "${option.name}${partialPath}"`);
  }

  const childrenPath = path.slice(1);
  validateTypeOrThrow(node, option, fieldType, validations, childrenPath);

  return true;
}

module.exports = {validateProto, validateOption, getWixValidations, withFullTypeNames};
