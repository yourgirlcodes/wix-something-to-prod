const protobufjs = require('@wix/wnp-protobufjs'),
  {getCamelCaseImpl} = require('@wix/wnp-rpc-common'),
  path = require('path'),
  Promise = require('bluebird'),
  bundled = require('./bundled');

class Root extends protobufjs.Root {

  constructor(module, {strictMode = false, alternateCommentMode = false, preferTrailingComment = false, stdCase} = {}) {
    super();
    this._module = module;
    this.strictMode = strictMode;
    this.alternateCommentMode = alternateCommentMode;
    this.preferTrailingComment = preferTrailingComment;
    this.camelCase = getCamelCaseImpl(stdCase).fieldCamelCase;
  }

  async init() {
    this._initReverseLookup();
    await this._validatePerFileResolution();
    await this._loadFiles();
    this._resolveAll();
  }

  _initReverseLookup() {
    this._reverseLookup = new Map();
    const self = this;

    function rec(module) {
      const files = module.protoFiles();
      files.forEach(file => self._reverseLookup.set(file, module));
      module.children.forEach(rec);
    }

    rec(this._module);
  }

  async _validateFileIsResolvable(file) {
    const root = this._copy();
    try {
      await root.load(file);
      root._resolveAll();
    } catch (err) {
      this._enrichErrorAndRethrow(err, {file});
    }
  }

  async _validatePerFileResolution() {
    const files = this._module.protoFiles();
    await Promise.each(files, file => this._validateFileIsResolvable(file));
  }

  _copy() {
    const copy = new Root(this._module);
    copy._reverseLookup = this._reverseLookup;
    return copy;
  }

  _resolveAll(node = this) {
    if (node.filename && node.resolveAll) {
      try {
        node.resolveAll();
      } catch (err) {
        const file = node.filename;
        this._enrichErrorAndRethrow(err, {file});
      }
    } else {
      if (node.nestedArray) {
        node.nestedArray.forEach(n => this._resolveAll(n));
      }
    }
  }

  moduleForFile(file) {
    return this._reverseLookup.get(file);
  }

  async _loadFiles() {
    const files = this._module.protoFiles();
    this._module.children.forEach(child => files.push(...child.protoFiles()));
    files.sort();
    files.forEach(file => this.loadSync(file, {
      alternateCommentMode: this.alternateCommentMode,
      preferTrailingComment: this.preferTrailingComment,
      camelCase: this.camelCase,
    }));
  }

  resolvePath(origin, target) {
    return this._resolveAbsolute(target) ||
      this._resolveFromCurrent(origin, target) ||
      this._resolveFromChild(origin, target) ||
      this._resolveFromSibling(origin, target) || // this is a workaround for https://jira.wixpress.com/browse/HAL-443
      this._resolveFromBundled(target) ||
      this._resolutionFailed(origin, target);
  }

  _resolutionFailed(origin, target) {
    const originModule = origin && this.moduleForFile(origin);
    if (originModule) {
      this._enrichErrorAndRethrow(new Error(`cannot resolve import ${target}`), {file: origin, module: originModule});
    }
  }

  _resolveFromSibling(origin, target) {
    const originModule = origin && this.moduleForFile(origin);
    const parent = originModule && originModule.parent;
    return parent && parent.children
      .filter(child => child !== originModule)
      .map(child => child.toAbsolute(target))
      .find(path => path);
  }

  _resolveFromCurrent(origin, target) {
    const originModule = origin && this.moduleForFile(origin);
    return originModule && originModule.toAbsolute(target);
  }

  _resolveFromChild(origin, target) {
    const originModule = origin && this.moduleForFile(origin);
    return originModule && originModule.children.map(m => m.toAbsolute(target)).find(path => path);
  }

  _resolveAbsolute(target) {
    if (path.isAbsolute(target)) {
      return target;
    }
  }

  _resolveFromBundled(target) {
    return bundled.resolve(target);
  }

  _enrichErrorAndRethrow(err, {file, module = this.moduleForFile(file)}) {
    Object.assign(err, {file: err.file || file, module: err.module || module.name});
    throw err;
  }
}

module.exports = {Root};
