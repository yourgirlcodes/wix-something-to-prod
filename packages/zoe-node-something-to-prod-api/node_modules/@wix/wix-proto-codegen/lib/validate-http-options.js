const {throwError} = require('./validation-error');
const {parsePathTemplate} = require('./path-template');
const {findFieldIgnoreCasing} = require('./javascript/hacks');
const {util} = require('@wix/wix-proto-runtime-toolkit');
const log = require('@wix/wix-log')('wix-proto-codegen');
const options = util.options('google.api.http');

const VALID_HTTP_VERBS = new Set(['GET', 'POST', 'PATCH', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', '*']);
const UNSUPPORTED_FIELDS = ['selector', 'response_body'];
const INVALID_INPUT_TYPES = new Set([
  'google.protobuf.DoubleValue',
  'google.protobuf.FloatValue',
  'google.protobuf.Int64Value',
  'google.protobuf.UInt64Value',
  'google.protobuf.Int32Value',
  'google.protobuf.UInt32Value',
  'google.protobuf.BoolValue',
  'google.protobuf.StringValue',
  'google.protobuf.BytesValue',
]);

// https://github.com/wix-private/server-infra/blob/master/framework/grpc/generator/src/main/scala/com/wixpress/grpc/HttpOptionValidator.scala#L159
const IGNORED_INPUT_TYPES = new Set([
  'com.wixpress.rest.RawHttpRequest'
]);

function validateInputType(method) {
  const anyHttpOption = options(method).find().first;
  if (INVALID_INPUT_TYPES.has(method.requestType) && anyHttpOption) {
    throwError(method, `request input type cannot be a primitive. Found: ${method.requestType}`);
  }
}

function validateUnsupportedFields(method) {
  UNSUPPORTED_FIELDS.forEach(field => {
    const value = options(method).find(field).first;
    if (value !== undefined) {
      throwError(method, `${field} is not supported. Found value: ${value}. It is a noop, please remove it.`);
    }
  });
  const body = options(method).find('body').first;
  if (body !== undefined) {
    const msg = `body is not supported. Found value: ${body}. It is a noop, please remove it.`;
    if (body === '*') {
      log.error(msg);
    } else {
      throwError(method, msg);
    }
  }
}

function validateCustom(method, paths) {
  const kind = options(method).find('custom.kind').first;
  const path = options(method).find('custom.path').first;

  if (kind !== undefined && !VALID_HTTP_VERBS.has(kind.toUpperCase())) {
    throwError(method, `'${kind}' is not a valid http verb`);
  }

  if (kind !== undefined) {
    validatePath(path, method);
    paths.push({method, verb: kind.toLowerCase(), path});
  }
}

function isIgnored(type) {
  return IGNORED_INPUT_TYPES.has(util.fqn(type));
}

function validatePath(path, method) {
  let vars;
  try {
    vars = parsePathTemplate(path);
  } catch (err) {
    throwError(method, `illegal path '${path}' (${err.message})`);
  }

  const type = method.resolve().resolvedRequestType;
  if (!isIgnored(type)) {
    const missing = vars.filter(v => !findField(type, v));
    if (missing.length > 0) {
      throwError(method, `fields [${missing.join(',')}] are missing from message type ${util.fqn(type)}`);
    }
  }
}

function validateUri(method, paths, fragment) {
  Array.from(VALID_HTTP_VERBS).forEach(v => {
    const verb = v.toLowerCase();
    const path = options(method).find(`${fragment ? fragment + '.' : ''}${verb}`).first;
    if (path !== undefined) {
      validatePath(path, method);
      paths.push({method, verb, path});
    }
  });
}

function validateSingleVerb(method) {
  const res = Array.from(VALID_HTTP_VERBS)
    .map(verb => options(method).find(verb.toLowerCase()))
    .flat();

  if (res.length > 1) {
    throwError(method, `only one verb is allowed. found ${res.length} verbs`);
  }
}

function validateAdditionalBindings(method, paths) {
  const nested = options(method).find(/additional_bindings\.additional_bindings.*/).first;
  if (nested !== undefined) {
    throwError(method, 'additional_bindings can\'t be nested');
  }
  validateUri(method, paths, 'additional_bindings');
}

function validateMethod(method, paths = []) {
  validateCustom(method, paths);
  validateUnsupportedFields(method);
  validateAdditionalBindings(method, paths);
  validateInputType(method);
  validateUri(method, paths);
  validateSingleVerb(method);
}

function findField(type, path) {
  function findRec(t, p) {
    if (t) {
      const [f, ...rest] = p;
      if (f) {
        const field = findFieldIgnoreCasing(t.fields, f);
        if (rest.length > 0) {
          return findRec(field && field.resolvedType, rest);
        } else {
          return field;
        }
      }
    }
  }

  return findRec(type, path.split('.'));
}

module.exports = {validateMethod, findField};
