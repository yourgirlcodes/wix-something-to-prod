const e = require('estree-builder'),
  _ = require('lodash'),
  {Enum, Type} = require('@wix/wnp-protobufjs'),
  {fixupName} = require('./hacks'),
  {id, fqn, EMPTY_OBJ, and, or, firstDefinedEnumLiteral} = require('./util'),
  {DEFAULTS} = require('./defaults'),
  {util: runtimeUtil} = require('@wix/wix-proto-runtime-toolkit');

const PRIMITIVE_FIELD = {
  fromGRPC: _.identity,
  toGRPC: _.identity
};

const HELPER_IDENTIFIER = 'helper';

const WRAPPER_TYPE = {
  fromGRPC: () => {
    return e.fn([id('grpc'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('grpc'), id('grpc', 'value')))]);
  },

  toGRPC: () => {
    return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(
      e('?',
        e('==', id('obj'), e.null()),
        id('obj'),
        e('object', {value: id('obj')})))]);
  }
};

function callHelper(name, arg) {
  return e.call(id(HELPER_IDENTIFIER, 'grpc', name), [arg]);
}

const LONG = {
  fromGRPC: (identifier, {stringLongs} = {}) => {
    return e.ternary(
      or(
        e('===', e.typeof(id(identifier)), e.str('number')),
        and(
          e('===', e.typeof(id(identifier)), e.str('string')),
          e.call(id('/^[-+]?\\d+$/.test'), [identifier])
        )
      ),
      stringLongs ?
        e.call(e('.', identifier, id('toString')), []) :
        e.call(id('Long.fromValue'), [identifier]),
      id(identifier)
    );
  },

  toGRPC: identifier => {
    return e.call(e('.', identifier, id('toString')), []);
  }
};

const ULONG = {
  fromGRPC: (identifier, {stringLongs} = {}) => {
    return e.ternary(
      or(
        e('===', e.typeof(id(identifier)), e.str('number')),
        and(
          e('===', e.typeof(id(identifier)), e.str('string')),
          e.call(id('/^[-+]?\\d+$/.test'), [identifier])
        )
      ),
      stringLongs ?
        e.call(e('.', identifier, id('toString')), []) :
        e.call(id('Long.fromValue'), [identifier, e.str('true')]),
      id(identifier)
    );
  },
  toGRPC: LONG.toGRPC
};

function customTypeWithHelper(fromGRPCHelper, toGRPCHelper) {
  return {
    fromGRPC: () => {
      return e.fn([id('grpc'), id(HELPER_IDENTIFIER)], [e.return(callHelper(fromGRPCHelper, id('grpc')))]);
    },

    toGRPC: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(callHelper(toGRPCHelper, id('obj')))]);
    }
  };
}

const CUSTOM_64_BIT_NUMBER_FIELD_TYPES = {
  'uint64': ULONG,
  'int64': LONG,
  'sint64': LONG,
  'fixed64': LONG,
  'sfixed64': LONG
};

const LONG_WRAPPER = {
  fromGRPC: (identifier, opts) => {
    return e.fn([id('grpc'), id(HELPER_IDENTIFIER)], [e.return(
      and(id('grpc'), LONG.fromGRPC(id('grpc.value'), opts))
    )]);
  },

  toGRPC: () => {
    return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(
      e('?',
        e('==', id('obj'), e.null()),
        id('obj'),
        e('object', {value: e.call(e('.', id('obj'), id('toString')), [])})))]);
  }
};

const ULONG_WRAPPER = {
  fromGRPC: (identifier, opts) => {
    return e.fn([id('grpc'), id(HELPER_IDENTIFIER)], [e.return(
      and(id('grpc'), ULONG.fromGRPC(id('grpc.value'), opts))
    )]);
  },

  toGRPC: LONG_WRAPPER.toGRPC
};

const CUSTOM_TYPES = {
  'google.protobuf.Struct': customTypeWithHelper('structFromGRPC', 'structToGRPC'),
  'google.protobuf.Value': customTypeWithHelper('valueFromGRPC', 'valueToGRPC'),
  'google.protobuf.ListValue': customTypeWithHelper('listValueFromGRPC', 'listValueToGRPC'),
  'google.protobuf.Timestamp': customTypeWithHelper('timestampFromGRPC', 'timestampToGRPC'),
  'google.protobuf.FieldMask': customTypeWithHelper('fieldmaskFromGRPC', 'fieldmaskToGRPC'),
  'google.protobuf.FloatValue': WRAPPER_TYPE,
  'google.protobuf.DoubleValue': WRAPPER_TYPE,
  'google.protobuf.StringValue': WRAPPER_TYPE,
  'google.protobuf.Int32Value': WRAPPER_TYPE,
  'google.protobuf.UInt32Value': WRAPPER_TYPE,
  'google.protobuf.BytesValue': WRAPPER_TYPE,
  'google.protobuf.BoolValue': WRAPPER_TYPE,
  'google.protobuf.Int64Value': LONG_WRAPPER,
  'google.protobuf.UInt64Value': ULONG_WRAPPER
};

function forType(field) {
  const {resolvedType} = field.resolve();
  if (resolvedType && resolvedType.constructor && resolvedType.constructor.name === Type.name) {
    return {
      fromGRPC: identifier => {
        return e.call(e('.', fqn(resolvedType), id('fromGRPC')), [identifier, id(HELPER_IDENTIFIER)]);
      },

      toGRPC: identifier => {
        return e.call(e('.', fqn(resolvedType), id('toGRPC')), [identifier, id(HELPER_IDENTIFIER)]);
      }
    };
  }
}

function forRepeatedField(field, opts) {
  const nested = forScalarField(field, opts);
  return {
    toGRPC: identifier => {
      return e.call(id(identifier, 'map'), [e.arrow([e.id('e')], [e.return(nested.toGRPC(e.id('e'), opts))])]);
    },

    fromGRPC: identifier => {
      return e.call(id(identifier, 'map'), [e.arrow([e.id('e')], [e.return(nested.fromGRPC(e.id('e'), opts))])]);
    }
  };
}

function forMapField(field, opts) {
  const nested = forScalarField(field, opts);
  return {
    toGRPC: identifier => {
      const entries = e.call(id('Object.entries'), [identifier]);
      return e.call(e('.', entries, e.id('reduce')), [e.arrow([e.id('acc'), e('arr-pattern', [e.id('k'), e.id('v')])], [
        e(';', e('=', e('get', e.id('acc'), e.id('k')), nested.toGRPC(e.id('v')))),
        e.return(e.id('acc'))
      ]), EMPTY_OBJ], []);
    },

    fromGRPC: identifier => {
      const entries = e.call(id('Object.entries'), [identifier]);
      return e.call(e('.', entries, e.id('reduce')), [e.arrow([e.id('acc'), e('arr-pattern', [e.id('k'), e.id('v')])], [
        e(';', e('=', e('get', e.id('acc'), e.id('k')), nested.fromGRPC(e.id('v'), opts))),
        e.return(e.id('acc'))
      ]), EMPTY_OBJ], []);
    }
  };
}

function forScalarField(field) {
  return CUSTOM_64_BIT_NUMBER_FIELD_TYPES[field.type] || forType(field) || PRIMITIVE_FIELD;
}

function forField(field, opts) {
  if (field.repeated === true) {
    return forRepeatedField(field, opts);
  } else if (field.map === true) {
    return forMapField(field, opts);
  } else {
    return forScalarField(field, opts);
  }
}

function defaultFor(target, field, {stringEnums = false, stringLongs = false} = {}) {
  const {resolvedType} = field.resolve();

  if (field.map === true) {
    return e(';', e.delete(target));
  } else if (field.repeated === true) {
    return e(';', e('=', target, e.array([])));
  } else if (DEFAULTS[field.type] && !field.partOf) {
    return e(';', e('=', target, DEFAULTS[field.type](stringLongs)));
  } else if (resolvedType && resolvedType.constructor && resolvedType.constructor.name === Enum.name && !field.partOf) {
    return e(';', e('=', target, firstDefinedEnumLiteral(resolvedType, {stringEnums})));
  } else {
    return e(';', e.delete(target));
  }
}

function notEmpty(id) {
  return e('!=', id, e.null());
}

function fromGRPC(type, opts) {
  const typeName = runtimeUtil.fqn(type);

  if (CUSTOM_TYPES[typeName]) {
    return CUSTOM_TYPES[typeName].fromGRPC(type, opts);
  } else {
    const init = e.const(id('result'), e.new(fqn(type), []));

    const assignments = _(type.fields).toPairs().map(([fieldName, field]) => {
      const {fromGRPC} = forField(field, opts);
      const target = id(`result['${fixupName(fieldName)}']`);

      return e.if(
        notEmpty(id(`grpc['${fixupName(field.name)}']`)),
        e.block([e(';', e('=', target, fromGRPC(id(`grpc['${fixupName(field.name)}']`), opts)))]),
        e.block([defaultFor(target, field, opts)]));
    }).value();

    const ifNullElse = e.if(
      e('==', id('grpc'), e.null()),
      e.block([e.return(e.null())]),
      e.block([init, ...assignments, e.return(id('result'))]));

    return e.fn([id('grpc'), id(HELPER_IDENTIFIER)], [ifNullElse]);
  }
}

function toGRPC(type, opts) {
  const typeName = runtimeUtil.fqn(type);

  if (CUSTOM_TYPES[typeName]) {
    return CUSTOM_TYPES[typeName].toGRPC(type);
  } else {
    const init = e.const(id('grpc'), EMPTY_OBJ);

    const assignments = _(type.fields).toPairs().map(([fieldName, field]) => {
      const {toGRPC} = forField(field, opts);

      const assignment = e('=', id(`grpc['${fixupName(fieldName)}']`), toGRPC(id(`obj['${fixupName(field.name)}']`), field));
      if (field.type === 'google.protobuf.Value') {
        return assignment;
      } else {
        return e.if(e('!=', id(`obj['${fixupName(field.name)}']`), e.null()), e.block([e(';', assignment)]));
      }
    }).value();

    const ifNullElse = e.if(
      e('==', id('obj'), e.null()),
      e.block([e.return(e.null())]),
      e.block([init, ...assignments, e.return(id('grpc'))]));

    return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [ifNullElse]);
  }
}

module.exports = {fromGRPC, toGRPC};
