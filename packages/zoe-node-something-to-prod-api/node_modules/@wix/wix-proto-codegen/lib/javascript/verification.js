const e = require('estree-builder'),
  {id, EMPTY_OBJ, BUILT_IN_IDENTIFIER, and, or} = require('./util'),
  {fixupName} = require('./hacks'),
  {util: runtimeUtil} = require('@wix/wix-proto-runtime-toolkit'),
  _ = require('lodash');

const returnErrors = e.return(e.id('errors'));

const msg = e.id('msg');
const root = e.id('$root');
const helper = e.id('helper');
const ONE_OF_MUTEXT = 'oneOfMutex';

const isStringIntegerRegex = /^[-+]?\d+$/;
const isNegativeStringIntegerRegex = /^-\d+$/;

const not = expr => e('!', expr);
const isInteger = expr => e.call(id(BUILT_IN_IDENTIFIER, 'Number.isInteger'), [expr]);
const notInteger = expr => not(isInteger(expr));
const isLong = expr => e.call(id('Long.isLong'), [expr]);
const isExprStringInteger = expr => e.call(id(`${isStringIntegerRegex}.test`), [expr]);
const isExprNegativeStringInteger = expr => e.call(id(`${isNegativeStringIntegerRegex}.test`), [expr]);
const isStringInteger = expr => and(typeOf(expr, 'string'), isExprStringInteger(expr));
const isNonNegativeStringInteger = expr => and(typeOf(expr, 'string'), not(isExprNegativeStringInteger(expr)));
const isBase64Number = (expr, stringLongs) => stringLongs ? isStringInteger(expr) : isLong(expr);
const notBase64Number = (expr, stringLongs) => not(isBase64Number(expr, stringLongs));
const isArray = expr => e.call(id(BUILT_IN_IDENTIFIER, 'Array.isArray'), [expr]);
const notArray = expr => not(e.call(id(BUILT_IN_IDENTIFIER, 'Array.isArray'), [expr]));
const notObject = expr => not(typeOf(expr, 'object'));
const typeOf = (expr, type) => e('===', e.typeof(expr), e.str(type));
const notTypeOf = (expr, type) => e('!==', e.typeof(expr), e.str(type));
const objectLength = expr => e('.', e.call(id('Object.keys'), [expr]), id('length'));

const FIELD_TYPE_VERIFICATIONS = {

  'bool': typeVerify('boolean'),

  'string': typeVerify('string'),

  'float': typeVerify('number'),

  'int32': (expr, errors) => {
    return e.if(
      notInteger(expr),
      error('integer expected', errors));
  },

  'int64': (expr, errors, {stringLongs}) => {
    const errorMessage = `${stringLongs ? 'string integer' : 'long'} or integer expected`;

    return e.if(
      and(notInteger(expr), notBase64Number(expr, stringLongs)),
      error(errorMessage, errors));
  },

  'uint32': (expr, errors) => {
    const isNegative = e('<', expr, e.number(0));
    return e.if(
      or(notInteger(expr), isNegative),
      error('non-negative integer expected', errors));
  },

  'uint64': (expr, errors, {stringLongs}) => {
    const isNonNegativeLong = e.call(id(e.call(id('Long.fromValue'), [expr]), 'greaterThanOrEqual'), [e.number(0)]);
    const isNonNegativeInteger = expr => and(isInteger(expr), e('>=', expr, e.number(0)));
    const isNonNegativeStringLong = or(isNonNegativeInteger(expr), isNonNegativeStringInteger(expr));
    const isNonNegative = stringLongs ? isNonNegativeStringLong : isNonNegativeLong;

    const errorMessage = `non-negative ${stringLongs ? 'string integer' : 'long'} or integer expected`;

    return e.if(
      not(and(or(isInteger(expr), isBase64Number(expr, stringLongs)), isNonNegative)),
      error(errorMessage, errors));
  },

  'bytes': (expr, errors) => {
    const notBuffer = e('!', e.call(id('Buffer.isBuffer'), [expr]));
    return e.if(
      notBuffer,
      error('buffer expected', errors));
  }
};

FIELD_TYPE_VERIFICATIONS['sint32'] = FIELD_TYPE_VERIFICATIONS['fixed32'] = FIELD_TYPE_VERIFICATIONS['sfixed32'] = FIELD_TYPE_VERIFICATIONS['int32'];
FIELD_TYPE_VERIFICATIONS['double'] = FIELD_TYPE_VERIFICATIONS['float'];
FIELD_TYPE_VERIFICATIONS['sint64'] = FIELD_TYPE_VERIFICATIONS['fixed64'] = FIELD_TYPE_VERIFICATIONS['sfixed64'] = FIELD_TYPE_VERIFICATIONS['int64'];

function verificationFor(typeName, opts) {
  return e.block([FIELD_TYPE_VERIFICATIONS[typeName](msg, id('errors'), opts), returnErrors]);
}

const CUSTOM_TYPES = {

  'google.protobuf.DoubleValue': () => verificationFor('double'),

  'google.protobuf.FloatValue': () => verificationFor('float'),

  'google.protobuf.Int64Value': (typedef, opts) => verificationFor('int64', opts),

  'google.protobuf.UInt64Value': (typedef, opts) => verificationFor('uint64', opts),

  'google.protobuf.Int32Value': () => verificationFor('int32'),

  'google.protobuf.UInt32Value': () => verificationFor('uint32'),

  'google.protobuf.BoolValue': () => verificationFor('bool'),

  'google.protobuf.StringValue': () => verificationFor('string'),

  'google.protobuf.BytesValue': () => verificationFor('bytes'),

  'google.protobuf.Timestamp': () => {
    const notInstanceOfDate = notTypeOf(e('.', id(msg), id('getUTCMilliseconds')), 'function');
    return e.block([
      e.if(
        and(notNull(msg), notInstanceOfDate),
        error('Date expected')),
      returnErrors
    ]);
  },

  'google.protobuf.ListValue': () => {
    return e.block([
      e.if(
        and(notNull(msg), notArray(msg)),
        error('array expected')),
      returnErrors
    ]);
  },

  'google.protobuf.Struct': () => {
    return e.block([
      e.if(
        and(notNull(msg), or(notObject(msg), isArray(msg))),
        error('object expected')),
      returnErrors
    ]);
  },

  'google.protobuf.FieldMask': () => {
    const iterate = e(';', e.call(id(msg, 'forEach'), [e.arrow([id('value'), id('index')], [
      typeVerificationOrThrow('string')(id('value'), e.call(id('errors.index'), [id('index')]))
    ])]));

    return e.block([
      e.if(
        and(notNull(msg), notArray(msg)),
        error('array expected'),
        e.block([iterate])
      )]);
  },

  'google.protobuf.Value': () => {
    return e.block([returnErrors]);
  }
};

function typeVerify(typeName, label = typeName) {
  return (expr, errors) => {
    return e.if(
      notTypeOf(expr, typeName),
      error(`${label} expected`, errors));
  };
}

function error(msg, errors = id('errors')) {
  return block(e.call(id(errors, 'error'), [e.str(msg)]));
}

function block(statement) {
  return e.block([e(';', statement)]);
}

function notNull(id) {
  return e('!=', id, e.null());
}

function isEmptyObject() {
  const isEmptyObj = e('===', objectLength(msg), e.number(0));
  return e.if(
    not(
      and(
        and(
          typeOf(msg, 'object'),
          notArray(msg)
        ),
        isEmptyObj)
    ),
    error('empty object expected'));
}

function delegate(typeName) {
  return (expr, errors) => {
    return e(';', e.call(id(root, typeName, 'verify'), [expr, helper, errors]));
  };
}

function typeVerificationOrThrow(typeName) {
  return FIELD_TYPE_VERIFICATIONS[typeName] || delegate(typeName);
}

function arrayFieldVerification({fieldErrors, typeName, expr}, opts) {
  const defineFieldErrors = e.const('fieldErrors', fieldErrors);

  const iterate = e(';', e.call(id(expr, 'forEach'), [e.arrow([id('value'), id('index')], [
    typeVerificationOrThrow(typeName)(id('value'), e.call(id('fieldErrors.index'), [id('index')]), opts)
  ])]));

  const verifyArray = e.if(
    notArray(expr),
    error('array expected', id('fieldErrors')),
    e.block([iterate]));

  return [defineFieldErrors, verifyArray];
}

function mapFieldVerification({fieldErrors, fieldDef, expr}, opts) {
  const [valueTypeName] = resolveType(fieldDef);
  const defineFieldErrors = e.const('fieldErrors', fieldErrors);

  let keyValidator, keyErrorMessage;

  if (fieldDef.keyType.match(/.*(32|64)$/)) {
    keyValidator = 'isInteger';
    keyErrorMessage = 'integer expected';
  } else if (fieldDef.keyType === 'bool') {
    keyValidator = 'isBoolean';
    keyErrorMessage = 'boolean expected';
  }

  let validation;
  if (keyValidator) {
    validation = e.if(
      e('!', e.call(id(`helper.verification.Map.Key.${keyValidator}`), [id('key')])),
      error(keyErrorMessage, e.call(id('keyErrors.field'), [e.str('key')])),
      typeVerificationOrThrow(valueTypeName)(e('get', expr, id('key')), e.call(id('keyErrors.field'), [e.str('value')]), opts));
  } else {
    validation = typeVerificationOrThrow(valueTypeName)(e('get', expr, id('key')), e.call(id('keyErrors.field'), [e.str('value')]));
  }

  const validateKeysAndValues = e('for-in', e.let(id('key')), expr, e.block([
    e.const('keyErrors', e.call(id('fieldErrors.index'), [id('key')])),
    validation
  ]));

  const ifObjValidateKeysAndValues = e.if(
    and(notNull(expr), or(notObject(expr), isArray(expr))),
    error('object expected', id('fieldErrors')),
    e.block([validateKeysAndValues]));

  return [defineFieldErrors, e(';', ifObjValidateKeysAndValues)];
}

function oneOfFieldVerification({fieldErrors, fieldDef, expr, typeName}, opts) {
  const set = e('=', e('get', id(ONE_OF_MUTEXT), e.str(fieldDef.partOf.name)), e.true());

  const mutexErrors = e.call(id(e.call(id(fieldErrors, 'up'), []), 'field'), [e.str(fieldDef.partOf.name)]);
  return [
    e.if(
      e('get', id(ONE_OF_MUTEXT), e.str(fieldDef.partOf.name)),
      error('multiple values', mutexErrors),
      e.block([set, typeVerificationOrThrow(typeName)(expr, fieldErrors, opts)]))];
}

function toFieldVerification([typeName, fieldDef], opts) {
  const expr = id(msg, fixupName(fieldDef.name));
  const verification = getVerificationByFieldType({typeName, fieldDef, expr}, opts);

  return e.if(
    notNull(expr),
    e.block(verification));
}

function getVerificationByFieldType({typeName, fieldDef, expr}, opts) {
  const fieldErrors = e.call(id('errors.field'), [e.str(fieldDef.name)]);

  if (fieldDef.repeated === true) {
    return arrayFieldVerification({fieldErrors, typeName, expr}, opts);
  } else if (fieldDef.map === true) {
    return mapFieldVerification({fieldErrors, fieldDef, expr}, opts);
  } else if (fieldDef.partOf) {
    return oneOfFieldVerification({fieldErrors, fieldDef, expr, typeName}, opts);
  } else {
    return [typeVerificationOrThrow(typeName)(expr, fieldErrors, opts)];
  }
}

function fieldWiseVerification(typeDef, opts) {
  let fieldsValidations = typeDef.fieldsArray.map(resolveType).map((fields) => toFieldVerification(fields, opts));

  if (fieldsValidations.length === 0) {
    fieldsValidations = [isEmptyObject()];
  } else if (typeDef.oneofs) {
    fieldsValidations.unshift(e.const(ONE_OF_MUTEXT, EMPTY_OBJ));
  }

  const ifObject = e.if(
    or(notTypeOf(msg, 'object'), e('==', msg, e.null())),
    error('object expected'),
    e.block([...fieldsValidations]));

  return e.block([ifObject, returnErrors]);
}

function forType(typeDef, opts) {
  const typeName = runtimeUtil.fqn(typeDef);

  if (CUSTOM_TYPES[typeName]) {
    return CUSTOM_TYPES[typeName](typeDef, opts);
  } else {
    return fieldWiseVerification(typeDef, opts);
  }
}

function forEnum(enumDef, {stringEnums}) {
  const numOfOptions = _.size(enumDef.values);

  const mapper = function ([label, id], idx) {
    return e.case(e.str(stringEnums ? label : id), (idx === (numOfOptions - 1)) ? [e.break()] : []);
  };

  const cases = _(enumDef.values).entries().map(mapper).value();

  return e('obj-prop',
    e.id('verify'),
    e.arrow(
      [e.id('value'), e.id('helper'), e('=', e.id('errors'), id('helper.verification.Errors.empty()'))],
      e.block([
        e.switch(e.id('value'), [
          e.default([error('enum expected')]),
          ...cases
        ]),
        e.return(e.id('errors'))
      ])));
}

function resolveType(fieldDef) {
  const {type, resolvedType} = fieldDef.resolve();
  const typeName = resolvedType ? runtimeUtil.fqn(resolvedType) : type;
  return [typeName, fieldDef];
}

module.exports = {forType, forEnum};
