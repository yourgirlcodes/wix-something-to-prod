const e = require('estree-builder'),
  _ = require('lodash'),
  {Enum, Type} = require('@wix/wnp-protobufjs'),
  {fixupName} = require('./hacks'),
  {util: runtimeUtil} = require('@wix/wix-proto-runtime-toolkit'),
  {DEFAULTS} = require('./defaults'),
  {id, fqn, EMPTY_OBJ, BUILT_IN_IDENTIFIER, and, or, firstDefinedEnumLiteral} = require('./util');

const PRIMITIVE_FIELD = {
  fromJSON: _.identity,
  toJSON: _.identity
};

const HELPER_IDENTIFIER = 'helper';
const WITH_DEFAULTS_IDENTIFIER = 'withDefaults';

const CUSTOM_FIELD_TYPES = {
  'int64': {
    fromJSON: (identifier, {stringLongs} = {}) => {
      return e.ternary(
        or(
          e('===', e.typeof(id(identifier)), e.str('number')),
          and(
            e('===', e.typeof(id(identifier)), e.str('string')),
            e.call(id('/^[-+]?\\d+$/.test'), [identifier])
          )
        ),
        stringLongs ?
          e.call(e('.', identifier, id('toString')), []) :
          e.call(id('Long.fromValue'), [identifier]),
        id(identifier)
      );
    },

    toJSON: identifier => {
      return e.call(e('.', identifier, id('toString')), []);
    }
  },

  'uint64': {
    fromJSON: (identifier, {stringLongs} = {}) => {
      return e.ternary(
        or(
          e('===', e.typeof(id(identifier)), e.str('number')),
          and(
            e('===', e.typeof(id(identifier)), e.str('string')),
            e.call(id('/^[-+]?\\d+$/.test'), [identifier])
          )
        ),
        stringLongs ?
          e.call(e('.', identifier, id('toString')), []) :
          e.call(id('Long.fromValue'), [identifier, e.str('true')]),
        id(identifier)
      );
    },

    toJSON: identifier => {
      return e.call(e('.', identifier, id('toString')), []);
    }
  },

  'bytes': {
    fromJSON: identifier => {
      const body = [e.try([e.return(e.call(id(BUILT_IN_IDENTIFIER, 'Buffer.from'), [id('val'), e.str('base64')]))], e.id('e'), [e.return(id('val'))], [])];
      const inlineFn = e.fn([id('val')], body, 'tryParseBytes');
      return e.call(inlineFn, [identifier]);
    },

    toJSON: identifier => {
      return e.call(id(identifier, 'toString'), [e.str('base64')]);
    }
  },

  'double': {
    fromJSON: identifier => {
      return e.ternary(
        e('===', identifier, e.str('NaN')),
        id('NaN'),
        e.ternary(
          e('===', identifier, e.str('Infinity')),
          id('Infinity'),
          e.ternary(
            e('===', identifier, e.str('-Infinity')),
            id('-Infinity'),
            identifier)));

    },
    toJSON: identifier => {
      return e.ternary(
        e('==', identifier, e.null()),
        identifier,
        e.ternary(e.call(id('isNaN'), [identifier]),
          e.str('NaN'),
          e.ternary(
            e.call(id('isFinite'), [identifier]),
            identifier,
            e.call(e('.', identifier, id('toString')), []))));
    }
  }
};

CUSTOM_FIELD_TYPES['sint64'] = CUSTOM_FIELD_TYPES['fixed64'] = CUSTOM_FIELD_TYPES['sfixed64'] = CUSTOM_FIELD_TYPES['int64'];
CUSTOM_FIELD_TYPES['float'] = CUSTOM_FIELD_TYPES['double'];

const PRIMITIVE_TYPE = {
  fromJSON: () => {
    return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(id('json'))]);
  },

  toJSON: () => {
    return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(id('obj'))]);
  }
};

const DOUBLE_WRAPPER_TYPE = {
  fromJSON: () => {
    return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(CUSTOM_FIELD_TYPES['double'].fromJSON(id('json')))]);
  },

  toJSON: () => {
    return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(CUSTOM_FIELD_TYPES['double'].toJSON(id('obj')))]);
  }
};

const CUSTOM_TYPES = {
  'google.protobuf.Timestamp': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [
        e.return(e('?',
          e('&&',
            e('===', e('typeof', id('json')), e.str('string')),
            e('!', e('call', id('isNaN'), [e.new(e.id('Date'), [id('json')])]))),
          e.new(e.id('Date'), [id('json')]),
          id('json')))
      ]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('obj'), e.call(id('obj', 'toISOString'), [])))]);
    }
  },

  'google.protobuf.Value': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(id('json'))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(id('obj'))]);
    }
  },

  'google.protobuf.Struct': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(id('json'))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(id('obj'))]);
    }
  },

  'google.protobuf.ListValue': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(id('json'))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(id('obj'))]);
    }
  },

  'google.protobuf.Duration': {
    fromJSON: (identifier, { stringLongs } = {}) => {
      const opts = {stringLongs};

      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(
        e('&&', id('json'), e.new(fqn('google.protobuf.Duration'), [e.call(id(HELPER_IDENTIFIER, 'json.Duration.fromJSON'), [id('json'), e('json', opts)])])))]);
    },

    toJSON: (identifier, {stringLongs} = {}) => {
      const opts = {stringLongs};

      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('obj'), e.call(id(HELPER_IDENTIFIER, 'json.Duration.toJSON'), [id('obj'), e('json', opts)])))]);
    }
  },

  'google.protobuf.FieldMask': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('json'), e.call(id('json', 'split'), [e.str(',')])))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('obj'), e.call(id('obj', 'join'), [])))]);
    }
  },

  'google.protobuf.FloatValue': DOUBLE_WRAPPER_TYPE,
  'google.protobuf.DoubleValue': DOUBLE_WRAPPER_TYPE,
  'google.protobuf.StringValue': PRIMITIVE_TYPE,
  'google.protobuf.Int32Value': PRIMITIVE_TYPE,
  'google.protobuf.UInt32Value': PRIMITIVE_TYPE,
  'google.protobuf.BoolValue': PRIMITIVE_TYPE,

  'google.protobuf.Int64Value': {
    fromJSON: (identifier, opts) => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(
        e.ternary(
          e('==', id('json'), e.null()),
          id('json'),
          CUSTOM_FIELD_TYPES['int64'].fromJSON(id('json'), opts)))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(
        e.ternary(
          e('==', id('obj'), e.null()),
          id('obj'),
          CUSTOM_FIELD_TYPES['int64'].toJSON(id('obj'))))]);
    }
  },

  'google.protobuf.UInt64Value': {
    fromJSON: (identifier, opts = {}) => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(
        e.ternary(
          e('==', id('json'), e.null()),
          id('json'),
          CUSTOM_FIELD_TYPES['uint64'].fromJSON(id('json'), opts)))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(
        e.ternary(
          e('==', id('obj'), e.null()),
          id('obj'),
          CUSTOM_FIELD_TYPES['uint64'].toJSON(id('obj'))))]);
    }
  },

  'google.protobuf.BytesValue': {
    fromJSON: () => {
      return e.fn([id('json'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('json'), CUSTOM_FIELD_TYPES['bytes'].fromJSON(id('json'))))]);
    },

    toJSON: () => {
      return e.fn([id('obj'), id(HELPER_IDENTIFIER)], [e.return(e('&&', id('obj'), CUSTOM_FIELD_TYPES['bytes'].toJSON(id('obj'))))]);
    }
  }
};

function forEnum(field, {stringEnums = false} = {}) {
  const {resolvedType} = field.resolve();
  if (resolvedType && resolvedType.constructor && resolvedType.constructor.name === Enum.name) {
    return {
      fromJSON: identifier => {
        return e.ternary(
          e('===', e.typeof(identifier), e.str('string')),
          stringEnums ? identifier : e.get(fqn(resolvedType), identifier),
          stringEnums ? e.get(fqn(resolvedType), identifier) : identifier);
      },

      toJSON: identifier => {
        return e.get(fqn(resolvedType), identifier);
      }
    };
  }
}

function forType(field) {
  const {resolvedType} = field.resolve();
  if (resolvedType && resolvedType.constructor && resolvedType.constructor.name === Type.name) {
    return {
      fromJSON: identifier => {
        return e.call(e('.', fqn(resolvedType), id('fromJSON')), [identifier, id(HELPER_IDENTIFIER)]);
      },

      toJSON: identifier => {
        return e.call(e('.', fqn(resolvedType), id('toJSON')), [identifier, id(HELPER_IDENTIFIER), id(WITH_DEFAULTS_IDENTIFIER)]);
      }
    };
  }
}

function forRepeatedField(field, opts) {
  const nested = forScalarField(field, opts);
  return {
    toJSON: identifier => {
      return e.call(id(identifier, 'map'), [e.arrow([e.id('e')], [e.return(nested.toJSON(e.id('e'), opts))])]);
    },

    fromJSON: identifier => {
      return e.ternary(
        e.call(id('Array.isArray'), [id(identifier)]),
        e.call(id(identifier, 'map'), [e.arrow([e.id('e')], [e.return(nested.fromJSON(e.id('e'), opts))])]),
        id(identifier)
      );
    }
  };
}

function forMapField(field, opts) {
  const nested = forScalarField(field, opts);
  return {
    toJSON: identifier => {
      const entries = e.call(id('Object.entries'), [identifier]);
      return e.call(e('.', entries, e.id('reduce')), [e.arrow([e.id('acc'), e('arr-pattern', [e.id('k'), e.id('v')])], [
        e(';', e('=', e('get', e.id('acc'), e.id('k')), nested.toJSON(e.id('v'), opts))),
        e.return(e.id('acc'))
      ]), EMPTY_OBJ], []);
    },

    fromJSON: identifier => {
      const entries = e.call(id('Object.entries'), [identifier]);
      return e.call(e('.', entries, e.id('reduce')), [e.arrow([e.id('acc'), e('arr-pattern', [e.id('k'), e.id('v')])], [
        e(';', e('=', e('get', e.id('acc'), e.id('k')), nested.fromJSON(e.id('v'), opts))),
        e.return(e.id('acc'))
      ]), EMPTY_OBJ], []);
    }
  };
}

function forScalarField(field, opts) {
  return CUSTOM_FIELD_TYPES[field.type] || forEnum(field, opts) || forType(field, opts) || PRIMITIVE_FIELD;
}

function forField(field, opts) {
  if (field.repeated === true) {
    return forRepeatedField(field, opts);
  } else if (field.map === true) {
    return forMapField(field, opts);
  } else {
    return forScalarField(field, opts);
  }
}

function defaultFor(target, field, {stringEnums = false, stringLongs = false} = {}) {
  const {resolvedType} = field.resolve();

  if (field.map === true) {
    return e(';', e.delete(target));
  } else if (field.repeated === true) {
    return e(';', e('=', target, e.array([])));
  } else if (DEFAULTS[field.type] && !field.partOf) {
    return e(';', e('=', target, DEFAULTS[field.type](stringLongs)));
  } else if (resolvedType && resolvedType.constructor && resolvedType.constructor.name === Enum.name && !field.partOf) {
    return e(';', e('=', target, firstDefinedEnumLiteral(resolvedType, {stringEnums})));
  } else {
    return e(';', e.delete(target));
  }
}

function notEmpty(id) {
  return e('!=', id, e.null());
}

function fromJSON(type, opts) {
  const typeName = runtimeUtil.fqn(type);

  if (CUSTOM_TYPES[typeName]) {
    return CUSTOM_TYPES[typeName].fromJSON(type, opts);
  } else {
    const init = e.const(id('result'), e.new(fqn(type), []));

    const assignments = _(type.fields).toPairs().map(([fieldName, field]) => {
      const {fromJSON} = forField(field, opts);
      const target = id(`result['${fixupName(fieldName)}']`);
      return e.if(
        notEmpty(id(`json['${fixupName(field.name)}']`)),
        e.block([e(';', e('=', target, fromJSON(id(`json['${fixupName(field.name)}']`), opts)))]),
        e.if(
          e('!==', id(WITH_DEFAULTS_IDENTIFIER), e('false')),
          e.block([defaultFor(target, field, opts)]),
          e.block([e(';', e.delete(target))])
        ));
    }).value();

    const ifObjectElseReturn = e.if(
      e('&&',
        e('===', e.typeof(id('json')), e.str('object')),
        e('!', e.call(id('Array.isArray'), [id('json')]))),
      e.block([init, ...assignments, e.return(id('result'))]),
      e.return(id('json'))
    );

    return e.fn([id('json'), id(HELPER_IDENTIFIER), id(WITH_DEFAULTS_IDENTIFIER)], [ifObjectElseReturn]);
  }
}

function toJSON(type, opts) {
  const typeName = runtimeUtil.fqn(type);

  if (CUSTOM_TYPES[typeName]) {
    return CUSTOM_TYPES[typeName].toJSON(type, opts);
  } else {
    const init = e.const(id('json'), EMPTY_OBJ);

    const assignments = _(type.fields).toPairs().map(([fieldName, field]) => {
      const {toJSON} = forField(field, opts);
      const target = id(`json['${fixupName(fieldName)}']`);
      const defaultValue = defaultFor(target, field, opts);

      return e.if(
        e('!=', id(`obj['${fixupName(field.name)}']`), e.null()),
        e.block([e(';', e('=', target, toJSON(id(`obj['${fixupName(field.name)}']`), opts)))]),
        e.if(id(WITH_DEFAULTS_IDENTIFIER), e.block([defaultValue])));
    }).value();

    const ifNullElse = e.if(
      e('==', id('obj'), e.null()),
      e.block([e.return(e.null())]),
      e.block([init, ...assignments, e.return(id('json'))]));

    return e.fn([id('obj'), id(HELPER_IDENTIFIER), id(WITH_DEFAULTS_IDENTIFIER)], [ifNullElse]);
  }
}

module.exports = {fromJSON, toJSON};
