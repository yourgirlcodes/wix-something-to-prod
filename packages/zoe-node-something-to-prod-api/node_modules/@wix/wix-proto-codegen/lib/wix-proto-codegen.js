const pkg = require('../package.json');
require('please-upgrade-node')(pkg);

const js = require('./javascript/codegen'),
  {join} = require('path'),
  ts = require('./typescript/index'),
  fs = require('fs'),
  {Workspace} = require('./workspace'),
  pbjs = require('@wix/wnp-protobufjs'),
  tools = require('./tools'),
  shelljs = require('shelljs'),
  assert = require('assert'),
  log = require('@wix/wix-log')('wix-proto-codegen');

class CodeGenerationError extends Error {

  constructor(msg, {cause}) {
    super(msg);
    Error.captureStackTrace(this, CodeGenerationError);
    if (cause) {
      if (cause instanceof Error) {
        this.cause = cause;
      } else {
        this.cause = new Error(cause.toString());
      }
      this.stack += '\nCaused By: ' + (cause.stack || cause.toString());
    }
  }
}

async function generate(opts) {
  const workspace = new Workspace(opts.moduleDir);

  log.info('resolving protobuf files from dependencies...');
  workspace.resolveDependencies(opts);
  log.info('detected files:\n' + workspace.toString());

  if (!opts.skipGeneration) {
    log.info('generating JS & TS code...');

    try {
      const root = await workspace.loadProto();
      workspace.validate(opts);
      shelljs.mkdir('-p', opts.target.dir);
      const jsSrc = js.generateJavaScript(root, opts);
      const tsSrc = ts.generateTypeScript(root, opts);
      fs.writeFileSync(join(opts.target.dir, `${opts.target.name}.js`), jsSrc);
      fs.writeFileSync(join(opts.target.dir, `${opts.target.name}.d.ts`), tsSrc.src);
      if (tsSrc.server && tsSrc.client) {
        const clientServerIndexJs = getClientServerIndexContent(opts.target.name);
        writeClientServerTypes(opts.target.dir, opts.target.name, 'client', tsSrc.client, clientServerIndexJs);
        writeClientServerTypes(opts.target.dir, opts.target.name, 'server', tsSrc.server, clientServerIndexJs);
      }
      return root;
    } catch (err) {
      throw new CodeGenerationError(`${err.message}\n\n\toffending module:\t${err.module}\n\toffending file:\t\t${err.file}\n\n`, {cause: err});
    }
  } else {
    log.info('skipping code generation');
  }
  log.info('completed');
}

function writeClientServerTypes(targetDir, targetName, type, src, clientServerIndexJs) {
  shelljs.mkdir('-p', join(targetDir, type));
  fs.writeFileSync(join(targetDir, type, `${targetName}.d.ts`), src);
  fs.writeFileSync(join(targetDir, type, `${targetName}.js`), clientServerIndexJs);
}

function getClientServerIndexContent(targetName) {
  return `const wrapper = require('../${targetName}');
module.exports = {services: wrapper, requests: wrapper, responses: wrapper};
`;
}

function sanitize(opts) {
  assert(opts.moduleDir && typeof opts.moduleDir === 'string', 'moduleDir is required');
  const defaults = {
    target: {
      dir: join(opts.moduleDir, 'dist'),
      name: 'proto-generated'
    },
    skipGeneration: false,
    withAspectStore: true,
    strictMode: false,
    alternateCommentMode: false,
    preferTrailingComment: false,
    withAspectlessServices: true,
    stdCase: false,
  };
  return Object.assign({}, defaults, opts);
}

async function generateFromJson(json) {
  const root = pbjs.Root.fromJSON(json);
  return js.generateJavaScript(root, {stringEnums: true});
}

module.exports = opts => generate(sanitize(opts));

Object.assign(module.exports, {
  CodeGenerationError,
  tools,
  generateFromJson,
});

