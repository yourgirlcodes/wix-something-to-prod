const {throwError} = require('./validation-error');
const {util} = require('@wix/wix-proto-runtime-toolkit');
const options = util.options('wix.api');
const _ = require('lodash');

const validEventTypes = function (node) {
  if (!this._types) {
    const eventType = node.root.lookup('wix.api.Callback.EventType');
    this._types = new Set(Object.keys(eventType.values));
  }
  return this._types;
};

function validateMessage(message) {
  const customSlug = options(message).find('action_payload.custom_slug').first;
  if (customSlug === '') {
    throwError(message, 'wix.api.action_payload.custom_slug cannot be empty');
  }
}

function validateMethod(method) {
  const CALLBACK_REGEX = /^[^\w]*wix\.api\.callback[^\w]*$/;
  const service = method.parent;

  const callbacks = _(method.parsedOptions || [])
    .map(elem => _.entries(elem))
    .flatten()
    .filter(([key]) => CALLBACK_REGEX.test(key))
    .map(([, value]) => value)
    .value();

  callbacks.forEach(({event_type: eventType, payload, topic}) => {
    if (eventType) {
      if (!validEventTypes(method).has(eventType)) {
        throwError(method, `unknown value ${eventType} for wix.api.callback#event_type - supported values: ${[...validEventTypes(method)]}`);
      }
      const serviceEntity = options(service).find('service_entity.message').first;
      if (!serviceEntity) {
        throwError(method, 'wix.api.callback#event_type requires wix.api.service_entity to be defined on service');
      }

      if (eventType === 'ACTION') {
        if (!payload) {
          throwError(method, 'wix.api.callback#event_type ACTION must have wix.api.callback#payload');
        }
      } else {
        if (payload) {
          throwError(method, 'wix.api.callback#event_type other than ACTION cannot have wix.api.callback#payload');
        }
      }

      if (topic) {
        throwError(method, 'wix.api.callback cannot have both #topic and #event_type defined');
      }
    }
  });
}

module.exports = {validateMethod, validateMessage};
