const CodeBlockWriter = require('code-block-writer').default,
  {
    BaseVisitor,
    LONGS,
    PRIMITIVES,
    servicesVisitorMixin,
    messagesVisitorMixin,
    writeComment,
    writeHeader,
    typeFor,
    visit,
    isEnum,
  } = require('./common'),
  {escapeIdentifier} = require('../javascript/util');

const namespaces = {
  requests: '$requests',
  responses: '$responses',
  services: '$services',
};

function hasDefaultValue(field) {
  if (field.partOf) {
    return false;
  } else if (field.repeated || PRIMITIVES.has(field.type)) {
    return true;
  } else {
    const {resolvedType} = field.resolve();
    return isEnum(resolvedType);
  }
}

function isLong(field) {
  return LONGS.has(field.type);
}

function generateClientServerTypeScript(proto, server, {
  stringEnums,
  stringLongs,
  tsClasses,
  withAspectStore,
  withAspectlessServices,
  methodCamelCase
}) {
  const w = new CodeBlockWriter();

  const requestsVisitor = new MessagesVisitor(namespaces.requests, server, {tsClasses, stringEnums, stringLongs});
  const responsesVisitor = new MessagesVisitor(namespaces.responses, !server, {tsClasses, stringEnums, stringLongs});
  const servicesVisitor = new ServicesVisitor(!server && withAspectlessServices, {tsClasses, withAspectStore, methodCamelCase, stringLongs});

  visit(proto, requestsVisitor);
  visit(proto, responsesVisitor);
  visit(proto, servicesVisitor);

  writeHeader(w, requestsVisitor.hasLong, withAspectStore && servicesVisitor.hasService, tsClasses);

  w.write(`declare namespace ${namespaces.requests}`)
    .block(() => requestsVisitor.codegen.apply(w))
    .writeLine(`export {${namespaces.requests} as requests};`)
    .blankLine()
    .write(`declare namespace ${namespaces.responses}`)
    .block(() => responsesVisitor.codegen.apply(w))
    .writeLine(`export {${namespaces.responses} as responses};`);

  if (servicesVisitor.hasService) {
    w.blankLine()
      .write(`declare namespace ${namespaces.services}`)
      .block(() => servicesVisitor.codegen.apply(w))
      .writeLine(`export {${namespaces.services} as services};`);
  }

  return w.toString();
}

class ServicesVisitor extends servicesVisitorMixin(BaseVisitor) {
  constructor(withAspectlessOverload, {tsClasses, withAspectStore, methodCamelCase}) {
    super();

    this.requestsNamespace = namespaces.requests;
    this.responsesNamespace = namespaces.responses;
    this.withAspectlessOverload = withAspectlessOverload;

    this.options = {
      tsClasses,
      withAspectStore,
      methodCamelCase,
    };
  }
}

class MessagesVisitor extends messagesVisitorMixin(BaseVisitor) {
  constructor(namespace, withDefaults, {tsClasses, stringEnums, stringLongs}) {
    super();

    this.namespace = namespace;
    this.withDefaults = withDefaults;

    this.options = {
      tsClasses,
      stringEnums,
      stringLongs,
    };
  }

  beforeField(field) {
    if (this.data(field.parent).codegenFields) {
      this.data(field.parent).codegenFields.push((w) => writeComment(w, field));

      let fieldType = typeFor(field, 'type', this.namespace, this.options);
      const withDefault = this.withDefaults && hasDefaultValue(field);

      if (!this.options.stringLongs && isLong(field)) {
        this.hasLong = true;

        if (withDefault) {
          fieldType = 'Long';
        }
      }

      const fieldLine = (w) => w.writeLine(`${escapeIdentifier(field.name)}${withDefault ? '' : '?'}: ${fieldType}${field.repeated ? '[]' : ''};`);
      this.data(field.parent).codegenFields.push(fieldLine);

      if (this.options.tsClasses === true) {
        this.data(field.parent).codegenClassFields.push(fieldLine);
      }
    }
  }

  beforeMapField(field) {
    if (this.data(field.parent).codegenFields) {
      let fieldType = typeFor(field, 'type', this.namespace, this.options);

      if (!this.options.stringLongs && isLong(field)) {
        this.hasLong = true;

        if (this.withDefaults) {
          fieldType = 'Long';
        }
      }

      const fieldLine = (w) => w.writeLine(`${escapeIdentifier(field.name)}?: { [k: string]: ${fieldType} };`);
      this.data(field.parent).codegenFields.push(fieldLine);

      if (this.options.tsClasses === true) {
        this.data(field.parent).codegenClassFields.push(fieldLine);
      }
    }
  }
}

module.exports = { generateClientServerTypeScript };
