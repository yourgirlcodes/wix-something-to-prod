const CodeBlockWriter = require('code-block-writer').default,
  {writeComment, typeFor, visit, LONG_SIGNATURE, BaseVisitor, writeHeader, servicesVisitorMixin, messagesVisitorMixin} = require('./common'),
  {escapeIdentifier} = require('../javascript/util');

const wrapperNamespace = '$wrapper';

function generateDefaultTypeScript(proto, {stringLongs, stringEnums, tsClasses, withAspectStore, tsExportDefault, methodCamelCase}) {
  const w = new CodeBlockWriter();

  const visitor = new DefaultVisitor({
    stringLongs,
    stringEnums,
    tsClasses,
    withAspectStore,
    methodCamelCase,
  });

  visit(proto, visitor);

  writeHeader(w, visitor.hasLong, withAspectStore && visitor.hasService, tsClasses);

  w.write(`declare namespace ${wrapperNamespace}`)
    .block(() => visitor.codegen.apply(w))
    .blankLine()
    .writeLine(`export ${tsExportDefault ? 'default' : '='} ${wrapperNamespace};`);

  return w.toString();
}

class DefaultVisitor extends servicesVisitorMixin(messagesVisitorMixin(BaseVisitor)) {
  constructor({stringLongs, stringEnums, tsClasses, withAspectStore, methodCamelCase}) {
    super();

    this.namespace = wrapperNamespace;
    this.requestsNamespace = wrapperNamespace;
    this.responsesNamespace = wrapperNamespace;

    this.options = {
      stringLongs,
      stringEnums,
      tsClasses,
      withAspectStore,
      methodCamelCase,
    };
  }

  beforeField(field) {
    if (this.data(field.parent).codegenFields) {
      this.data(field.parent).codegenFields.push((w) => writeComment(w, field));

      const fieldType = typeFor(field, 'type', wrapperNamespace, this.options);
      this.hasLong = this.hasLong || fieldType === LONG_SIGNATURE;
      const orNull = fieldType === 'null' ? '' : ' | null';
      const fieldLine = (w) => w.writeLine(`${escapeIdentifier(field.name)}?: (${fieldType}${field.repeated ? '[]' : ''}${orNull});`);
      this.data(field.parent).codegenFields.push(fieldLine);

      if (this.options.tsClasses === true) {
        this.data(field.parent).codegenClassFields.push(fieldLine);
      }
    }
  }

  beforeMapField(field) {
    if (this.data(field.parent).codegenFields) {
      const fieldType = typeFor(field, 'type', wrapperNamespace, this.options);
      this.hasLong = this.hasLong || fieldType === LONG_SIGNATURE;
      this.data(field.parent).codegenFields.push((w) => w.writeLine(`${escapeIdentifier(field.name)}?: ({ [k: string]: ${fieldType} } | null);`));

      if (this.options.tsClasses === true) {
        this.data(field.parent).codegenClassFields.push((w) => w.writeLine(`${field.name}?: ({ [k: string]: ${fieldType} });`));
      }
    }
  }
}

module.exports = {generateDefaultTypeScript};
