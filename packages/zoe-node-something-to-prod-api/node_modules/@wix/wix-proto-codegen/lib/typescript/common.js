const {primitiveMappings, isWrapperType} = require('../wrapper-types'),
  protobuf = require('@wix/wnp-protobufjs'),
  _ = require('lodash'),
  visitor = require('../proto-ast-traverse'),
  {isFromDescriptor} = require('../pbjs/descriptor'),
  {util: runtimeUtil} = require('@wix/wix-proto-runtime-toolkit');

const PRIMITIVES = new Set(['int32', 'sint32', 'uint32', 'fixed32', 'sfixed32', 'double', 'float', 'bool', 'string', 'bytes', 'int64', 'uint64', 'sint64', 'fixed64', 'sfixed64']);
const LONGS = new Set(['int64', 'uint64', 'sint64', 'fixed64', 'sfixed64']);

const LONG_SIGNATURE = '(number | Long)';
const STRING_LONG_SIGNATURE = '(number | string)';

const GENERATED_GOOGLE_TYPES = new Set(['google.protobuf.Duration', 'google.protobuf.Any']);

const CUSTOM_TYPES = {
  'google.protobuf.Any': require('./customTypes/any')
};

function skippedTypes(node) {
  if (node.isOfType(protobuf.Type) || node.isOfType(protobuf.Enum)) {
    const name = runtimeUtil.fqn(node);
    return name.startsWith('google.protobuf') && !GENERATED_GOOGLE_TYPES.has(name) && !isFromDescriptor(name);
  } else {
    return false;
  }
}

function isEnum(fieldNode) {
  return fieldNode.isOfType && fieldNode.isOfType(protobuf.Enum);
}

function typeFor(field, key, namespace, {tsClasses, stringLongs} = {}) {
  function convertClassNameToInterfaceName(nameParts) {
    nameParts[nameParts.length - 1] = `I${nameParts[nameParts.length - 1]}`;
  }

  function fullyQualifiedName(field, key) {
    const fieldNode = field.resolve()[`resolved${_.upperFirst(key)}`];

    function rec(node = fieldNode) {
      if (node.isOfType && node.isOfType(protobuf.Root)) {
        return [];
      } else {
        return rec(node.parent).concat([node.name]);
      }
    }

    const fragments = rec();

    if (tsClasses === true && !isEnum(fieldNode)) {
      convertClassNameToInterfaceName(fragments);
    }

    return fragments.join('.');
  }

  function getTypeMappings(stringLongs) {
    const TYPE_MAPPING = {
      'double': 'number',
      'float': 'number',
      'int32': 'number',
      'uint32': 'number',
      'sint32': 'number',
      'fixed32': 'number',
      'sfixed32': 'number',
      'bool': 'boolean',
      'string': 'string',
      'bytes': 'Uint8Array',
      'int64': stringLongs ? STRING_LONG_SIGNATURE : LONG_SIGNATURE,
      'uint64': stringLongs ? STRING_LONG_SIGNATURE : LONG_SIGNATURE,
      'sint64': stringLongs ? STRING_LONG_SIGNATURE : LONG_SIGNATURE,
      'fixed64': stringLongs ? STRING_LONG_SIGNATURE : LONG_SIGNATURE,
      'sfixed64': stringLongs ? STRING_LONG_SIGNATURE : LONG_SIGNATURE,
      'google.protobuf.Struct': '{ [key: string]: any }',
      'google.protobuf.Timestamp': 'Date',
      'google.protobuf.NullValue': 'null',
      'google.protobuf.Empty': '{}',
      'google.protobuf.Value': 'any',
      'google.protobuf.FieldMask': 'string[]',
      'google.protobuf.Any': 'google.protobuf.Any',
      'google.protobuf.ListValue': 'any[]',
    };

    for (const key in primitiveMappings) {
      TYPE_MAPPING[key] = TYPE_MAPPING[primitiveMappings[key]];
    }

    return TYPE_MAPPING;
  }

  const typeMapping = getTypeMappings(stringLongs);

  return typeMapping[field[key]] || `${namespace}.${fullyQualifiedName(field, key)}`;
}

function writeComment(w, node) {
  if (node.comment) {
    w.writeLine('/**');
    node.comment.split('\n').forEach(c => {
      const escaped = c.replace('*/', '* /');
      w.writeLine(' * ' + escaped);
    });
    w.writeLine(' */');
  }
}

class GenQueue {

  constructor() {
    this.children = [];
  }

  push(code) {
    this.children.push(code);
  }

  apply(w) {
    this.children.forEach(fn => fn(w));
  }

  isEmpty() {
    return this.children.length === 0;
  }
}

function visit(proto, handlers) {
  visitor(proto).filterOut(skippedTypes).visit(handlers);
}

class BaseVisitor {
  beforeRoot(root) {
    this._data = new Map();
    this.codegen = new GenQueue();
    this.data(root).codegen = this.codegen;
  }

  data(node) {
    let val = this._data.get(node);
    if (!val) {
      val = {};
      this._data.set(node, val);
    }
    return val;
  }

  beforeNamespace(namespace) {
    this.data(namespace).codegen = new GenQueue();
  }

  afterNamespace(namespace) {
    if (!this.data(namespace).codegen.isEmpty()) {
      this.data(namespace.parent).codegen.push((w) => w.write(`export namespace ${namespace.name}`).block(() =>
        this.data(namespace).codegen.apply(w)
      ));
    }
  }
}

const servicesVisitorMixin = (superclass) => class extends superclass {
  beforeService(service) {
    this.data(service).codegenMethods = new GenQueue();
    this.data(service.parent).codegen.push((w) => writeComment(w, service));
  }

  afterService(service) {
    this.hasService = true;
    this.data(service.parent).codegen.push((w) =>
      w.write(`export abstract class ${service.name}`)
        .block(() => this.data(service).codegenMethods.apply(w)));
  }

  beforeMethod(method) {
    this.data(method.parent).codegenMethods.push((w) => writeComment(w, method));

    let reqType = typeFor(method, 'requestType', this.requestsNamespace, this.options);

    if (isWrapperType(method.requestType)) {
      reqType += '| undefined';
    }

    let resType = typeFor(method, 'responseType', this.responsesNamespace, this.options);

    if (isWrapperType(method.responseType)) {
      resType += '| undefined';
    }

    const aspectsType = this.options.withAspectStore ? 'AspectStore' : 'object';
    const abstractMethod = `abstract ${this.options.methodCamelCase(method.name)}(aspects: ${aspectsType}, req: ${reqType}): Promise<${resType}>`;
    this.data(method.parent).codegenMethods.push((w) => w.writeLine(abstractMethod));

    if (this.withAspectlessOverload) {
      const aspectlessMethodOverload = `abstract ${this.options.methodCamelCase(method.name)}(req: ${reqType}): Promise<${resType}>`;
      this.data(method.parent).codegenMethods.push((w) => w.writeLine(aspectlessMethodOverload));
    }
  }
};

const messagesVisitorMixin = (superclass) => class extends superclass {
  beforeType(type) {
    if (!CUSTOM_TYPES[runtimeUtil.fqn(type)]) {
      this.data(type).codegenFields = new GenQueue();
      this.data(type).codegenClassFields = new GenQueue();
      this.data(type).codegen = new GenQueue();
      this.data(type.parent).codegen.push((w) => writeComment(w, type));
    }
  }

  afterType(type) {
    this.data(type.parent).codegen.push((w) => {
      const fqn = runtimeUtil.fqn(type);
      if (!CUSTOM_TYPES[fqn]) {
        const interfaceName = `${this.options.tsClasses ? 'I' : ''}${type.name}`;

        w.write(`export interface ${interfaceName}`).block(() => this.data(type).codegenFields.apply(w));

        if (this.options.tsClasses === true) {
          w.write(`export class ${type.name} implements ${interfaceName}`)
            .block(() => {
              w.writeLine(`constructor(data?: ${interfaceName});`);
              this.data(type).codegenClassFields.apply(w);
              w.writeLine('static __$$generatedFromProtobuf$$__: Symbol;');
            });
        }

        if (!this.data(type).codegen.isEmpty()) {
          w.write(`export namespace ${type.name}`).block(() => this.data(type).codegen.apply(w));
        }
      } else {
        CUSTOM_TYPES[fqn](w, this.namespace);
      }
    });
  }

  beforeEnum(_enum) {
    this.data(_enum.parent).codegen.push((w) => {
      writeComment(w, _enum);
      w.write(`export enum ${_enum.name}`)
        .block(() =>
          _.forOwn(_enum.values, (val, key) => w.writeLine(`${key} = ${this.options.stringEnums ? '"' + key + '"' : val},`)));
    });
  }
};


function writeHeader(w, writeLong, writeAspectStore, tsClasses) {
  w.conditionalWriteLine(writeLong, 'import Long from \'long\';')
    .conditionalWriteLine(writeAspectStore, 'import {AspectStore} from \'@wix/wix-aspects\';')
    .blankLine();

  if (tsClasses) {
    w.write('type $GeneratedMessageClassNominal$ = ')
      .block(() => w.writeLine('__$$generatedFromProtobuf$$__: Symbol;'))
      .writeLine('type $$GeneratedMessage$$<C> = Function & { prototype: C } & $GeneratedMessageClassNominal$;')
      .blankLine();
  }
}

module.exports = {
  LONG_SIGNATURE,
  LONGS,
  PRIMITIVES,
  typeFor,
  writeComment,
  writeHeader,
  isEnum,
  visit,
  BaseVisitor,
  servicesVisitorMixin,
  messagesVisitorMixin,
};
