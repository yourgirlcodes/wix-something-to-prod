import tmp from 'tmp';
import {createContext, prepareRepo} from './test-utils';
import {FlyntCtx, Severity} from '@wix/flynt-plugin-types';
import path from 'path';
import {NodePlugin} from '../lib/node-plugin';
import {runGit} from '../lib/git-utils';
import {FlyntApiOpts, flynt} from '@wix/flynt';
import {copy} from 'fs-extra';

describe('node plugin', () => {
  describe('Flynt Options', () => {
    let repo: string;
    let ctx: FlyntCtx;

    beforeEach(async () => {
      repo = tmp.dirSync({prefix: 'git-repo'}).name;
      ctx = createContext({
        moduleRootFolder: path.join(repo, 'api'),
        mainProtoFolder: path.join(repo, 'api', 'src/main/proto'),
      });
    });

    describe('when running from a non git repo', () => {
      beforeEach(async () => {
        await copy(path.join('./test/repos/simple', 'master'), repo);
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from master branch', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {skipBranches: true});
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from a pr branch without changes', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {skipBranches: true});
        await runGit(repo, 'checkout', '-b', 'pr');
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from a pr branch with changes in other modules', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr-with-other-changes'});
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from a pr branch with changes', () => {
      let plugin: NodePlugin;

      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr'});
        plugin = new NodePlugin();
        await plugin.init(ctx);
      });

      afterEach(async () => {
        await plugin.beforeUnload(ctx);
      });

      it('updates flynt options to be stateful', async () => {
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeDefined();
        expect(ctx.opts.prevModuleRootFolder).toBeDefined();
      });
    });

    describe('when running from a pr branch with changes but skipStateful was set', () => {
      let plugin: NodePlugin;

      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr'});
        plugin = new NodePlugin({skipStateful: true});
        await plugin.init(ctx);
      });

      afterEach(async () => {
        await plugin.beforeUnload(ctx);
      });

      it('does not update flynt options', async () => {
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from a pr branch with new API module', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/new-module', repo);
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });

    describe('when running from a pr branch with no master branch', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/no-master', repo, {masterBranch: 'main'});
      });

      it('does not update flynt options', async () => {
        const plugin = new NodePlugin();
        await plugin.init(ctx);
        plugin.beforeValidateFlyntOptions(ctx);
        expect(ctx.opts.prevMainProtoFolder).toBeUndefined();
        expect(ctx.opts.prevModuleRootFolder).toBeUndefined();
      });
    });
  });

  describe('Flynt API', () => {
    let repo: string;
    let opts: FlyntApiOpts;

    beforeEach(async () => {
      repo = tmp.dirSync({prefix: 'git-repo'}).name;
      opts = {
        moduleRootFolder: path.join(repo, 'api'),
        mainProtoFolder: path.join(repo, 'api', 'src/main/proto'),
        plugins: [new NodePlugin()]
      };
    });

    describe('when running from a pr branch without changes', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {skipBranches: true});
        await runGit(repo, 'checkout', '-b', 'pr');
      });

      it('stateful test rule should not fail', async () => {
        const results = await flynt(opts);

        expect(results.output.lintResults.results).not.toContainEqual(expect.objectContaining({
          ruleId: 'stateful-test-rule-dhsanpklgwsyaiqjxksx'
        }));
      });
    });

    describe('when running from a pr branch with changes', () => {
      beforeEach(async () => {
        await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr'});
      });

      it('stateful test rule should fail', async () => {
        opts.verbose = true;
        const results = await flynt(opts);

        expect(results.output.lintResults.results).toContainEqual(expect.objectContaining({
          ruleId: 'stateful-test-rule-dhsanpklgwsyaiqjxksx',
          severity: Severity.Error,
        }));
      });
    });

    describe('work tree', () => {
      describe('when plugin creates worktree internally', () => {
        beforeEach(async () => {
          opts = {
            moduleRootFolder: path.join(repo, 'api'),
            mainProtoFolder: path.join(repo, 'api', 'src/main/proto'),
            plugins: [new NodePlugin()]
          };
          await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr'});
        });

        it('no worktree is present after Flynt is finished', async () => {
          await flynt(opts);
          const wtList = await runGit(repo, 'worktree', 'list', '--porcelain');

          //Only one worktree should be present after Flynt finishes
          expect(wtList.match(/^HEAD /mg)).toHaveLength(1);
        });
      });

      describe('when plugin is initialized with a worktree', () => {
        let wt: string;
        beforeEach(async () => {
          wt = tmp.dirSync({prefix: 'wtXX'}).name;
          opts = {
            moduleRootFolder: path.join(repo, 'api'),
            mainProtoFolder: path.join(repo, 'api', 'src/main/proto'),
            plugins: [new NodePlugin({workTree: wt})]
          };
          await prepareRepo('./test/repos/simple', repo, {switchTo: 'pr'});
          await runGit(repo, 'worktree', 'add', wt, 'master', '--no-checkout', '--detach');
        });

        it('the passed worktree should not be deleted', async () => {
          await flynt(opts);
          const wtList = await runGit(repo, 'worktree', 'list', '--porcelain');

          //expecting the created worktree to appear in the list
          expect(wtList.match(/^HEAD /mg)).toHaveLength(2);
          expect(wtList).toMatch(wt);
        });
      });
    });

  });
});
