import {FlyntCtx, FlyntPlugin} from '@wix/flynt-plugin-types';
import {gitCreateWorktree, gitDirExistsInBranch, gitGetRootDir, gitIsDiff, runGit} from './git-utils';
import {getBuildInfo} from '@wix/ci-build-info';
import path from 'path';

export type PluginHints = {skipStateful: true} | {skipStateful?: false; workTree: string};

function isLegaci() {
  try {
    console.error('checking ci system');
    const info = getBuildInfo();
    return !info.v2.isFalcon;
  } catch {
    return false;
  }
}

export class NodePlugin implements FlyntPlugin {
  readonly name = 'node';

  private readonly cleanWorkTree: boolean;
  private readonly skipStateful: boolean;
  private workTree?: string;
  private prevMainProtoFolder?: string;

  constructor(hints?: PluginHints) {
    this.skipStateful = false;
    this.cleanWorkTree = true;
    if (hints) {
      if (hints.skipStateful) {
        this.skipStateful = true;
      } else {
        this.workTree = hints.workTree;
        this.cleanWorkTree = false;
      }
    }
  }

  async init(ctx: FlyntCtx) {
    ctx.debug('flynt node plugin - init');
    if (!this.skipStateful) {
      const cwd = ctx.opts.mainProtoFolder;
      try {
        if (isLegaci()) {
          return;
        }
        ctx.debug('find root git dir');
        const rootDir = await gitGetRootDir(cwd);
        if (rootDir) {
          const baseBranch = 'master';
          //Check if folder exists in master branch
          const protoRelativePath = await runGit(cwd, 'rev-parse', '--show-prefix');
          if (await gitDirExistsInBranch(rootDir, protoRelativePath, baseBranch)) {
            ctx.debug('checking gitIsDiff');
            const isDifferent = await gitIsDiff(cwd, baseBranch);
            if (isDifferent) {
              ctx.debug('preparing stateful mode');
              const workTreePath = await this.createWorkTreeIfNeeded(ctx, cwd, baseBranch);
              ctx.debug(`copying "${baseBranch}" version of files`);
              await runGit(workTreePath, 'checkout', baseBranch, protoRelativePath);
              this.prevMainProtoFolder = path.join(workTreePath, protoRelativePath);
            }
          }
        }
      } catch (err) {
        console.error('Failed to initialize');
        const version = await runGit(cwd, 'version');
        console.error(version);
        throw err;
      }
    }
    ctx.debug('finished');
  }

  async beforeUnload(ctx: FlyntCtx) {
    if (this.cleanWorkTree && this.workTree) {
      ctx.debug('removing temporary worktree');
      await runGit(this.workTree, 'worktree', 'remove', this.workTree, '--force');
    }
  }

  beforeValidateFlyntOptions(ctx: FlyntCtx) {
    if (this.prevMainProtoFolder) {
      ctx.opts.prevMainProtoFolder = this.prevMainProtoFolder;
      ctx.opts.prevModuleRootFolder = ctx.opts.moduleRootFolder;
      ctx.opts.prevIncludeProtoFolder = ctx.opts.includeProtoFolder;
    }
  }

  private async createWorkTreeIfNeeded(ctx: FlyntCtx, cwd: string, baseBranch: string) {
    if (!this.workTree) {
      ctx.debug('creating temporary worktree');
      this.workTree = await gitCreateWorktree(cwd, baseBranch);
    }
    return this.workTree;
  }
}
