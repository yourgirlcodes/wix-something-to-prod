"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePlugin = void 0;
const git_utils_1 = require("./git-utils");
const ci_build_info_1 = require("@wix/ci-build-info");
const path_1 = __importDefault(require("path"));
function isLegaci() {
    try {
        console.error('checking ci system');
        const info = (0, ci_build_info_1.getBuildInfo)();
        return !info.v2.isFalcon;
    }
    catch {
        return false;
    }
}
class NodePlugin {
    constructor(hints) {
        this.name = 'node';
        this.skipStateful = false;
        this.cleanWorkTree = true;
        if (hints) {
            if (hints.skipStateful) {
                this.skipStateful = true;
            }
            else {
                this.workTree = hints.workTree;
                this.cleanWorkTree = false;
            }
        }
    }
    async init(ctx) {
        ctx.debug('flynt node plugin - init');
        if (!this.skipStateful) {
            const cwd = ctx.opts.mainProtoFolder;
            try {
                if (isLegaci()) {
                    return;
                }
                ctx.debug('find root git dir');
                const rootDir = await (0, git_utils_1.gitGetRootDir)(cwd);
                if (rootDir) {
                    const baseBranch = 'master';
                    const protoRelativePath = await (0, git_utils_1.runGit)(cwd, 'rev-parse', '--show-prefix');
                    if (await (0, git_utils_1.gitDirExistsInBranch)(rootDir, protoRelativePath, baseBranch)) {
                        ctx.debug('checking gitIsDiff');
                        const isDifferent = await (0, git_utils_1.gitIsDiff)(cwd, baseBranch);
                        if (isDifferent) {
                            ctx.debug('preparing stateful mode');
                            const workTreePath = await this.createWorkTreeIfNeeded(ctx, cwd, baseBranch);
                            ctx.debug(`copying "${baseBranch}" version of files`);
                            await (0, git_utils_1.runGit)(workTreePath, 'checkout', baseBranch, protoRelativePath);
                            this.prevMainProtoFolder = path_1.default.join(workTreePath, protoRelativePath);
                        }
                    }
                }
            }
            catch (err) {
                console.error('Failed to initialize');
                const version = await (0, git_utils_1.runGit)(cwd, 'version');
                console.error(version);
                throw err;
            }
        }
        ctx.debug('finished');
    }
    async beforeUnload(ctx) {
        if (this.cleanWorkTree && this.workTree) {
            ctx.debug('removing temporary worktree');
            await (0, git_utils_1.runGit)(this.workTree, 'worktree', 'remove', this.workTree, '--force');
        }
    }
    beforeValidateFlyntOptions(ctx) {
        if (this.prevMainProtoFolder) {
            ctx.opts.prevMainProtoFolder = this.prevMainProtoFolder;
            ctx.opts.prevModuleRootFolder = ctx.opts.moduleRootFolder;
            ctx.opts.prevIncludeProtoFolder = ctx.opts.includeProtoFolder;
        }
    }
    async createWorkTreeIfNeeded(ctx, cwd, baseBranch) {
        if (!this.workTree) {
            ctx.debug('creating temporary worktree');
            this.workTree = await (0, git_utils_1.gitCreateWorktree)(cwd, baseBranch);
        }
        return this.workTree;
    }
}
exports.NodePlugin = NodePlugin;
//# sourceMappingURL=node-plugin.js.map