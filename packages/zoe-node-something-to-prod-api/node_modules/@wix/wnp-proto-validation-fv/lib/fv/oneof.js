module.exports = {
  messages: {
    'oneof.base': 'Only a single field from \'{expected}\' must be defined due to oneof, however \'{actual}\' fields are defined',
    'oneof.required': 'A single field from \'{expected}\' must be defined due to required oneof',
  },
  rules: {
    'object-with-oneof': function ({schema, messages}, path, context) {
      const src = [];
      const updated = {...schema, type: 'object'};
      const rule = this.getRuleFromSchema(updated);
      const innerSource = 'value = context.fn[%%INDEX%%](value, field, null, errors, context);';
      const nested = this.compileRule(rule, context, path, innerSource, 'value');
      src.push(nested);   
      
      Object.keys(schema.oneofs || {}).forEach(oneof => {
        const {fields, optional} = schema.oneofs[oneof];
        const fieldsArray = `[${fields.map(f => `'${f}'`)}]`; 
        const countVar = `oneOf${oneof}Defined`; 
        src.push(`
          // ${oneof} OneOf
          const ${countVar} = ${fieldsArray}.filter(f => typeof value[f] !== 'undefined' && value[f] !== null);
          if (${countVar}.length > 1) {
            ${this.makeError({ type: 'oneof.base', expected: fieldsArray, actual: countVar, messages })}
          }
        `);
        if (optional === false) {
          src.push(`
          if (${countVar}.length === 0) {
            ${this.makeError({ type: 'oneof.required', expected: fieldsArray, messages })}
          }
          `);
        }
      });
      src.push('return value;');
      return {
        source: src.join('\n')
      };
    }
  }
};