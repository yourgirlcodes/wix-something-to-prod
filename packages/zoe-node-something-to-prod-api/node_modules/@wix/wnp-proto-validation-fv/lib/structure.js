const _ = require('lodash');
const {Path, schemaIdFor, alias} = require('./util');
const {util} = require('@wix/wix-proto-runtime-toolkit');
const {validator} = require('./fv');

const WRAPPER_TYPES = new Set([
  'google.protobuf.Int32Value',
  'google.protobuf.DoubleValue',
  'google.protobuf.FloatValue',
  'google.protobuf.Int64Value',
  'google.protobuf.StringValue',
  'google.protobuf.BytesValue',
  'google.protobuf.BoolValue',
  'google.protobuf.UInt32Value',
  'google.protobuf.UInt64Value',
  'google.protobuf.Timestamp',
  'google.protobuf.ListValue',
  'google.protobuf.Struct',
  'google.protobuf.Value',
  'google.protobuf.FieldMask',
]);

const SCALAR_VALIDATORS = {
  string: () => ({type: 'string', optional: true}),
  bool: () => ({type: 'boolean', optional: true}),
  bytes: () => ({type: 'binary'}),
  float: () => ({type: 'number-ext', optional: true}),
  int32: () => ({type: 'number-ext', optional: true, integer: true}),
  uint32: () => ({type: 'number-ext', optional: true, integer: true, min: 0}),
  int64: (stringLongs) => ({type: stringLongs ? 'long-string': 'long'}),
  uint64: (stringLongs) => ({type: stringLongs ? 'long-string': 'long', nonNegative: true}),
  'google.protobuf.Value': () => ({type: 'any', optional: true}),
  'google.protobuf.Struct': () => ({type: 'object', optional: true}),
  'google.protobuf.Timestamp': () => ({type: 'date', optional: true}),
  'google.protobuf.FieldMask': () => ({type: 'repeated', items: 'string', optional: true}),
  'google.protobuf.Any': () => ({type: 'protobufAny'}),
  'google.protobuf.ListValue': () => ({type: 'repeated', optional: true}),
};

alias(SCALAR_VALIDATORS)
  .same('int32', 'fixed32', 'sfixed32', 'sint32', 'google.protobuf.Int32Value')
  .same('float', 'double', 'google.protobuf.FloatValue', 'google.protobuf.DoubleValue')
  .same('int64', 'fixed64', 'sfixed64', 'sint64', 'google.protobuf.Int64Value')
  .same('string', 'google.protobuf.StringValue')
  .same('bytes', 'google.protobuf.BytesValue')
  .same('bool', 'google.protobuf.BoolValue')
  .same('uint32', 'google.protobuf.UInt32Value')
  .same('uint64', 'google.protobuf.UInt64Value');

function oneofs(messageType) {
  return _(messageType.oneofs || {})
    .mapValues(({oneof: fields}) => ({fields, optional: true}))
    .value();
}

class SharedSchemas {

  constructor(schemaId = _.identity) {
    this._map = new Map();
    this._schemaId = schemaId;
  }

  createOrLink(messageType, path) {
    return factory => {
      const schemaId = this._schemaId(schemaIdFor(messageType), messageType, path.clone()).replace(/\./g, '_');
      if (!this._map.has(schemaId)) {
        const schema = {};
        this._map.set(schemaId, schema);
        return Object.assign(schema, factory());
      } else {
        return this._map.get(schemaId);
      }
    };
  }
}

function forMessage(messageType, {stringEnums, stringLongs, schemaId, decorator} = {}) {
  const path = Path.root;
  const schemas = new SharedSchemas(schemaId);

  function decorate(name) {
    return (schema, reflectionObject) => {
      let result;
      if (decorator && schema && decorator[name]) {
        result = decorator[name](schema, path.clone(), reflectionObject);
      }
      return result || schema;
    };
  }

  const decorateField = decorate('afterField');
  const decorateCollection = decorate('afterCollectionField');
  const decorateOneOf = decorate('afterOneOf');

  function forTypeOrEnum(type) {
    const ctor = type && type.constructor.name;
    switch (ctor) {
      case 'Enum':
        return forEnum(type);
      case 'Type':
        return schemas.createOrLink(type, path)(() => decorateOneOf({type: 'object-with-oneof', props: forType(type), optional: true, oneofs: oneofs(type)}));
      default:
    }
  }

  function unsupported(reflectionObject) {
    throw new Error(`cannot generate schema for ${reflectionObject} at ${path.valueOf()}`);
  }

  function forEnum(enumType) {
    let valid;
    switch (stringEnums) {
      case true:
        valid = Object.keys(enumType.values);
        break;
      case false:
        valid = Object.values(enumType.values);
        break;
      default:
        valid = [...Object.values(enumType.values), ...Object.keys(enumType.values)];
    }
    return {type: 'enum', values: valid, optional: true};
  }

  function forField(field) {
    return path.shift(field.partOf, field)(() => {
      let validator = decorateField(forScalar(field) || forTypeOrEnum(field.resolvedType) || unsupported(field), field);
      if (field.repeated) {
        validator = decorateCollection({type: 'repeated', items: validator, optional: true}, field);
      } else if (field.map) {
        validator = decorateCollection({type: 'map', optional: true, key: field.keyType, items: validator}, field);
      }
      return validator;
    });
  }

  function forScalar(field) {
    const getValidator = SCALAR_VALIDATORS[field.type];
    return getValidator && getValidator(stringLongs);
  }

  function forAdaptedType(messageType) {
    const getValidator = SCALAR_VALIDATORS[util.fqn(messageType)];
    return getValidator && getValidator(stringLongs);
  }

  function forCompositeType(messageType) {
    return messageType.fieldsArray.reduce((acc, field) => ({
      ...acc,
      [field.name]: forField(field)
    }), {});
  }

  function forType(messageType) {
    messageType.resolveAll();
    return forAdaptedType(messageType) || forCompositeType(messageType);
  }

  const props = forType(messageType);
  if (WRAPPER_TYPES.has(util.fqn(messageType))) {
    return {$$root: true, ...props};
  } else {
    return decorateOneOf({$$root: true, type: 'object-with-oneof', props, optional: true, oneofs: oneofs(messageType)});
  }
}

module.exports = {forMessage, validator};
