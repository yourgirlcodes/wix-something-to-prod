const pbjs = require('@wix/wnp-protobufjs');
const assert = require('assert');
const wixValidationsFactory = require('./lib/wix-validations');
const {forMessage, validator} = require('./lib/structure');
const {Path} = require('./lib/util');
const {AssertionError} = require('assert');
const {inspect} = require('util');

class SchemaBuilder {

  constructor(opts) {
    this.opts = opts;
  }

  forMethod(method) {
    validateMethod(method);
    const methodObject = method.__proto(pbjs).resolve();
    const options = resolveProtoCodegenOptions(method);

    return forMessage(methodObject.resolvedRequestType, {
      ...wixValidationsFactory(Path.fromReflectionObject(methodObject)),
      ...options
    });
  }

  forMessageProto(messageType, {stringEnums, stringLongs} = {}) {
    const opts = {stringEnums, stringLongs, schemaBuilder: this};

    if (this.opts.wixValidations) {
      Object.assign(opts, wixValidationsFactory());
    }
    return forMessage(messageType, opts);
  }

  forMessageClass(clazz) {
    const messageType = clazz.prototype.__proto(pbjs);
    const options = resolveProtoCodegenOptions(clazz);
    return this.forMessageProto(messageType, options);
  }
}

function validateMethod(method) {
  assert(typeof method === 'function' && typeof method.__proto === 'function', 'generated method from prototype is required');
}

function resolveProtoCodegenOptions(construct) {
  if (construct._messageTypes) {
    construct = construct._messageTypes()[0];
  }

  const opts = construct.prototype.__options__;

  return opts && {
    stringEnums: opts.stringEnums,
    stringLongs: opts.stringLongs,
  };
}

function attempt(schema, value, opts = {}) {
  const check = typeof schema === 'function' ? schema : validator.compile(schema);
  const result = check(value);
  if (Array.isArray(result)) {
    const message = result.map(({message, actual}) => `${message}, got ${inspect(actual)}`).join('. ');
    const err = opts.error ? new opts.error((opts.prefix || '') + message) : new AssertionError({message, expected: value}); // eslint-disable-line new-cap
    Object.assign(err, {details: result});
    throw err;
  } else {
    return value;
  }
}

module.exports = {SchemaBuilder, validator, attempt};
