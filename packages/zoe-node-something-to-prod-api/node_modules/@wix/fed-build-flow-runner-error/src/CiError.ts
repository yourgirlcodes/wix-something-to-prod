import { VError, Info, MultiError } from 'verror'

export { Info }

export enum ErrorKind {
  userError = 'userError',
  systemError = 'systemError',
  recoverableError = 'recoverableError',
}

export class CiError extends VError {
  readonly kind: ErrorKind
  constructor(options: { name?: string; error?: unknown; message: string; info?: Info; kind?: ErrorKind }) {
    const cause =
      options.error !== undefined
        ? options.error instanceof Error
          ? options.error
          : new Error(`Unknown error object: ${options.error}`)
        : undefined
    super({ cause, info: options.info }, options.message)
    this.kind = kind(cause, options.kind)
    // Reason for setting the message: VError creates a concatenated message of all causes
    // For example: failed to download file: server error: http error 500
    // These messages are not static (can include arbitrary text), and thus mess up sentry issue grouping
    // Therefore we re-set the message to be the one we got, without the causes messages.
    this.message = options.message
    if (this.constructor.name === 'CiError') {
      this.name = options.name || 'UnnamedError'
    } else {
      this.name = this.constructor.name
    }
  }
}

export class CiMultiError extends MultiError {
  readonly kind: ErrorKind
  constructor(options: { name?: string; errors: unknown[]; info?: Info }) {
    const errors = options.errors.map((e) =>
      e instanceof Error ? e : new CiError({ message: 'Unknown error object', error: e }),
    )
    super(errors)
    this.kind = multiKind(errors)
    if (this.constructor.name === 'CiMultiError') {
      this.name = options.name || 'UnnamedError'
    } else {
      this.name = this.constructor.name
    }
  }
}

export function isCiError(e: unknown): e is CiError | CiMultiError {
  return e instanceof CiError || e instanceof CiMultiError
}

export function extractCiErrors(e: CiError | CiMultiError, errorKind?: ErrorKind): CiError[] {
  if (e instanceof CiError) {
    return errorKind === undefined || e.kind === errorKind ? [e] : []
  }
  if (e instanceof CiMultiError) {
    return flatMap(e.errors(), (e) => (isCiError(e) ? extractCiErrors(e, errorKind) : []))
  }
  return []
}

export interface GroupedErrors {
  userErrors: CiError[]
  systemErrors: unknown[]
}

export function groupByErrorKind(e: unknown): GroupedErrors {
  if (isCiError(e)) {
    if (e instanceof CiError) {
      return e.kind === ErrorKind.userError
        ? { userErrors: [e], systemErrors: [] }
        : { userErrors: [], systemErrors: [e] }
    }
    if (e instanceof CiMultiError) {
      return e.errors().reduce(
        (acc: GroupedErrors, error) => {
          const nestedGrouping = groupByErrorKind(error)
          return {
            userErrors: [...acc.userErrors, ...nestedGrouping.userErrors],
            systemErrors: [...acc.systemErrors, ...nestedGrouping.systemErrors],
          }
        },
        { userErrors: [], systemErrors: [] },
      )
    }
  }

  return { userErrors: [], systemErrors: [e] }
}

export function getErrorMessages(error: Error | CiError | CiMultiError) {
  const messages: string[] = []
  VError.errorForEach(error, ({ message }) => messages.push(message))
  return messages
}

export const errorForEach = VError.errorForEach
export const getFullStack = (initialError: unknown) => {
  const error = initialError instanceof Error ? initialError : new Error(`Unknown error object: ${initialError}`)
  return VError.fullStack(error)
}
export const getInfo = (initialError: unknown) => {
  const error = initialError instanceof Error ? initialError : new Error(`Unknown error object: ${initialError}`)
  return VError.info(error)
}

export function getTags(error: CiError) {
  const info = getInfo(error)
  return info.tags ?? {}
}

export function kind(error?: Error, errorKind?: ErrorKind) {
  return errorKind ? errorKind : isCiError(error) ? error.kind : ErrorKind.systemError
}

function multiKind(errors: Error[]) {
  const kinds = errors.map((e) => (isCiError(e) ? e.kind : ErrorKind.systemError))
  if (kinds.some((k) => k === ErrorKind.systemError)) {
    return ErrorKind.systemError
  }
  if (kinds.every((k) => k === ErrorKind.recoverableError)) {
    return ErrorKind.recoverableError
  }

  return ErrorKind.userError
}

// Our compilation target is ES2015 which doesn't include flatMap
function flatMap<T, U>(arr: Array<T>, cb: (item: T) => U[]): U[] {
  return arr.reduce<U[]>((acc, item) => acc.concat(cb(item)), [])
}
