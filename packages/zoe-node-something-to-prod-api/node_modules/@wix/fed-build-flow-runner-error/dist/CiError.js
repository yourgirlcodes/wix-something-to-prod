"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.kind = exports.getTags = exports.getInfo = exports.getFullStack = exports.errorForEach = exports.getErrorMessages = exports.groupByErrorKind = exports.extractCiErrors = exports.isCiError = exports.CiMultiError = exports.CiError = exports.ErrorKind = void 0;
const verror_1 = require("verror");
var ErrorKind;
(function (ErrorKind) {
    ErrorKind["userError"] = "userError";
    ErrorKind["systemError"] = "systemError";
    ErrorKind["recoverableError"] = "recoverableError";
})(ErrorKind = exports.ErrorKind || (exports.ErrorKind = {}));
class CiError extends verror_1.VError {
    constructor(options) {
        const cause = options.error !== undefined
            ? options.error instanceof Error
                ? options.error
                : new Error(`Unknown error object: ${options.error}`)
            : undefined;
        super({ cause, info: options.info }, options.message);
        this.kind = kind(cause, options.kind);
        // Reason for setting the message: VError creates a concatenated message of all causes
        // For example: failed to download file: server error: http error 500
        // These messages are not static (can include arbitrary text), and thus mess up sentry issue grouping
        // Therefore we re-set the message to be the one we got, without the causes messages.
        this.message = options.message;
        if (this.constructor.name === 'CiError') {
            this.name = options.name || 'UnnamedError';
        }
        else {
            this.name = this.constructor.name;
        }
    }
}
exports.CiError = CiError;
class CiMultiError extends verror_1.MultiError {
    constructor(options) {
        const errors = options.errors.map((e) => e instanceof Error ? e : new CiError({ message: 'Unknown error object', error: e }));
        super(errors);
        this.kind = multiKind(errors);
        if (this.constructor.name === 'CiMultiError') {
            this.name = options.name || 'UnnamedError';
        }
        else {
            this.name = this.constructor.name;
        }
    }
}
exports.CiMultiError = CiMultiError;
function isCiError(e) {
    return e instanceof CiError || e instanceof CiMultiError;
}
exports.isCiError = isCiError;
function extractCiErrors(e, errorKind) {
    if (e instanceof CiError) {
        return errorKind === undefined || e.kind === errorKind ? [e] : [];
    }
    if (e instanceof CiMultiError) {
        return flatMap(e.errors(), (e) => (isCiError(e) ? extractCiErrors(e, errorKind) : []));
    }
    return [];
}
exports.extractCiErrors = extractCiErrors;
function groupByErrorKind(e) {
    if (isCiError(e)) {
        if (e instanceof CiError) {
            return e.kind === ErrorKind.userError
                ? { userErrors: [e], systemErrors: [] }
                : { userErrors: [], systemErrors: [e] };
        }
        if (e instanceof CiMultiError) {
            return e.errors().reduce((acc, error) => {
                const nestedGrouping = groupByErrorKind(error);
                return {
                    userErrors: [...acc.userErrors, ...nestedGrouping.userErrors],
                    systemErrors: [...acc.systemErrors, ...nestedGrouping.systemErrors],
                };
            }, { userErrors: [], systemErrors: [] });
        }
    }
    return { userErrors: [], systemErrors: [e] };
}
exports.groupByErrorKind = groupByErrorKind;
function getErrorMessages(error) {
    const messages = [];
    verror_1.VError.errorForEach(error, ({ message }) => messages.push(message));
    return messages;
}
exports.getErrorMessages = getErrorMessages;
exports.errorForEach = verror_1.VError.errorForEach;
const getFullStack = (initialError) => {
    const error = initialError instanceof Error ? initialError : new Error(`Unknown error object: ${initialError}`);
    return verror_1.VError.fullStack(error);
};
exports.getFullStack = getFullStack;
const getInfo = (initialError) => {
    const error = initialError instanceof Error ? initialError : new Error(`Unknown error object: ${initialError}`);
    return verror_1.VError.info(error);
};
exports.getInfo = getInfo;
function getTags(error) {
    var _a;
    const info = (0, exports.getInfo)(error);
    return (_a = info.tags) !== null && _a !== void 0 ? _a : {};
}
exports.getTags = getTags;
function kind(error, errorKind) {
    return errorKind ? errorKind : isCiError(error) ? error.kind : ErrorKind.systemError;
}
exports.kind = kind;
function multiKind(errors) {
    const kinds = errors.map((e) => (isCiError(e) ? e.kind : ErrorKind.systemError));
    if (kinds.some((k) => k === ErrorKind.systemError)) {
        return ErrorKind.systemError;
    }
    if (kinds.every((k) => k === ErrorKind.recoverableError)) {
        return ErrorKind.recoverableError;
    }
    return ErrorKind.userError;
}
// Our compilation target is ES2015 which doesn't include flatMap
function flatMap(arr, cb) {
    return arr.reduce((acc, item) => acc.concat(cb(item)), []);
}
//# sourceMappingURL=CiError.js.map