syntax = "proto3";

package com.wix.bookings.schedules.api.v1;

import "wix/api/validations.proto";
import "google/api/annotations.proto";
import "wix/api/callback.proto";
import "wix/api/annotations.proto";
import "google/protobuf/wrappers.proto";
import "com/wix/bookings/common/api/v1/entities/error.proto";
import "com/wix/bookings/common/api/v1/entities/location.proto";
import "com/wix/bookings/schedules/api/v1/entities/participantNotification.proto";
import "com/wix/bookings/schedules/api/v1/entities/schedule.proto";
import "com/wix/bookings/schedules/api/v1/entities/session.proto";
import "com/wix/bookings/schedules/api/v1/entities/participant.proto";
import "com/wix/bookings/schedules/api/v1/entities/properties/recurringInterval.proto";
import "com/wix/bookings/schedules/api/v1/entities/extendedSession.proto";
import "com/wix/bookings/schedules/api/v1/entities/scheduleWithHistory.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "wix/common/query.proto";
import "wix/common/paging.proto";
import "wix/http/field_mask.proto";


/*    >>>>>>>>>>>>>> NO LONGER MAINTAINED IN THE PROTO. PLease see the Velo JSDocs for the most uptodate version<<<<<<<<<<<<<
A schedule is a collection of sessions and the metadata to calculate availability. A schedule is owned by either a service or a resource as specified in the `scheduleOwnerId` property.
Schedules contain metadata for the following areas:
+ Availability
+ Pricing
+ Location
+ Participants
+ Conference calls
Schedules are owned by either resources or services, so not all metadata is relevant to both.
The schedule `availability` object holds the metadata to calculate availability. This is used in combination with sessions owned by the schedule to calculate available slots. The availability object contains an array of `linkedSchedules`. This array contains a list of other schedules that are impacted by this schedule’s availability. The `transparency` string defines how the linked schedules’ availability is affected. When `transparency` is set to `”FREE` the linked schedules’ availabilities are not affected when this schedule has a session. When set to `”BUSY”` the linked schedules have no available slots during this schedule’s sessions.
For example, there are two services, math tutoring and science tutoring, and they are both offered by a tutor called John.
In John’s resource’s schedule in the `liknedSchedules` array, we have both schedule IDs of the math service and the science service.
Both have transparency `”BUSY”`. When the math service is booked between 3 and 4pm, a session is created for John’s schedule for that time. The science service’s schedule is in John’s list of linked schedules. When availability is calculated for the science service, there will be no slots available between 3 and 4pm, because John is teaching math.

Tags are used for grouping schedules and for specific functions in the Wix Bookings app.
The Wix Bookings app uses the following predefined tags to set schedule types for services: 
`"INDIVIDUAL"`, `"GROUP"`, and `"COURSE”` for appointments, classes and courses. Once the schedule type is set using these tags, you cannot update it.
 In addition to the app's tags, you can create and update tags for your own use.
Some data defined in the  **Settings** page is inherited by the schedule by default. Inherited fields are:
+ location.businessLocation  from the **Business Info** page.
+ availability.constraints.slotsSplitInterval from the **Appointment Time Slots** section in the **Bookings Policy** page
The `inheritedFields` property lists the fields that were inherited from the **Business Info** page.
*/
service Schedules {

  //Creates a schedule
  //  <!--ONLY:VELO
  //  The `createSchedule()` function returns a Promise that resolves when a schedule is created
  // <!--END:ONLY:VELO-->
  // <!--ONLY:REST-->
  //> **Permissions**
  //> This endpoint requires the Manage Bookings permissions scope
  // <!--END:ONLY:REST-->
    rpc Create (CreateScheduleRequest) returns (CreateScheduleResponse) {
        option (.wix.api.required) = "CreateScheduleRequest.schedule";
        option (.wix.api.required) = "CreateScheduleRequest.schedule.schedule_owner_id";
        option (.wix.api.required) = "CreateScheduleRequest.schedule.intervals.start";
        option (.wix.api.required) = "CreateScheduleRequest.schedule.availability.start";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
        option (google.api.http) = {
            post : "/v1/calendar/schedules"
        };
    }

    rpc BatchCreate (BatchCreateScheduleRequest) returns (BatchCreateScheduleResponse) {
        option (.wix.api.exposure) = PRIVATE;
        option deprecated = true;
    }

    /*
    Updates a schedule.
    This method supports patch semantics. The field values you specify replace the existing values.
    Fields that you don’t specify in the request remain unchanged.
    Array fields, if specified, overwrite the existing arrays, and therefore discards any previous array elements.
    The `availability.locations` array cannot be updated. Please use the `setAvailabilityLocations` endpoint instead.
    > **Permissions**
    > This endpoint requires the Manage Bookings permissions scope
    */
    rpc Update (UpdateScheduleRequest) returns (UpdateScheduleResponse) {
        option (.wix.api.required) = "UpdateScheduleRequest.schedule.id";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
        option (google.api.http) = {
            patch : "/v1/calendar/schedules/{schedule.id}"
        };
    }

    //Cancels a schedule. Equivalent to batch cancel of sessions linked to a single schedule.
    //The schedule changes to status = CANCELED -  all sessions up until the time of cancellation are kept, and all future sessions are removed.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc Cancel (CancelScheduleRequest) returns (CancelScheduleResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "CancelScheduleRequest.schedule_id";
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
        };
        option (google.api.http) = {
            post : "/v1/calendar/schedules/{schedule_id}/cancel"
        };
    }

    //Cancels multiple schedules.
    //By applying this method, the given schedule move to a CANCELLED status which means that all sessions up until.
    //the cancellation point in time are kept, while removing all following sessions.
    rpc BatchCancel (BatchCancelScheduleRequest) returns (BatchCancelScheduleResponse) {
        option deprecated = true;
        option (.wix.api.exposure) = PRIVATE;
        option (.wix.api.required) = "BatchCancelScheduleRequest.requests";
        option (.wix.api.required) = "BatchCancelScheduleRequest.requests.schedule_id";
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"

       };
    }

    //Create update and cancel multiple schedules.
    rpc Batch (BatchRequest) returns (BatchResponse) {
        option (.wix.api.maturity) = BETA;
        option (.wix.api.exposure) = INTERNAL;
        option (.wix.api.required) = "BatchRequest.create_requests.schedule.schedule_owner_id";
        option (.wix.api.required) = "BatchRequest.create_requests.schedule.intervals.start";
        option (.wix.api.required) = "BatchRequest.create_requests.schedule.availability.start";
        option (.wix.api.required) = "BatchRequest.update_requests.schedule.id";
        option (.wix.api.required) = "BatchRequest.cancel_requests.schedule_id";
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
       };
    }

    /*Gets a schedule from the calendar.
    <!--ONLY:VELO
    The `getSchedule()` function returns a Promise that resolves to a schedule.
    Use `getSchedule()` to get a specific schedule based on the schedule Id.
    <!--END:ONLY:VELO-->
    <!--ONLY:REST-->
    > **Permissions**
    > This endpoint requires the Read Bookings Calendar or the Manage Bookings permissions scope.
    > With the Read Bookings Calendar permission scope, the schedule participants are not returned.
    <!--END:ONLY:REST-->
    */
    rpc Get (GetScheduleRequest) returns (GetScheduleResponse) {
        option (.wix.api.required) = "GetScheduleRequest.id";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            get : "/v1/calendar/schedules/{id}"
        };
    }

    //Lists schedules by schedule IDs or schedule owner IDs.
    //<!--ONLY:REST-->
    //> **Permissions**
    //> This endpoint requires the Read Bookings Calendar or the Manage Bookings permission scope.
    //> With the Read Bookings Calendar permission scope, the schedule participants are not returned.
    //<!--END:ONLY:REST-->
    rpc List (ListSchedulesRequest) returns (ListSchedulesResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            get : "/v1/calendar/schedules"
        };
    }

    //Returns a list of schedules matching to the provided query object.
    //The returned list will be ordered by `data->"$.lastModified"` desc.
    //
    //**Query object**:
    //
    //- **fieldset**: supports
    //  - `participants`: Includes the schedule's participants
    //    - Example: `"fieldset": ["participants"]`
    //- **cursorPaging**: supported.
    //  - Example: `"cursorPaging": { "limit": 50, "cursor": "1614162166479" }`
    //- **fields**: not supported.
    //- **filter**: not supported.
    //
    //> **Permissions**
    //> This endpoint requires the Manage Schedules permissions scope
    rpc QuerySchedules (QuerySchedulesRequest) returns (QuerySchedulesResponse) {
        option (.wix.api.required) = "QuerySchedulesRequest.query";
        option (.wix.api.exposure) = PRIVATE;
        option (.wix.api.maturity) = ALPHA;
        option (google.api.http) = {
            post : "/v1/calendar/schedules/query"
        };
    }

    //Returns a list of schedules history matching to the provided query object.
    //The returned list will be ordered by `data->"$.lastModified"` desc.
    //
    //**Query object**:
    //
    //- **fieldset**: supports
    //  - `participants`: Includes the schedule's participants
    //    - Example: `"fieldset": ["participants"]`
    //- **cursorPaging**: supported.
    //  - Example: `"cursorPaging": { "limit": 50, "cursor": "1614162166479" }`
    //- **fields**: not supported.
    //- **filter**: not supported.
    //
    //> **Permissions**
    //> This endpoint requires the Manage Schedules permissions scope
    rpc QuerySchedulesHistory (QuerySchedulesHistoryRequest) returns (QuerySchedulesHistoryResponse) {
        option (.wix.api.required) = "QuerySchedulesHistoryRequest.query";
        option (.wix.api.exposure) = PRIVATE;
        option (.wix.api.maturity) = ALPHA;
        option (google.api.http) = {
            post : "/v1/calendar/schedulesHistory/query"
        };
    }

    /*
    >>>>>>>>>>>>>> NO LONGER MAINTAINED IN THE PROTO. PLease see the Velo JSDocs for the most uptodate version<<<<<<<<<<<<<
    Sessions
    A session is an occupied period of time on a schedule or period of availability on a resource's schedule.
    A session is owned by a schedule which in turn has an owner. The owner of a session's schedule can be a service or a resource.
    Sessions can be of type `"WORING_HOURS"` or `"EVENT"`. A session with type `"WORING_HOURS"` defines the availability of a resource.
    A session with type `"EVENT"` creates an event on the calendar for the owner of the schedule that the session belongs to.

    Session may be individual sessions or recurring sessions.
    An individual session has a discrete start and end date. A recurring session defines a series of repeating sessions.
    The recurrence is defined using a subset of [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html)s.

    The following RRULE parameters are supported:

    |Keyword|Description|Supported values|
    |--|--|---|
    |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
    |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
    |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
    |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|

    For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
    `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`

    A session includes an optional list of `affectedSchedules`. This is a list of linked schedules and the way each schedule's    availability is affected. For example, the schedule of an instructor is linked to the session for the class that they instruct.

    Sessions have tags that can be used to group sessions. Tags are also used by the Wix Bookings app. The tag `"Blocked"` is used to create a session that blocks the resource's availability but is not related to a service. Use this tag to schedule non-working hours where the resource is not available. The `"Google_Event"` tag is used by the app for events created by Google applications. These events are read-only.

    Sessions inherit information from the schedules that they belong to.
    The following lists which session properties are inherited from the schedule.

    + `affectedSchedules`, from Schedule.availability.linkedSchedules
    + `title`
    + `tags`
    + `location`
    + `capacity`
    + `rate`

    Inherited properties can be overridden for each session unless the session is a recurring session.
 */


  //  Creates a session.
  //  A session is an occupied period of time on a schedule or period of availability on a resource's schedule.
  //  <!--ONLY:VELO
  //  The `createSession()` function returns a Promise that resolves when a session is created.
  //  <!--END:ONLY:VELO-->
  //
  //Session may be individual sessions or recurring sessions.
  //  An individual session has a discrete start and end date. A recurring session defines a series of repeating sessions.
  //  The recurrence is defined using a subset of [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html)s.
  //
  //  Session can be owned by resources or services. Set `type` to `"WORING_HOURS"` when creating sessions for resource availability. Set `type` to `"EVENT"` when creating sessions owned by a service's schedule,
  //
  //  The session `start` and `end` properties set the time and duration of the session. For non-recurring sessions, `timestamp` or `localDateTime` properties can be used. For recurring sessions, use the `localDateTime` property only. For recurring sessions, the `start` property sets the date and time of the first recurring session, subject to the recurrence rule. The `year`, `monthOfYear` and `dayOfMonth` properties in the `end` property are used  with the `hourOfDay` and `minutesOfHour` properties to set the duration of the session relative to the `start`.
  //  The `UNTIL` keyword in the `recurrence` property sets the date for the last recurring session.
  //
  //  You can create a session that blocks hours on the resource's calendar making the resource unavailable.
  //  Create a either recurring or non-recurring sessions of type `"EVENT"`, and add `"Blocked"` to the `tags` array.
  //
  //  For recurring availability sessions, the following properties must be populated:
  //
  //  + scheduleId
  //  + start
  //  + end
  //  + type
  //  + recurrence
  //
  //  <!--ONLY:REST-->
  //  > **Permissions**
  //  > This endpoint requires the Manage Bookings permissions scope
  //  <!--END:ONLY:REST-->
  //  <!--ONLY:VELO
  //  @snippet [createSession.es6=Create a session.]
  //  @snippet [createSession.es6=Create a recurring session for a resource.]
  //  <!--END:ONLY:VELO-->

    rpc CreateSession (CreateSessionRequest) returns (CreateSessionResponse) {
        option (.wix.api.required) = "CreateSessionRequest.session";
        option (.wix.api.required) = "CreateSessionRequest.session.schedule_id";
        option (.wix.api.required) = "CreateSessionRequest.session.start";
        option (.wix.api.required) = "CreateSessionRequest.session.end";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
        option (google.api.http) = {
            post : "/v1/calendar/sessions"
        };
    }

    //Updates a session.
    //<!--ONLY:VELO
    // The `updateSession()` function returns a Promise that resolves when the session has been updated.
    //<!--END:ONLY:VELO-->
    //The property values specified replace the existing values. If a property is not specified in the request it will remain unchanged.
    //Array properties, if specified, overwrite the existing array and all of its elements.
    //The `participants` array cannot be updated.
    //Use the participantNotification property to send an email to the participants notifying them of the change.
    //<!--ONLY:REST-->
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    //<!--END:ONLY:REST-->
    rpc UpdateSession (UpdateSessionRequest) returns (UpdateSessionResponse) {
        option (.wix.api.required) = "UpdateSessionRequest.session";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            patch : "/v1/calendar/sessions/{session.id}"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    /*
    Deletes a session from a schedule.
    <!--ONLY:VELO
    The `deleteSession()` function returns a Promise that resolves to a session Id when the session has been deleted.
    <!--END:ONLY:VELO-->
    Use the `participantNotification` property to send an email to the participants when the session is deleted.

    When deleting a session of type `"EVENT"` where a booking exists, the booking's status is updated to `"CANCELED"`.

    To delete a set of recurring sessions, specify the session's `recurringSessionId` in the `sessionId` property of the request parameters.
    <!--ONLY:REST-->
    > **Permissions**
    > This endpoint requires the Manage Bookings permissions scope
    <!--END:ONLY:REST-->
    <!--ONLY:REST-->
    @snippet [deleteSession.es6=Delete a session.]
    <!--END:ONLY:REST-->
    */
    rpc DeleteSession (DeleteSessionRequest) returns (DeleteSessionResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "DeleteSessionRequest.id";
        option (google.api.http) = {
            post : "/v1/calendar/sessions/{id}/cancel"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    //Create, Update, and Delete multiple sessions in a single request.
    //All sessions must belong to the same schedule.
    //Currently only supported for recurring sessions.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc SessionBatch (SessionBatchRequest) returns (SessionBatchResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            post : "/v1/calendar/sessions/batch"
        };
    }

    //Returns a session from the calendar.
    //> **Permissions**
    //> This endpoint requires the Read Bookings Calendar or the Manage Bookings permission scope.
    //> With the Read Bookings Calendar permission scope, the session participants are not returned.
    rpc GetSession (GetSessionRequest) returns (GetSessionResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "GetSessionRequest.id";
        option (google.api.http) = {
            get : "/v1/calendar/sessions/{id}"
        };
    }

    //Returns multiple sessions from the calendar.
    //> **Permissions**
    //> This endpoint requires the Read Bookings Calendar or the Manage Bookings permission scope
    //> With the Read Bookings Calendar permission scope, the sessions return without participants.
    rpc ListSessions (ListSessionsRequest) returns (ListSessionsResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            post : "/v1/calendar/sessions/list"
        };
    }

    //Returns a list of concrete sessions matching to the provided query object.
    //The returned list will be ordered by session ID desc.
    //
    //**Query object**:
    //
    //- **cursorPaging**: supported.
    //  - Example: `"cursorPaging": { "limit": 50, "cursor": "1614162166479" }`
    //- **fieldset**: not supported.
    //- **fields**: not supported.
    //- **filter**: not supported.
    //
    //> **Permissions**
    //> This endpoint requires the Manage Schedules permissions scope
    rpc QueryConcreteSessions (QueryConcreteSessionsRequest) returns (QueryConcreteSessionsResponse) {
        option (.wix.api.required) = "QueryConcreteSessionsRequest.query";
        option (.wix.api.exposure) = PRIVATE;
        option (.wix.api.maturity) = ALPHA;
        option (google.api.http) = {
            post : "/v1/calendar/concreteSessions/query"
        };
    }

    //Returns multiple sessions from the calendar. Only recurring sessions are currently supported.
    //
    //- **filter**: supports
    //  - `recurrence`: Filter for the existence of the `session.recurrence`. Currently required and must be `true`.
    //  - `scheduleId`: Filter by `session.schedule_id`. Supports multiple values. Up to 100 values are allowed. Optional.
    //  - `location`: Filter for the existence of the `session.location`. Can be combined with other `location` filters. Optional.
    //  - `location.locationType`: Filter by `session.location.location_type`. Supports multiple values. Possible values are `OWNER_BUSINESS`, `OWNER_CUSTOM` and `CUSTOM`. Optional.
    //  - `location.businessLocation.id`: Filter by `session.location.business_location.id`. Supports multiple values. Optional.
    //
    //> **Permissions**
    //> This endpoint requires the Read Bookings Calendar or the Manage Bookings permission scope
    //> With the Read Bookings Calendar permission scope, the sessions return without participants.
    rpc QuerySessions (QuerySessionsRequest) returns (QuerySessionsResponse) {
        option (.wix.api.required) = "QuerySessionsRequest.query";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = ALPHA;
        option (google.api.http) = {
            post : "/v1/calendar/sessions/query"
        };
    }

    //Adds a participant to a schedule.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc AddParticipant (AddParticipantRequest) returns (AddParticipantResponse) {
        option (.wix.api.required) = "AddParticipantRequest.schedule_id";
        option (.wix.api.required) = "AddParticipantRequest.participant";
        option (.wix.api.required) = "AddParticipantRequest.participant.id";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            post : "/v1/calendar/participants"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    //Adds a participant to a session.
    //<!--ONLY:REST-->
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    //<!--END:ONLY:REST-->
    rpc AddParticipantToSession(AddParticipantToSessionRequest) returns (AddParticipantToSessionResponse) {
        option (.wix.api.required) = "AddParticipantToSessionRequest.session_id";
        option (.wix.api.required) = "AddParticipantToSessionRequest.participant";
        option (.wix.api.required) = "AddParticipantToSessionRequest.participant.id";
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (google.api.http) = {
            post : "/v1/calendar/sessions/{session_id}/participants"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    //Updates participant details.
    // The field values you specify replace the existing values. Fields that you don’t specify in the request remain unchanged.
    //Array fields, if specified, overwrite the existing arrays; this discards any previous array elements.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc UpdateParticipant (UpdateParticipantRequest) returns (UpdateParticipantResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "UpdateParticipantRequest.participant";
        option (.wix.api.required) = "UpdateParticipantRequest.participant.id";
        option (google.api.http) = {
            patch : "/v1/calendar/participants/{participant.id}"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    //Removes a participant from a schedule or from a specific session.
    //Note: Currently, removing *participants that have been inherited from a schedule* from a specific session, is not supported.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc RemoveParticipant (RemoveParticipantRequest) returns (RemoveParticipantResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "RemoveParticipantRequest.id";
        option (google.api.http) = {
            delete : "/v1/calendar/participants/{id}"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
           permission: "CALENDAR.READ_SCHEDULES_SESSIONS_WITH_PARTICIPANTS"
       };
    }

    //Sets the schedule's availability locations.
    //
    //Future sessions of a removed location can be deleted, or moved to a different location.
    //The schedule must contain availability (`schedule.availability`).
    //The `schedule.availability.useDefaultLocation` field will be automatically set to `false`.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc SetAvailabilityLocations (SetAvailabilityLocationsRequest) returns (SetAvailabilityLocationsResponse) {
        option (.wix.api.exposure) = INTERNAL;
        option (.wix.api.maturity) = ALPHA;
        option (.wix.api.required) = "SetAvailabilityLocationsRequest.schedule_id";
        option (google.api.http) = {
            post : "/v1/calendar/schedules/{schedule_id}/setAvailabilityLocations"
        };
    }

    //Splits an existing interval into two or more parts.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc SplitInterval (SplitIntervalRequest) returns (SplitIntervalResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "SplitIntervalRequest.schedule_id";
        option (.wix.api.required) = "SplitIntervalRequest.interval_id";
        option (.wix.api.required) = "SplitIntervalRequest.split_times";
        option (google.api.http) = {
            post : "/v1/calendar/intervals/{interval_id}/split"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
       };
       option deprecated = true;
    }

    //Splits a recurring session into two or more parts.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    rpc SplitRecurringSession (SplitRecurringSessionRequest) returns (SplitRecurringSessionResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "SplitRecurringSessionRequest.recurring_session_id";
        option (.wix.api.required) = "SplitRecurringSessionRequest.split_times";
        option (google.api.http) = {
            post : "/v1/calendar/sessions/{recurring_session_id}/split"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
       };
    }

    //Updates an existing recurring interval.
    //> **Permissions**
    //> This endpoint requires the Manage Bookings permissions scope
    //Deprecated. Please use UpdateSession instead.
    rpc UpdateInterval (UpdateIntervalRequest) returns (UpdateIntervalResponse) {
        option (.wix.api.exposure) = PUBLIC;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "UpdateIntervalRequest.schedule_id";
        option (.wix.api.required) = "UpdateIntervalRequest.interval";
        option (.wix.api.required) = "UpdateIntervalRequest.interval.id";
        option (google.api.http) = {
            post : "/v1/calendar/intervals/{interval.id}"
        };
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
        };
        option deprecated = true;
    }

    //Assign wix user to schedule owner id.
    rpc AssignWiXUserAsScheduleOwner (AssignWiXUserAsScheduleOwnerRequest) returns (AssignWiXUserAsScheduleOwnerResponse) {
        option (.wix.api.exposure) = INTERNAL;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "AssignWiXUserAsScheduleOwnerRequest.uid";
        option (.wix.api.required) = "AssignWiXUserAsScheduleOwnerRequest.schedule_owner_id";
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
       };
    }

    //remove wix user assignment from schedule owenr id.
    rpc UnAssignWiXUserFromScheduleOwner (UnAssignWiXUserFromScheduleOwnerRequest) returns (UnAssignWiXUserFromScheduleOwnerResponse) {
        option (.wix.api.exposure) = INTERNAL;
        option (.wix.api.maturity) = BETA;
        option (.wix.api.required) = "UnAssignWiXUserFromScheduleOwnerRequest.uid";
        option (.wix.api.required) = "UnAssignWiXUserFromScheduleOwnerRequest.schedule_owner_id";
        option (.wix.api.callback) = {
           topic: "bookings.schedules.notifications"
           payload: "ScheduleNotification"
       };
    }

    rpc Migrate (MigrateRequest) returns (MigrateResponse) {
        option (.wix.api.exposure) = PRIVATE;
    }
}

//schedule
message CreateScheduleRequest {
    Schedule schedule = 1; //Schedule.
}

message BatchCreateScheduleRequest {
    repeated Schedule schedules = 1; //Schedule.
}

message BatchCreateScheduleResponse {
    repeated Schedule schedules = 1; //Schedule.
}

message CreateScheduleResponse {
    Schedule schedule = 1; //Schedule.
    repeated com.wix.bookings.common.api.v1.Error errors = 2 [deprecated = true];
}

message UpdateScheduleRequest {
    // Schedule.
    Schedule schedule = 1;
    //Field mask of fields to update.
    google.protobuf.FieldMask fieldMask = 2 [(.wix.http.infer_fieldmask_from) = "schedule"];
    //Optional. Defaults to false. In case of updated intervals' start time, this field indicates whether to align those interval's time exceptions.
    bool align_time_exceptions = 3;
    //Deprecated, use participant_notification.
    bool notify_participants = 4 [deprecated = true];
    //Whether to notify participants about the change, and an optional custom message.
    ParticipantNotification participant_notification = 5;
}

message UpdateScheduleResponse {
    Schedule schedule = 1; //Schedule.
}

message DeleteScheduleRequest {
    string id = 1; //Schedule ID.
}

message DeleteScheduleResponse {
    string id = 1; // Schedule ID.
}

message BatchCancelScheduleRequest {
    repeated CancelScheduleRequest requests = 1;
}

message BatchCancelScheduleResponse {
    repeated Schedule schedules = 1; // Schedule.
}

message BatchRequest {
    //Create multiple schedules.
    repeated CreateScheduleRequest create_requests = 1;
    //Update multiple schedules. Not Supported yet.
    repeated UpdateScheduleRequest update_requests = 2;
    //Cancel multiple schedules.
    //The given schedules move to a CANCELLED status which means that all sessions up until
    //the cancellation point in time are kept, while removing all following sessions.
    repeated CancelScheduleRequest cancel_requests = 3;
}

message BatchResponse {
    repeated Schedule created = 1; //Created schedules.
    repeated Schedule updated = 2; //Updated schedules.
    repeated Schedule cancelled = 3; //Cancelled schedules.
}

message CancelScheduleRequest {
    string schedule_id = 1; //Schedule ID.
    google.protobuf.Timestamp from = 2; //Time to cancel the sessions from. Optional. If this field is empty, all of this schedule's sessions will be canceled.
    bool preserve_future_sessions_with_participants = 3; //Whether to preserve future sessions with reservations. Defaults to false.
    bool notify_participants = 4 [deprecated = true]; // Deprecated, use participant_notification
    ParticipantNotification participant_notification = 5; // Whether to notify participants about the change, and an optional custom message.
}

message CancelScheduleResponse {
    Schedule schedule = 1; //Schedule.
}

message GetScheduleRequest {
    string id = 1; //Schedule ID.
}

message GetScheduleResponse {
    Schedule schedule = 1; // Schedule.
}

message ListSchedulesRequest {
    repeated string schedule_ids = 1; //List by schedule IDs.
    repeated string schedule_owner_ids = 2; //List by schedule owner IDs.
    bool dont_include_schedule_participants = 3; //Whether to return a list of the schedule's participants.
}

message ListSchedulesResponse {
    repeated Schedule schedules = 1; // Schedule.
}

//Schedule's session
message CreateSessionRequest {
    Session session = 1; //Session.
    google.protobuf.FieldMask deleted = 2; //List of fields that do not inherit values from the schedule when they are empty. Not supported for recurring sessions.
}

message CreateSessionResponse {
    Session session = 1; //Session.
}
message UpdateSessionRequest {
    Session session = 1; //Session.
    google.protobuf.FieldMask updated = 2 [(.wix.http.infer_fieldmask_from) = "session"]; //Field mask of fields to update. Not supported for recurring sessions.
    google.protobuf.FieldMask deleted = 3; //List of fields that do not inherit values from the schedule when they are empty. Not supported for recurring sessions.
    bool notify_participants = 4 [deprecated = true]; // Deprecated. Use participant_notification.
    ParticipantNotification participant_notification = 5; // Whether to notify participants about the change, and an optional custom message.
}

message UpdateSessionResponse {
    Session session = 1; //Session.
}

message DeleteSessionRequest {
    string id = 1; //Session ID. Required.
    bool notify_participants = 2 [deprecated = true]; // Deprecated, use participant_notification
    ParticipantNotification participant_notification = 3; // Whether to notify participants about the change, and an optional custom message.
}

message DeleteSessionResponse {
    string id = 1; //Session ID.
}

message SessionBatchRequest {
    repeated CreateSessionRequest sessions_to_create = 1;
    repeated UpdateSessionRequest sessions_to_update = 2;
    repeated DeleteSessionRequest sessions_to_delete = 3;
}

message SessionBatchResponse {
    repeated CreateSessionResponse sessions_created = 1;
    repeated UpdateSessionResponse sessions_updated = 2;
    repeated DeleteSessionResponse sessions_deleted = 3;
}

message GetSessionRequest {
    string id = 1; //Session ID.
}

message GetSessionResponse {
    Session session = 1; //Session.
}

//session
message ListSessionsRequest {
    repeated string ids = 1; //Session ID.
    google.protobuf.FieldMask field_mask = 2; //Field mask of fields to return. Currently only supports the "scheduleOwnerId" field.
}

message ListSessionsResponse {
    repeated Session sessions = 1; //Session.
}

//recurring sessions
message QuerySessionsRequest {
    .wix.common.Query query = 1; //Query
}

message QuerySessionsResponse {
    repeated Session sessions = 1; //Session.
    .wix.common.PagingMetadataV2 paging_metadata = 2;
}

message ValidateSessionRequest {
    Session session = 1; //Session.
}

message ValidateSessionResponse {
    Session session = 1; //Session.
}

//Participants
message AddParticipantRequest {
    string schedule_id = 1; //Schedule ID. Required.
    //Optional. If this field is given, the participant will be added to this specific session.
    //Not supported for recurring sessions.
    google.protobuf.StringValue session_id = 2 [deprecated = true];
    Participant participant = 3; //Participant.
}

message AddParticipantResponse {
    string schedule_id = 1[deprecated = true]; //Schedule ID.
    google.protobuf.StringValue session_id = 2 [deprecated = true]; //Session ID. Optional.
    Participant participant = 3; //Participant.
    Session session = 4 [deprecated = true]; //Session.
    Schedule schedule = 5; //Schedule.
}

//Participants
message AddParticipantToSessionRequest {
    string session_id = 1; //Session ID. Required.
    Participant participant = 2; //Participant.
}

message AddParticipantToSessionResponse {
    Participant participant = 1; //Participant.
    Session session = 2; //Session.
}

message UpdateParticipantRequest {
    Participant participant = 1; //Participant to update, identified by the ID field.
    google.protobuf.FieldMask field_mask = 2; // Field mask of fields to update.
}

message UpdateParticipantResponse {
    Participant participant = 1; //Participant.
}

message RemoveParticipantRequest {
    string id = 1; //Participant ID.
}

message RemoveParticipantResponse {
    string id = 1; //Participant ID.
}

message SplitIntervalRequest {
    string schedule_id = 1; //Schedule ID.
    string interval_id = 2; //Interval ID.
    repeated google.protobuf.Timestamp split_times = 3; //A list of times where the interval is to be split. Must not be in the past. Must not contain duplicate times.
}

message SplitIntervalResponse {
    repeated RecurringInterval intervals = 1; //A list of intervals where the first is the modified original interval followed by other newly created intervals.
}

message SplitRecurringSessionRequest {
    string recurring_session_id = 2; //Recurring session ID.
    repeated google.protobuf.Timestamp split_times = 3; //A list of times where the session is to be split. Must not be in the past. Must not contain duplicate times.
}

message SplitRecurringSessionResponse {
    repeated Session recurring_sessions = 1; //A list of recurring sessions where the first is the modified original session followed by other newly created sessions.
}

message UpdateIntervalRequest {
    string schedule_id = 1; //Schedule ID.
    RecurringInterval interval = 2; //Recurring Interval
    ParticipantNotification participant_notification = 3; //Whether to notify participants about the change, and an optional custom message.
}

message UpdateIntervalResponse {

}

//schedule owner
message AssignWiXUserAsScheduleOwnerRequest {
    string uid = 1 [(.wix.api.format) = GUID]; //The wix user id. Required.
    string schedule_owner_id = 3 [(.wix.api.format) = GUID]; //Schedule owner id assigned to the user id. e.g, in case of schedule of a staff member, can be staff member id.
    string ms_id = 2 [(.wix.api.format) = GUID]; //The meta site id related to this schedule owner id. Required.
}

message AssignWiXUserAsScheduleOwnerResponse {
    string uid = 2; //The wix user id related to this schedule owner id. Required.
    string schedule_owner_id = 1 [(.wix.api.format) = GUID]; //Schedule owner id. e.g, in case of schedule of a staff member, can be staff member id.
}

//schedule owner
message UnAssignWiXUserFromScheduleOwnerRequest {
    string uid = 1 [(.wix.api.format) = GUID]; //The wix user id. Required.
    string schedule_owner_id = 3 [(.wix.api.format) = GUID]; //Schedule owner id. e.g, in case of schedule of a staff member, can be staff member id.
    string ms_id = 2 [(.wix.api.format) = GUID]; //The meta site id related to this schedule owner id. Required.
}

message UnAssignWiXUserFromScheduleOwnerResponse {
    string schedule_owner_id = 1 [(.wix.api.format) = GUID]; //Schedule owner id. e.g, in case of schedule of a staff member, can be staff member id.
}

message SessionParticipants {
    string schedule_id = 1;
    string session_id = 2;
    repeated Participant participants = 3;
}

message MigrateParticipantsRequest {
    repeated SessionParticipants session_participants_list = 1;
}

message MigrateParticipantsResponse {
    repeated Session sessions = 1;
}

message MigrateRequest {
    repeated string csv_list = 1;
}

message MigrateResponse {
    repeated MigrateResponseEntry results = 1;
}

message MigrateResponseEntry {
    string key = 1;
    google.protobuf.StringValue errorMessage = 2;
}

message SetAvailabilityLocationsRequest {
    //The ID of the schedule. Required.
    string schedule_id = 1;
    //The schedule's availability locations to set. Required.
    //The locations you specify replace the existing `schedule.availability.locations`.
    repeated com.wix.bookings.common.api.v1.Location locations = 2;
    //The action to perform on sessions currently set to a removed location.
    RemovedLocationSessionsAction removed_location_sessions_action = 3;
    //Whether to notify participants about the change, and an optional custom message.
    ParticipantNotification participant_notification = 6;

    message RemovedLocationSessionsAction {
        //The action to perform on sessions currently set to a removed location.
        Action action = 1;
        //The location to move sessions currently set to a removed location, used when `action` is `MOVE_TO_LOCATION`.
        com.wix.bookings.common.api.v1.Location new_location = 2;

        enum Action {
            UNDEFINED = 0;
            //Keep future sessions at their current location. This is the default.
            //Note: The location will be set directly on the session. i.e, if the location is currently inherited from the schedule, the inheritance will be overridden.
            KEEP_AT_CURRENT_LOCATION = 1;
            //Move future sessions to a new location.
            //The new location must be specified in the availability locations to set ('SetAvailabilityLocationsRequest.locations').
            MOVE_TO_LOCATION = 2;
            //Delete future sessions.
            //Currently not supported.
            DELETE = 3;
        }
    }
}

message SetAvailabilityLocationsResponse {
    //The updated schedule
    Schedule schedule = 1;
}

message QuerySchedulesRequest {
    .wix.common.QueryV2 query = 1;
}

message QuerySchedulesResponse {
    repeated ExtendedSchedule schedules = 1;
    .wix.common.PagingMetadataV2 paging_metadata = 2;
}

message QuerySchedulesHistoryRequest {
    .wix.common.QueryV2 query = 1;
}

message QuerySchedulesHistoryResponse {
    repeated ExtendedSchedule schedules = 1;
    .wix.common.PagingMetadataV2 paging_metadata = 2;
}

message QueryConcreteSessionsRequest {
    .wix.common.QueryV2 query = 1;
    google.protobuf.Timestamp minimum_session_start_date = 2;
}

message QueryConcreteSessionsResponse {
    repeated ExtendedSession sessions = 1;
    .wix.common.PagingMetadataV2 paging_metadata = 2;
}
