import tmp from 'tmp';
import fs from 'fs';

import {flynt} from '../lib/flynt-api';
import {getProtocExec} from '@wix/flynt-protoc';
import {getStdIncludeProtos} from '@wix/proto-syntax-tree';
import {FlyntPlugin} from '@wix/flynt-plugin-types';
import {execFile} from 'child_process';
import path from 'path';
import util from 'util';

const execFileAsync = util.promisify(execFile);

describe('flynt', () => {

  const mainProtoFolder = './test/resources/proto-module/src/main/proto';
  const catalog = './test/test-catalog';
  const moduleRootFolder = './test/resources/proto-module';

  const simpleModule = './test/resources/simple-module';
  const stdProtosFolder = './test/resources/std-protos';

  describe('validations', () => {
    it('mainDescriptorSet must be set together with includeDescriptorSet', async () => {
      await expect(flynt({
        mainProtoFolder: 'proto',
        moduleRootFolder: 'module',
        includeDescriptorSet: ['include'],
      })).rejects.toThrow(/mainDescriptorSet.*includeDescriptorSet/);
    });

    it('prevModuleRootFolder must be set if prevMainProtoFolder is set', async () => {
      await expect(flynt({
        mainProtoFolder: 'proto',
        moduleRootFolder: 'module',
        prevMainProtoFolder: 'prevProto',
      })).rejects.toThrow(/prevMainProtoFolder/);
    });
  });

  describe('unpackaged', () => {
    it('when proto is invalid', async () => {
      await expect(flynt({
        mainProtoFolder: './test/resources/invalid-proto-module/proto',
        moduleRootFolder: './test/resources/invalid-proto-module',
      })).rejects.toThrow(/Option.*unknown/);
    });

    it('runs the proto linter cli and reports expected issues (test catalog)', async () => {
      const results = await flynt({
        mainProtoFolder,
        moduleRootFolder,
        catalog,
      });
      const stdout = results.formattedOutput;
      console.log(stdout);

      expect(stdout).toContain('always-fail');
      expect(stdout).toMatch(/WARNING.*services are not allowed/);
      expect(stdout).toMatch(/src\/main\/proto\/service.proto:\d+:\d+/);
    });

    it('runs the proto linter cli and reports expected issues (built in catalog)', async () => {
      const results = await flynt({
        mainProtoFolder,
        moduleRootFolder,
        verbose: true
      });
      expect(results.output.lintResults.executionErrors).toEqual([]);
      expect(results.output.lintResults.results).not.toHaveLength(0);
      expect(results.output.lintResults.results).toContainEqual(expect.objectContaining({
        ruleId: 'test-rule-wsyaiqjxksxdhsanpklg'
      }));
    });

    it('writes output file', async () => {
      const {name: jsonOutput} = tmp.fileSync({postfix: 'output.json'});

      const res = await flynt({
        mainProtoFolder,
        moduleRootFolder,
        catalog,
        jsonOutput,
        config: './test/configs/config2.json'
      });

      const report = JSON.parse(fs.readFileSync(jsonOutput, 'utf-8'));
      expect(report).toEqual({
        lintResults: res.output.lintResults,
        config: {
          rules: {
            rule1: 'error',
            rule2: 'warning',
            rule3: 'off'
          },
          severity: 'error',
          date: new Date('2021-01-01').toISOString(),
        }
      });
    });

    it('runs with external standard protos', async () => {
      const results = await flynt({
        mainProtoFolder: simpleModule,
        moduleRootFolder: simpleModule,
        catalog,
        includeProtoFolder: [stdProtosFolder],
      });
      const stdout = results.formattedOutput;
      console.log(stdout);

      expect(stdout).toContain('always-fail');
      expect(stdout).toContain('services are not allowed');
      expect(stdout).toMatch(/service.proto:\d+:\d+/);
    });

    it('allows mainProtoFolder to be passed as include folder', async () => {
      const results = await flynt({
        mainProtoFolder,
        moduleRootFolder,
        includeProtoFolder: [mainProtoFolder],
        catalog,
      });
      const stdout = results.formattedOutput;
      expect(stdout).toContain('always-fail');
    });

    it('run linter on proto descriptor sets', async () => {
      const results = await flynt({
        mainProtoFolder: simpleModule,
        moduleRootFolder: simpleModule,
        catalog,
        mainDescriptorSet: simpleModule + '/fds/service.bin',
        includeDescriptorSet: [
          simpleModule + '/fds/wrappers.bin',
          simpleModule + '/fds/service.bin',
        ],
      });
      const stdout = results.formattedOutput;
      console.log(stdout);

      expect(stdout).toContain('always-fail');
      expect(stdout).toContain('services are not allowed');
      expect(stdout).toMatch(/service.proto:\d+:\d+/);
    });

    describe('stateful', () => {
      it('runs the proto linter cli and reports expected issues (test catalog)', async () => {
        const results = await flynt({
          mainProtoFolder,
          moduleRootFolder,
          catalog,
          prevMainProtoFolder: './test/resources/proto-module-prev/src/main/proto',
          prevModuleRootFolder: './test/resources/proto-module-prev',
        });
        const stdout = results.formattedOutput;
        console.log(stdout);

        expect(stdout).toContain('stateful-always-fail');
        expect(stdout).toContain('new services are not allowed');
        expect(stdout).toMatch(/src\/main\/proto\/service.proto:\d+:\d+/);
      });

      it('runs the proto linter cli and reports expected issues (built in catalog)', async () => {
        const results = await flynt({
          mainProtoFolder,
          moduleRootFolder,
          prevMainProtoFolder: './test/resources/proto-module-prev/src/main/proto',
          prevModuleRootFolder: './test/resources/proto-module-prev',
        });
        expect(results.output.lintResults.executionErrors).toEqual([]);
        expect(results.output.lintResults.results).not.toHaveLength(0);
        expect(results.output.lintResults.results).toContainEqual(expect.objectContaining({
          ruleId: 'stateful-test-rule-dhsanpklgwsyaiqjxksx'
        }));
      });
    });

    describe('plugins', () => {
      it('plugin which deal with output', async () => {
        const {name: jsonOutput} = tmp.fileSync({postfix: 'output.json'});
        const plugin: FlyntPlugin = {
          name: 'output',
          beforeWriteToOutputFile(ctx, output) {
            output.foo = 'bar';
          },
          afterWriteToOutputFile(ctx, output) {
            expect(output.foo).toEqual('bar');
          }
        };
        const res = await flynt({
          mainProtoFolder,
          moduleRootFolder,
          catalog,
          jsonOutput,
          config: './test/configs/config2.json',
          plugins: [plugin],
        });

        const report = JSON.parse(fs.readFileSync(jsonOutput, 'utf-8'));
        expect(report).toEqual({
          lintResults: res.output.lintResults,
          config: {
            rules: {
              rule1: 'error',
              rule2: 'warning',
              rule3: 'off'
            },
            severity: 'error',
            date: new Date('2021-01-01').toISOString(),
          },
          foo: 'bar',
        });
      });
    });
  });

  describe('packaged', () => {
    describe('simulate packaged', () => {
      beforeAll(() => {
        (process as any).pkg = true;
      });

      afterAll(() => {
        delete (process as any).pkg;
      });

      describe('runs the proto linter cli and reports expected issues', () => {
        it('fails if not passing a protoc executable', async () => {
          await expect(flynt({
            mainProtoFolder,
            moduleRootFolder,
            includeProtoFolder: [...getStdIncludeProtos()],
            catalog,
          })).rejects.toThrow(/external protoc/);
        });

        it('fails if passing stdProtos=true', async () => {
          await expect(flynt({
            protocExe: getProtocExec(),
            mainProtoFolder,
            moduleRootFolder,
            includeProtoFolder: [...getStdIncludeProtos()],
            catalog,
            stdProtos: true,
          })).rejects.toThrow(/standard protos/);
        });

        it('it runs without protocExe when run on descriptor sets', async () => {
          const results = await flynt({
            mainProtoFolder: simpleModule,
            moduleRootFolder: simpleModule,
            catalog,
            mainDescriptorSet: simpleModule + '/fds/service.bin',
            includeDescriptorSet: [
              simpleModule + '/fds/wrappers.bin',
              simpleModule + '/fds/service.bin',
            ],
          });
          const stdout = results.formattedOutput;
          console.log(stdout);

          expect(stdout).toContain('always-fail');
          expect(stdout).toContain('services are not allowed');
          expect(stdout).toMatch(/service.proto:\d+:\d+/);
        });

        it('with the test catalog', async () => {
          const results = await flynt({
            protocExe: getProtocExec(),
            mainProtoFolder,
            moduleRootFolder,
            includeProtoFolder: [...getStdIncludeProtos()],
            catalog,
          });
          const stdout = results.formattedOutput;
          console.log(stdout);

          expect(stdout).toContain('always-fail');
          expect(stdout).toContain('services are not allowed');
          expect(stdout).toMatch(/src\/main\/proto\/service.proto:\d+:\d+/);
        });

        it('with the built in catalog', async () => {
          const results = await flynt({
            protocExe: getProtocExec(),
            mainProtoFolder,
            moduleRootFolder,
            includeProtoFolder: [...getStdIncludeProtos()],
          });
          const stdout = results.formattedOutput;
          console.log(stdout);

          expect(stdout).not.toContain('error occurred in rule');
          expect(stdout).toContain('wsyaiqjxksxdhsanpklg');
          expect(stdout).toMatch(/src\/main\/proto\/service.proto:\d+:\d+/);
        });
      });

      it('runs with external standard protos', async () => {
        const results = await flynt({
          protocExe: getProtocExec(),
          mainProtoFolder: simpleModule,
          moduleRootFolder: simpleModule,
          catalog,
          includeProtoFolder: [stdProtosFolder],
          stdProtos: false,
        });
        const stdout = results.formattedOutput;
        console.log(stdout);

        expect(stdout).toContain('always-fail');
        expect(stdout).toContain('services are not allowed');
        expect(stdout).toMatch(/service.proto:\d+:\d+/);
      });

      describe('external protoc', () => {
        it('works when running with an external protoc executable', async () => {
          const results = await flynt({
            mainProtoFolder,
            moduleRootFolder,
            catalog,
            includeProtoFolder: [...getStdIncludeProtos()],
            protocExe: getProtocExec()
          });
          const stdout = results.formattedOutput;

          expect(stdout).toContain('always-fail');
        });

        it('fails when passing a non existing protoc executable', async () => {
          try {
            await flynt({
              mainProtoFolder,
              moduleRootFolder,
              catalog,
              protocExe: '/non/existing/foo/bar/protoc'
            });
            throw new Error('Expected execution to fail but it passed');
          } catch (e: any) {
            expect(e.message).not.toEqual('Expected execution to fail but it passed');
            expect(e.message).toMatch(/spawn.*protoc.*ENOENT/);
          }
        });
      });
    });
  });

  describe('runs the flynt cli', () => {
    const cli = path.join(__dirname, '../cli.ts');

    it('with warnings only', async () => {
      const args = ['--mainProtoFolder', mainProtoFolder,
        '--moduleRootFolder', moduleRootFolder,
        '--catalog', './test/test-catalog',
        '--protocExe', getProtocExec()
      ];
      const stdProtos = getStdIncludeProtos();
      stdProtos.forEach(proto => args.push('-I', proto));

      const promise = execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
      const {stderr} = await promise;

      expect(promise.child.exitCode).toEqual(0);
      expect(stderr).toContain('always-fail');
      expect(stderr).toMatch(/WARNING.*services are not allowed/);
      expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
      expect(stderr).not.toMatch('Flynt Exit with code');
    }, 20000);

    it('with errors', async () => {
      const args = ['--mainProtoFolder', mainProtoFolder,
        '--moduleRootFolder', moduleRootFolder,
        '--catalog', './test/error-test-catalog',
        '--protocExe', getProtocExec(),
      ];
      const stdProtos = getStdIncludeProtos();
      stdProtos.forEach(proto => args.push('-I', proto));

      try {
        await execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
        throw new Error('Expected execution to fail but it passed');
      } catch (e: any) {
        expect(e.message).not.toEqual('Expected execution to fail but it passed');
        expect(e.code).toEqual(1); //Exit code 1 when there are rule ERRORs
        const {stderr} = e;
        expect(stderr).toContain('always-fail');
        expect(stderr).toMatch(/ERROR.*services are not allowed/);
        expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
        expect(stderr).toMatch('Flynt Exit with code 1');
      }
    }, 20000);

    describe('exitCode', () => {
      it('non strict errors with  with exitCode=errors', async () => {
        const args = ['--mainProtoFolder', mainProtoFolder,
          '--moduleRootFolder', moduleRootFolder,
          '--catalog', './test/error-test-catalog',
          '--exitCode', 'error',
          '--protocExe', getProtocExec(),
        ];
        const stdProtos = getStdIncludeProtos();
        stdProtos.forEach(proto => args.push('-I', proto));

        try {
          await execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
          throw new Error('Expected execution to fail but it passed');
        } catch (e: any) {
          expect(e.message).not.toEqual('Expected execution to fail but it passed');
          expect(e.code).toEqual(1); //Exit code 1 when there are rule ERRORs
          const {stderr} = e;
          expect(stderr).toContain('always-fail');
          expect(stderr).toMatch(/ERROR.*services are not allowed/);
          expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
          expect(stderr).toMatch('Flynt Exit with code 1');
        }
      }, 20000);

      it('non strict errors with  with exitCode=strict', async () => {
        const args = ['--mainProtoFolder', mainProtoFolder,
          '--moduleRootFolder', moduleRootFolder,
          '--catalog', './test/error-test-catalog',
          '--exitCode', 'strict',
          '--protocExe', getProtocExec(),
        ];
        const stdProtos = getStdIncludeProtos();
        stdProtos.forEach(proto => args.push('-I', proto));

        const promise = execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
        const {stderr} = await promise;

        expect(promise.child.exitCode).toEqual(0);
        expect(stderr).toContain('always-fail');
        expect(stderr).toMatch(/ERROR.*services are not allowed/);
        expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
        expect(stderr).toMatch('Flynt Exit with code 0');
      }, 20000);

      it('strict errors with  with exitCode=strict', async () => {
        const args = ['--mainProtoFolder', mainProtoFolder,
          '--moduleRootFolder', moduleRootFolder,
          '--catalog', './test/strict-test-catalog',
          '--exitCode', 'strict',
          '--protocExe', getProtocExec(),
        ];
        const stdProtos = getStdIncludeProtos();
        stdProtos.forEach(proto => args.push('-I', proto));

        try {
          await execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
          throw new Error('Expected execution to fail but it passed');
        } catch (e: any) {
          expect(e.message).not.toEqual('Expected execution to fail but it passed');
          expect(e.code).toEqual(1); //Exit code 1 when there are rule ERRORs
          const {stderr} = e;
          expect(stderr).toContain('strict-always-fail');
          expect(stderr).toMatch(/ERROR.*services are strictly not allowed/);
          expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
          expect(stderr).toMatch('Flynt Exit with code 1');
        }
      }, 20000);

      it('strict errors with  with exitCode=never', async () => {
        const args = ['--mainProtoFolder', mainProtoFolder,
          '--moduleRootFolder', moduleRootFolder,
          '--catalog', './test/strict-test-catalog',
          '--exitCode', 'never',
          '--protocExe', getProtocExec(),
        ];
        const stdProtos = getStdIncludeProtos();
        stdProtos.forEach(proto => args.push('-I', proto));

        const promise = execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
        const {stderr} = await promise;

        expect(promise.child.exitCode).toEqual(0);
        expect(stderr).toContain('always-fail');
        expect(stderr).toMatch(/ERROR.*services are strictly not allowed/);
        expect(stderr).toMatch(/^src\/main\/proto\/service.proto:\d+:\d+/m);
        expect(stderr).toMatch('Flynt Exit with code 0');
      }, 20000);
    });

    it('with invalid parameters', async () => {
      const args = ['--mainProtoFolder', mainProtoFolder,
        '--mainDescriptorSet', 'xxx',
        '--includeDescriptorSet', 'xxx'
      ];

      try {
        await execFileAsync('npx', ['ts-node', '-T', cli, ...args]);
        throw new Error('Expected execution to fail but it passed');
      } catch (e: any) {
        expect(e.message).not.toEqual('Expected execution to fail but it passed');
        expect(e.code).toEqual(2); //Exit code 2 when an exception was thrown by flynt
        const {stderr} = e;
        expect(stderr).toMatch(/ENOENT.*xxx/);
      }

    }, 20000);
  });

});
