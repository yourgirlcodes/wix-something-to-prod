import {parseCliOptions, parseOptsInternal} from '../lib/cli-options';
import {createFlyntPluginsCliHost, PluginsCliHost} from '@wix/flynt-plugins-host';
import {loadPlugins, OptionsPlugin} from './test-utils';
import {ExitCode} from '../lib/flynt-cli';

describe('cli options', () => {
  let pluginsHost: PluginsCliHost;

  beforeEach(() => {
    pluginsHost = createFlyntPluginsCliHost();
  });

  describe('basics', () => {

    describe('defaults', () => {
      it('returns correct defaults', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base'], pluginsHost);
        expect(opts.includeProtoFolder).toBeUndefined();
        expect(opts.mainDescriptorSet).toBeUndefined();
        expect(opts.includeDescriptorSet).toBeUndefined();
        expect(opts.moduleRootFolder).toEqual(process.cwd());

        expect(opts.prevMainProtoFolder).toBeUndefined();
        expect(opts.prevIncludeProtoFolder).toBeUndefined();
        expect(opts.prevModuleRootFolder).toBeUndefined();
        expect(opts.prevMainDescriptorSet).toBeUndefined();
        expect(opts.prevIncludeDescriptorSet).toBeUndefined();

        expect(opts.config).toBeUndefined();
        expect(opts.catalog).toBeUndefined();
        expect(opts.jsonOutput).toBeUndefined();
        expect(opts.protocExe).toBeUndefined();
        expect(opts.stdProtos).toBeUndefined();
        expect(opts.verbose).toEqual(false);
        expect(opts.date).toBeUndefined();
        expect(opts.exitCode).toEqual(ExitCode.error);
      });
    });

    describe('mainProtoFolder', () => {
      it('should return mainProtoFolder', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base'], pluginsHost);
        expect(opts.mainProtoFolder).toEqual('base');
      });
    });

    describe('mainProtoFile', () => {
      it('should return array of proto files', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--mainProtoFile', 'file1.proto', '--mainProtoFile', 'file2.proto'], pluginsHost);
        expect(opts.mainProtoFile).toEqual(['file1.proto', 'file2.proto']);
      });

      it('should support delimited files', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--mainProtoFile', 'file1.proto:file2.proto'], pluginsHost);
        expect(opts.mainProtoFile).toEqual(['file1.proto', 'file2.proto']);
      });
    });

    describe('include option', () => {
      it('should return array of one folder', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '-I', 'folder1'], pluginsHost);
        expect(opts.includeProtoFolder).toEqual(['folder1']);
      });

      it('should return array of include folders', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '-I', 'folder1', '-I', 'folder2'], pluginsHost);
        expect(opts.includeProtoFolder).toEqual(['folder1', 'folder2']);
      });

      it('supports delimited include folders', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '-I', 'folder1:folder2'], pluginsHost);
        expect(opts.includeProtoFolder).toEqual(['folder1', 'folder2']);
      });
    });

    describe('module option', () => {
      it('returns passed module', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--moduleRootFolder', '/dummy'], pluginsHost);
        expect(opts.moduleRootFolder).toEqual('/dummy');
      });

      it('returns current working dir', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base'], pluginsHost);
        expect(opts.moduleRootFolder).toEqual(process.cwd());
      });
    });

    describe('config option', () => {
      it('returns passed config', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--config', '/dummy/config.json'], pluginsHost);
        expect(opts.config).toEqual('/dummy/config.json');
      });
    });

    describe('protoc option', () => {
      it('returns passed protoc', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--protocExe', '/dummy/protoc'], pluginsHost);
        expect(opts.protocExe).toEqual('/dummy/protoc');
      });
    });

    describe('descriptor set', () => {
      it('supports repeated descriptor set input', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--mainDescriptorSet', 'mainDes',
          '--includeDescriptorSet', '/dummy/val1',
          '--includeDescriptorSet', '/dummy/val3'
        ], pluginsHost);
        expect(opts.mainDescriptorSet).toEqual('mainDes');
        expect(opts.includeDescriptorSet).toEqual([
          '/dummy/val1',
          '/dummy/val3',
        ]);
      });

      it('supports delimited descriptor set input', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--mainDescriptorSet', 'mainDes',
          '--includeDescriptorSet', '/dummy/val1:/dummy/val2',
          '--includeDescriptorSet', '/dummy/val3:/dummy/val4'
        ], pluginsHost);
        expect(opts.mainDescriptorSet).toEqual('mainDes');
        expect(opts.includeDescriptorSet).toEqual([
          '/dummy/val1',
          '/dummy/val2',
          '/dummy/val3',
          '/dummy/val4',
        ]);
      });
    });

    describe('date', () => {
      it('returns passed date', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--date', '2000-01-01'], pluginsHost);
        expect(opts.date).toEqual('2000-01-01');
      });
    });

    describe('previous proto files', () => {
      it('previous main proto folder', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--prevMainProtoFolder', 'prev-base'], pluginsHost);

        expect(opts.prevMainProtoFolder).toEqual('prev-base');
      });

      it('previous proto files', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--prevMainProtoFolder', 'prev-base', '--prevMainProtoFile', 'proto1.proto',
          '--prevMainProtoFile', 'proto2.proto:proto3.proto'], pluginsHost);

        expect(opts.prevMainProtoFile).toEqual(['proto1.proto', 'proto2.proto', 'proto3.proto']);
      });

      it('previous proto include folders', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--prevMainProtoFolder', 'prev-base', '--prevIncludeProtoFolder', 'folder1', '--prevIncludeProtoFolder', 'folder2:folder3'], pluginsHost);

        expect(opts.prevIncludeProtoFolder).toEqual(['folder1', 'folder2', 'folder3']);
      });

      it('previous module', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--prevModuleRootFolder', 'prev-module'], pluginsHost);

        expect(opts.prevModuleRootFolder).toEqual('prev-module');
      });

      it('previous proto descriptors', async () => {
        const opts = parseCliOptions(['--mainProtoFolder', 'base', '--prevMainProtoFolder', 'prev-base',
          '--prevMainDescriptorSet', 'prev-desc-set',
          '--prevIncludeDescriptorSet', 'inc-desc-set-1', '--prevIncludeDescriptorSet', 'inc-desc-set-2'], pluginsHost);

        expect(opts.prevMainDescriptorSet).toEqual('prev-desc-set');
        expect(opts.prevIncludeDescriptorSet).toEqual(['inc-desc-set-1', 'inc-desc-set-2']);
      });
    });

    describe('exitCode option', () => {
      it('returns passed value', async () => {
        let opts = parseCliOptions(['--mainProtoFolder', 'base', '--exitCode', 'never'], pluginsHost);
        expect(opts.exitCode).toEqual(ExitCode.never);
        opts = parseCliOptions(['--mainProtoFolder', 'base', '--exitCode', 'error'], pluginsHost);
        expect(opts.exitCode).toEqual(ExitCode.error);
        opts = parseCliOptions(['--mainProtoFolder', 'base', '--exitCode', 'strict'], pluginsHost);
        expect(opts.exitCode).toEqual(ExitCode.strict);
      });
    });
  });

  describe('errors', () => {
    it('missing required arguments', async () => {
      expect(() => parseOptsInternal([], pluginsHost, {})).toThrow(/missing required argument.*mainProtoFolder/i);
    });

    it('invalid exitCode choices', async () => {
      expect(() => parseOptsInternal(['--mainProtoFolder', 'base', '--exitCode', 'foo'], pluginsHost, {})).toThrow(/argument.*exitCode.*foo/i);
    });

    it('fails on invalid args', async () => {
      expect(() => parseOptsInternal(['--mainProtoFolder', 'base', '--xxx', 'yyy'], pluginsHost, {})).toThrow(/unknown argument.*xxx/i);
    });

    it('includeProtoFolder conflicts with mainDescriptorSet', async () => {
      expect(() => parseOptsInternal(['--mainProtoFolder', 'base',
        '--includeProtoFolder', 'yyy', '--mainDescriptorSet', 'zzz'], pluginsHost, {})).toThrow(/mutually exclusiv/i);
    });

    it('mainProtoFile conflicts with mainDescriptorSet', async () => {
      expect(() => parseOptsInternal(['--mainProtoFolder', 'base',
        '--mainProtoFile', 'yyy', '--mainDescriptorSet', 'zzz'], pluginsHost, {})).toThrow(/mutually exclusiv/i);
    });
  });

  describe('plugins', () => {
    it('does not fail on plugin options', async () => {
      const opts = parseOptsInternal(['--mainProtoFolder', 'base', '-p', 'plugin:name'], pluginsHost);
      expect(opts.plugin).toEqual(['plugin:name']);
    });

    it('parses extended plugin options', async () => {
      const testMode = {usage: ''};
      await loadPlugins(pluginsHost, {
        name: 'plg1',
        getCliOptions() {
          return [{name: 'param1'}];
        }
      });
      const opts = parseOptsInternal(['--mainProtoFolder', 'base', '--plg1-param1', 'foobar'], pluginsHost, testMode);
      expect(opts['plg1-param1']).toEqual('foobar');
      expect(testMode.usage).toContain('--plg1-param1');
    });

    it('set extended plugin options', async () => {
      const plugin1 = new OptionsPlugin('plg1', ['p1']);
      const plugin2 = new OptionsPlugin('plg2', ['p2', 'p3']);
      await loadPlugins(pluginsHost, plugin1, plugin2);
      parseCliOptions(['--mainProtoFolder', 'base',
        '--plg1-p1', 'v1', '--plg2-p2', 'v2', '--plg2-p3', 'v3'], pluginsHost);
      expect(plugin1.opts).toEqual({p1: 'v1'});
      expect(plugin2.opts).toEqual({p2: 'v2', p3: 'v3'});
    });

    it('all options are treated as strings', async () => {
      const plugin1 = new OptionsPlugin('plg1', ['p1']);
      const plugin2 = new OptionsPlugin('plg2', ['p2', 'p3']);
      await loadPlugins(pluginsHost, plugin1, plugin2);
      parseCliOptions(['--mainProtoFolder', 'base',
        '--plg1-p1', '1', '--plg2-p2', 'true', '--plg2-p3'], pluginsHost);
      expect(plugin1.opts).toEqual({p1: '1'});
      expect(plugin2.opts).toEqual({p2: 'true', p3: ''});
    });

    it('set only some options', async () => {
      const plugin1 = {
        name: 'plg1',
        getCliOptions() {
          return [{name: 'param'}];
        },
        setOptions() {
          throw new Error('not supposed to get here');
        }
      };
      const plugin2 = new OptionsPlugin('plg2', ['p2', 'p3']);
      await loadPlugins(pluginsHost, plugin1, plugin2);
      parseCliOptions(['--mainProtoFolder', 'base', '--plg2-p3', 'v3'], pluginsHost);
      expect(plugin2.opts).toEqual({p3: 'v3'});
    });

  });
});
