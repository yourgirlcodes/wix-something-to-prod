import {generateSyntaxTreeFrom, LintConfig, linter, LintResults, ProtoModule} from '@wix/flynt-engine';
import {generateSyntaxTreeFromDescriptorFiles} from '@wix/proto-syntax-tree';
import debug from 'debug';
import {loadConfig} from './cli-config';
import {summarizeResults} from './summarize-results';
import fs from 'fs';
import assert from 'assert';
import {FlyntPlugins, PluginsHost} from '@wix/flynt-plugins-host';
import {FlyntOutput, FlyntResults} from './flynt-api';
import {initPluginsRunner} from './plugins';

const log = debug('wix:flynt:cli');

export interface CliOptions {
  mainProtoFolder: string;
  mainProtoFile?: string[];
  includeProtoFolder?: string[];
  includeDescriptorSet?: string[];
  mainDescriptorSet?: string;
  moduleRootFolder: string;
  prevMainProtoFolder?: string;
  prevMainProtoFile?: string[];
  prevIncludeProtoFolder?: string[];
  prevIncludeDescriptorSet?: string[];
  prevMainDescriptorSet?: string;
  prevModuleRootFolder?: string;
  config?: string;
  catalog?: string;
  jsonOutput?: string;
  stdProtos?: boolean;
  verbose?: boolean;
  protocExe?: string;
  date?: string;
  exitCode?: ExitCode;
}

export enum ExitCode {
  error = 'error',
  strict = 'strict',
  never = 'never'
}

export async function flyntCliInternal(opts: CliOptions, pluginsHost: PluginsHost): Promise<FlyntResults> {
  if (opts.verbose) {
    debug.enable('wix:flynt:protoc;wix:flynt:cli,wix:flynt:syntax-tree,wix:flynt:descriptor-parser,wix:flynt:proto-linter,wix:flynt:plugins');
  }

  const optEnv = {pkg: (process as any).pkg};
  opts = sanitizeOptions(opts, optEnv);
  const flyntPlugins = await initPluginsRunner(pluginsHost, opts);
  opts = flyntPlugins.beforeValidateFlyntOptions();
  validateOptions(opts, optEnv);

  if (opts.protocExe) {
    log(`using protoc from ${opts.protocExe}`);
    process.env.PROTOC = opts.protocExe;
  }

  console.error(`${new Date().toISOString()} mainProtoFolder: ${opts.mainProtoFolder}`);

  const config = loadConfig(opts);

  if (config.date) {
    log(`Current date is ${config.date.toISOString()}`);
  }
  const protoModule = await buildProtoModule(opts.moduleRootFolder, opts);
  let prevProtoModule: ProtoModule | undefined;
  if (opts.prevMainProtoFolder) {
    log('Running in stateful mode');
    prevProtoModule = await buildProtoModule(opts.prevModuleRootFolder!, {
      mainProtoFolder: opts.prevMainProtoFolder,
      mainProtoFile: opts.prevMainProtoFile,
      includeProtoFolder: opts.prevIncludeProtoFolder,
      mainDescriptorSet: opts.prevMainDescriptorSet,
      includeDescriptorSet: opts.prevIncludeDescriptorSet,
      stdProtos: opts.stdProtos
    });
  }

  log('running linter');

  const lintResult = await linter(config).lint(protoModule, prevProtoModule);
  const output = await writeResultToFile(lintResult, config, opts.jsonOutput, flyntPlugins);

  const lintResultsSummary = summarizeResults(lintResult, opts, flyntPlugins);
  log('done');
  const result = {
    output,
    ...lintResultsSummary
  };
  await flyntPlugins.beforeUnload(result);
  return result;
}

type genProtoModuleOpts = {
  mainProtoFolder: string;
  mainProtoFile?: string[];
  includeProtoFolder?: string[];
  mainDescriptorSet?: string;
  includeDescriptorSet?: string[];
  stdProtos?: boolean;
};

async function buildProtoModule(moduleDir: string, opts: genProtoModuleOpts): Promise<ProtoModule> {
  const st = await generateSyntaxTree(opts);
  return {
    st,
    moduleDir,
    protoDir: opts.mainProtoFolder,
  };
}

async function generateSyntaxTree(opts: genProtoModuleOpts) {
  if (opts.mainDescriptorSet && opts.includeDescriptorSet) {
    log('generating syntax tree from proto descriptor sets');
    return await generateSyntaxTreeFromDescriptorFiles(opts.mainDescriptorSet, opts.mainProtoFolder, opts.includeDescriptorSet);
  } else {
    log('generating syntax tree from proto files');
    return await generateSyntaxTreeFrom({
      mainProtoFolder: opts.mainProtoFolder,
      protoFiles: opts.mainProtoFile,
      include: opts.includeProtoFolder ?? [],
      includeStdProtos: opts.stdProtos,
    });
  }
}

function sanitizeOptions(opts: CliOptions, env: {pkg: boolean}): CliOptions {
  const result = {...opts};
  result.stdProtos = opts.stdProtos === undefined ? !env.pkg : opts.stdProtos;
  result.includeProtoFolder = opts.includeProtoFolder?.filter(f => f !== opts.mainProtoFolder);

  if (opts.mainDescriptorSet && !opts.includeDescriptorSet) {
    result.includeDescriptorSet = [];
  }

  return result;
}

function validateOptions(opts: CliOptions, env: {pkg: boolean}) {
  if (opts.includeDescriptorSet) {
    assert(opts.mainDescriptorSet, '"mainDescriptorSet" must be set together with "includeDescriptorSet"');
  }

  if (opts.prevMainProtoFolder) {
    assert(opts.prevModuleRootFolder, 'prevModuleRootFolder must be set when prevMainProtoFolder is set');
  }

  if (env.pkg) {
    assert(opts.protocExe || opts.mainDescriptorSet, 'Packaged flynt can only be used with external protoc or with descriptor sets');
    assert(!opts.stdProtos, 'Packaged flynt does not contain standard protos');
  }
}

async function writeResultToFile(lintResults: LintResults, lintConfig: LintConfig, fileName: string | undefined, flyntPlugins: FlyntPlugins): Promise<FlyntOutput> {
  //Exclude unneeded properties from config
  const {catalog: _catalog, ...config} = lintConfig;
  const output = {lintResults, config};
  await flyntPlugins.beforeWriteToOutputFile(output);
  //do this even if no output file is provided to ensure output is serializable
  const jsonOutput = JSON.stringify(output, null, 1);
  if (fileName) {
    log('writing output');
    fs.writeFileSync(fileName, jsonOutput);
  }
  await flyntPlugins.afterWriteToOutputFile(Object.freeze(output));
  return output;
}
