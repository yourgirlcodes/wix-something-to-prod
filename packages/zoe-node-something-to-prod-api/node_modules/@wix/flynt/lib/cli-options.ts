import yargs, {Argv} from 'yargs';
import {CliOptions, ExitCode} from './flynt-cli';
import path from 'path';
import debug from 'debug';
import {PluginsCliHost} from '@wix/flynt-plugins-host';
import {CliOption} from '@wix/flynt-plugin-types';

const log = debug('wix:flynt:cli');

export function parseCliOptions(args: string[], pluginsHost: PluginsCliHost): CliOptions {
  return parseOptsInternal(args, pluginsHost);
}

export function parseOptsInternal(args: string[], pluginsHost: PluginsCliHost, testOpts?: {usage?: string}) {
  log('parsing cli options');
  let optsBuilder = yargs(args).options({
    mainProtoFolder: {
      string: true,
      demandOption: true,
      description: 'folder where proto files to lint are located in'
    },
    mainProtoFile: {
      type: 'array',
      string: true,
      description: 'proto files to lint. If not provided, all proto files in mainProtoFolder will be linted',
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    includeProtoFolder: {
      type: 'array',
      string: true,
      alias: 'I',
      description: 'additional directories to search for proto files.\n May be specified multiple times',
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    moduleRootFolder: {
      string: true,
      default: process.cwd(),
      defaultDescription: 'current working directory',
      description: 'root folder of the module containing the proto files',
    },
    mainDescriptorSet: {
      string: true,
      conflicts: ['includeProtoFolder', 'mainProtoFile'],
    },
    includeDescriptorSet: {
      type: 'array',
      alias: 'descriptorSetIn',
      string: true,
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    catalog: {
      string: true,
      hidden: true,
      defaultDescription: 'built in rule catalog',
      description: 'path to folder containing rules catalog'
    },
    config: {
      string: true,
      description: 'path to config file where options can be read from'
    },
    jsonOutput: {
      string: true,
      description: 'path to filename which will contain Flynt output in json format'
    },
    stdProtos: {
      boolean: true,
      description: 'automatically include "standard" protos',
    },
    verbose: {
      alias: 'v',
      boolean: true,
      default: false,
      description: 'enable verbose logging',
    },
    protocExe: {
      string: true,
      description: 'path to protoc executable',
    },
    date: {
      string: true,
      description: 'Overrides current date. This affects rule grace period (format: YYYY-MM-DD)',
    },
    prevMainProtoFolder: {
      string: true,
      description: 'folder where previous version of the proto files are located in'
    },
    prevMainProtoFile: {
      type: 'array',
      string: true,
      description: 'previous main proto files',
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    prevIncludeProtoFolder: {
      type: 'array',
      string: true,
      description: 'previous proto files include directories',
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    prevModuleRootFolder: {
      string: true,
      description: 'root folder of the module containing the previous proto files',
    },
    prevMainDescriptorSet: {
      string: true,
      conflicts: ['prevIncludeProtoFolder'],
    },
    prevIncludeDescriptorSet: {
      type: 'array',
      string: true,
      coerce: (set?: string[]) => set ? set.map(s => s.split(path.delimiter)).flat() : undefined,
    },
    plugin: {
      alias: 'p',
      type: 'array',
      string: true,
      description: 'path to a package containing a Flynt plugin to load',
    },
    exitCode: {
      choices: Object.values(ExitCode),
      default: ExitCode.error,
      coerce: (choice: string) => choice as ExitCode,
      description: 'determines when to set exit code to 1. error- whenever a lint issue with error severity is found. strict - only for strict errors. never - exit code will never be 1',
    }
  });

  const pluginOptions = pluginsHost.getExtendedCliOptions();
  optsBuilder = addPluginOptions(pluginOptions, optsBuilder);

  optsBuilder = optsBuilder.strict();
  if (testOpts) {
    optsBuilder = optsBuilder.exitProcess(false).showHelp((s) => testOpts.usage = s);
  }

  const opts = optsBuilder.parse();
  setPluginOptionsFromParsedOptions(pluginsHost, pluginOptions, opts);
  return opts;
}

function addPluginOptions<T>(pluginOptions: Record<string, CliOption[]>, optsBuilder: Argv<T>) {
  for (const pluginName in pluginOptions) {
    const pluginCliOptions = pluginOptions[pluginName];
    for (const pluginOption of pluginCliOptions) {
      const optName = `${pluginName}-${pluginOption.name}`;
      optsBuilder = optsBuilder.option(optName, {string: true});
    }
  }
  return optsBuilder;
}

function setPluginOptionsFromParsedOptions(pluginsHost: PluginsCliHost, pluginOptions: Record<string, CliOption[]>, opts: Record<string, any>) {
  for (const pluginName in pluginOptions) {
    const pluginCliOptions = pluginOptions[pluginName];
    let pluginOpt: Record<string, string> | undefined;
    for (const pluginOption of pluginCliOptions) {
      const optName = `${pluginName}-${pluginOption.name}`;
      const optValue = opts[optName];
      if (optValue !== undefined) {
        pluginOpt = pluginOpt || {};
        pluginOpt[pluginOption.name] = optValue;
      }
    }
    if (pluginOpt) {
      pluginsHost.setPluginOptions(pluginName, pluginOpt);
    }
  }
}
