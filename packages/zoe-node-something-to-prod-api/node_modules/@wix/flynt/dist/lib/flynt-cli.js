"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flyntCliInternal = exports.ExitCode = void 0;
const flynt_engine_1 = require("@wix/flynt-engine");
const proto_syntax_tree_1 = require("@wix/proto-syntax-tree");
const debug_1 = __importDefault(require("debug"));
const cli_config_1 = require("./cli-config");
const summarize_results_1 = require("./summarize-results");
const fs_1 = __importDefault(require("fs"));
const assert_1 = __importDefault(require("assert"));
const plugins_1 = require("./plugins");
const log = (0, debug_1.default)('wix:flynt:cli');
var ExitCode;
(function (ExitCode) {
    ExitCode["error"] = "error";
    ExitCode["strict"] = "strict";
    ExitCode["never"] = "never";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
async function flyntCliInternal(opts, pluginsHost) {
    if (opts.verbose) {
        debug_1.default.enable('wix:flynt:protoc;wix:flynt:cli,wix:flynt:syntax-tree,wix:flynt:descriptor-parser,wix:flynt:proto-linter,wix:flynt:plugins');
    }
    const optEnv = { pkg: process.pkg };
    opts = sanitizeOptions(opts, optEnv);
    const flyntPlugins = await (0, plugins_1.initPluginsRunner)(pluginsHost, opts);
    opts = flyntPlugins.beforeValidateFlyntOptions();
    validateOptions(opts, optEnv);
    if (opts.protocExe) {
        log(`using protoc from ${opts.protocExe}`);
        process.env.PROTOC = opts.protocExe;
    }
    console.error(`${new Date().toISOString()} mainProtoFolder: ${opts.mainProtoFolder}`);
    const config = (0, cli_config_1.loadConfig)(opts);
    if (config.date) {
        log(`Current date is ${config.date.toISOString()}`);
    }
    const protoModule = await buildProtoModule(opts.moduleRootFolder, opts);
    let prevProtoModule;
    if (opts.prevMainProtoFolder) {
        log('Running in stateful mode');
        prevProtoModule = await buildProtoModule(opts.prevModuleRootFolder, {
            mainProtoFolder: opts.prevMainProtoFolder,
            mainProtoFile: opts.prevMainProtoFile,
            includeProtoFolder: opts.prevIncludeProtoFolder,
            mainDescriptorSet: opts.prevMainDescriptorSet,
            includeDescriptorSet: opts.prevIncludeDescriptorSet,
            stdProtos: opts.stdProtos
        });
    }
    log('running linter');
    const lintResult = await (0, flynt_engine_1.linter)(config).lint(protoModule, prevProtoModule);
    const output = await writeResultToFile(lintResult, config, opts.jsonOutput, flyntPlugins);
    const lintResultsSummary = (0, summarize_results_1.summarizeResults)(lintResult, opts, flyntPlugins);
    log('done');
    const result = {
        output,
        ...lintResultsSummary
    };
    await flyntPlugins.beforeUnload(result);
    return result;
}
exports.flyntCliInternal = flyntCliInternal;
async function buildProtoModule(moduleDir, opts) {
    const st = await generateSyntaxTree(opts);
    return {
        st,
        moduleDir,
        protoDir: opts.mainProtoFolder,
    };
}
async function generateSyntaxTree(opts) {
    if (opts.mainDescriptorSet && opts.includeDescriptorSet) {
        log('generating syntax tree from proto descriptor sets');
        return await (0, proto_syntax_tree_1.generateSyntaxTreeFromDescriptorFiles)(opts.mainDescriptorSet, opts.mainProtoFolder, opts.includeDescriptorSet);
    }
    else {
        log('generating syntax tree from proto files');
        return await (0, flynt_engine_1.generateSyntaxTreeFrom)({
            mainProtoFolder: opts.mainProtoFolder,
            protoFiles: opts.mainProtoFile,
            include: opts.includeProtoFolder ?? [],
            includeStdProtos: opts.stdProtos,
        });
    }
}
function sanitizeOptions(opts, env) {
    const result = { ...opts };
    result.stdProtos = opts.stdProtos === undefined ? !env.pkg : opts.stdProtos;
    result.includeProtoFolder = opts.includeProtoFolder?.filter(f => f !== opts.mainProtoFolder);
    if (opts.mainDescriptorSet && !opts.includeDescriptorSet) {
        result.includeDescriptorSet = [];
    }
    return result;
}
function validateOptions(opts, env) {
    if (opts.includeDescriptorSet) {
        (0, assert_1.default)(opts.mainDescriptorSet, '"mainDescriptorSet" must be set together with "includeDescriptorSet"');
    }
    if (opts.prevMainProtoFolder) {
        (0, assert_1.default)(opts.prevModuleRootFolder, 'prevModuleRootFolder must be set when prevMainProtoFolder is set');
    }
    if (env.pkg) {
        (0, assert_1.default)(opts.protocExe || opts.mainDescriptorSet, 'Packaged flynt can only be used with external protoc or with descriptor sets');
        (0, assert_1.default)(!opts.stdProtos, 'Packaged flynt does not contain standard protos');
    }
}
async function writeResultToFile(lintResults, lintConfig, fileName, flyntPlugins) {
    const { catalog: _catalog, ...config } = lintConfig;
    const output = { lintResults, config };
    await flyntPlugins.beforeWriteToOutputFile(output);
    const jsonOutput = JSON.stringify(output, null, 1);
    if (fileName) {
        log('writing output');
        fs_1.default.writeFileSync(fileName, jsonOutput);
    }
    await flyntPlugins.afterWriteToOutputFile(Object.freeze(output));
    return output;
}
//# sourceMappingURL=flynt-cli.js.map