"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOptsInternal = exports.parseCliOptions = void 0;
const yargs_1 = __importDefault(require("yargs"));
const flynt_cli_1 = require("./flynt-cli");
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('wix:flynt:cli');
function parseCliOptions(args, pluginsHost) {
    return parseOptsInternal(args, pluginsHost);
}
exports.parseCliOptions = parseCliOptions;
function parseOptsInternal(args, pluginsHost, testOpts) {
    log('parsing cli options');
    let optsBuilder = (0, yargs_1.default)(args).options({
        mainProtoFolder: {
            string: true,
            demandOption: true,
            description: 'folder where proto files to lint are located in'
        },
        mainProtoFile: {
            type: 'array',
            string: true,
            description: 'proto files to lint. If not provided, all proto files in mainProtoFolder will be linted',
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        includeProtoFolder: {
            type: 'array',
            string: true,
            alias: 'I',
            description: 'additional directories to search for proto files.\n May be specified multiple times',
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        moduleRootFolder: {
            string: true,
            default: process.cwd(),
            defaultDescription: 'current working directory',
            description: 'root folder of the module containing the proto files',
        },
        mainDescriptorSet: {
            string: true,
            conflicts: ['includeProtoFolder', 'mainProtoFile'],
        },
        includeDescriptorSet: {
            type: 'array',
            alias: 'descriptorSetIn',
            string: true,
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        catalog: {
            string: true,
            hidden: true,
            defaultDescription: 'built in rule catalog',
            description: 'path to folder containing rules catalog'
        },
        config: {
            string: true,
            description: 'path to config file where options can be read from'
        },
        jsonOutput: {
            string: true,
            description: 'path to filename which will contain Flynt output in json format'
        },
        stdProtos: {
            boolean: true,
            description: 'automatically include "standard" protos',
        },
        verbose: {
            alias: 'v',
            boolean: true,
            default: false,
            description: 'enable verbose logging',
        },
        protocExe: {
            string: true,
            description: 'path to protoc executable',
        },
        date: {
            string: true,
            description: 'Overrides current date. This affects rule grace period (format: YYYY-MM-DD)',
        },
        prevMainProtoFolder: {
            string: true,
            description: 'folder where previous version of the proto files are located in'
        },
        prevMainProtoFile: {
            type: 'array',
            string: true,
            description: 'previous main proto files',
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        prevIncludeProtoFolder: {
            type: 'array',
            string: true,
            description: 'previous proto files include directories',
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        prevModuleRootFolder: {
            string: true,
            description: 'root folder of the module containing the previous proto files',
        },
        prevMainDescriptorSet: {
            string: true,
            conflicts: ['prevIncludeProtoFolder'],
        },
        prevIncludeDescriptorSet: {
            type: 'array',
            string: true,
            coerce: (set) => set ? set.map(s => s.split(path_1.default.delimiter)).flat() : undefined,
        },
        plugin: {
            alias: 'p',
            type: 'array',
            string: true,
            description: 'path to a package containing a Flynt plugin to load',
        },
        exitCode: {
            choices: Object.values(flynt_cli_1.ExitCode),
            default: flynt_cli_1.ExitCode.error,
            coerce: (choice) => choice,
            description: 'determines when to set exit code to 1. error- whenever a lint issue with error severity is found. strict - only for strict errors. never - exit code will never be 1',
        }
    });
    const pluginOptions = pluginsHost.getExtendedCliOptions();
    optsBuilder = addPluginOptions(pluginOptions, optsBuilder);
    optsBuilder = optsBuilder.strict();
    if (testOpts) {
        optsBuilder = optsBuilder.exitProcess(false).showHelp((s) => testOpts.usage = s);
    }
    const opts = optsBuilder.parse();
    setPluginOptionsFromParsedOptions(pluginsHost, pluginOptions, opts);
    return opts;
}
exports.parseOptsInternal = parseOptsInternal;
function addPluginOptions(pluginOptions, optsBuilder) {
    for (const pluginName in pluginOptions) {
        const pluginCliOptions = pluginOptions[pluginName];
        for (const pluginOption of pluginCliOptions) {
            const optName = `${pluginName}-${pluginOption.name}`;
            optsBuilder = optsBuilder.option(optName, { string: true });
        }
    }
    return optsBuilder;
}
function setPluginOptionsFromParsedOptions(pluginsHost, pluginOptions, opts) {
    for (const pluginName in pluginOptions) {
        const pluginCliOptions = pluginOptions[pluginName];
        let pluginOpt;
        for (const pluginOption of pluginCliOptions) {
            const optName = `${pluginName}-${pluginOption.name}`;
            const optValue = opts[optName];
            if (optValue !== undefined) {
                pluginOpt = pluginOpt || {};
                pluginOpt[pluginOption.name] = optValue;
            }
        }
        if (pluginOpt) {
            pluginsHost.setPluginOptions(pluginName, pluginOpt);
        }
    }
}
//# sourceMappingURL=cli-options.js.map