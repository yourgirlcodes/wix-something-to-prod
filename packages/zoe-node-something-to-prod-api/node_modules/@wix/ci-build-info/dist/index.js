"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuildInfoForTesting = exports.getBuildInfo = exports.createBuildInfoFile = exports.fullFileName = exports.testkit = exports.TESTKIT_BUILD_INFO_PATH_ENV_NAME = exports.BUILD_INFO_PATH_ENV_NAME = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const CiBuildInfo_1 = require("./CiBuildInfo");
const artifact_description_1 = require("@wix/artifact-description");
const tmp_1 = __importDefault(require("tmp"));
const git_url_parse_1 = __importDefault(require("git-url-parse"));
exports.BUILD_INFO_PATH_ENV_NAME = 'FALCON_CI_BUILD_INFO_PATH';
exports.TESTKIT_BUILD_INFO_PATH_ENV_NAME = 'FALCON_CI_TESTKIT_BUILD_INFO_PATH';
function getGitRepoDetails(vcsUrl) {
    try {
        const result = (0, git_url_parse_1.default)(vcsUrl);
        if (!result.name || !result.owner || result.protocol !== 'ssh') {
            throw new Error(`Invalid vcs url "${vcsUrl}" (format should be git@github.com:<org-name>/<repo-name>.git)`);
        }
        return {
            repoOwner: result.owner,
            repoName: result.name,
        };
    }
    catch (e) {
        const info = e instanceof Error ? e.stack : e;
        throw new Error(`Failed to parse vcs url "${vcsUrl}": ${info}`);
    }
}
function fromEntries(entries) {
    return [...entries].reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
    }, {});
}
exports.testkit = {
    createBuildInfo: ({ packages, isPullRequest, isFalcon, repoRootDir, vcsUrl: customVcsUrl, }) => {
        const artifactVersion = '1.0.0';
        const buildId = '12345';
        const vcsUrl = customVcsUrl !== null && customVcsUrl !== void 0 ? customVcsUrl : 'git@github.com:wix-private/my-repo.git';
        const ciServerUrl = 'http://tc.dev.wixpress.com';
        const falconBuildRunId = 'aaaaaaaa-aaaa-aaaa-aaaa-bbbbbbbbbbbb';
        const branchName = isPullRequest ? 'branch-in-pr' : 'master';
        const { repoName, repoOwner } = getGitRepoDetails(vcsUrl);
        const versionedBuildInfo = {
            isFalcon: typeof isFalcon === 'boolean' ? isFalcon : true,
            buildLogLink: `${ciServerUrl}/viewLog.html?buildId=${buildId}`,
            falconBuildRunId,
            flakinessDetectionBuildRun: false,
            vcs: Object.assign({ repoName,
                repoOwner, url: vcsUrl, branch: branchName, commitHash: 'sha' }, (isPullRequest && {
                pullRequest: {
                    fromBranch: branchName,
                    prNumber: '12321',
                },
            })),
            repoRootFullPath: repoRootDir !== null && repoRootDir !== void 0 ? repoRootDir : '',
            packages: fromEntries(packages.map(({ path: packagePath, fingerprint }) => {
                var _a;
                const id = getPackageName(packagePath);
                const description = (0, artifact_description_1.extractDescription)(packagePath);
                const packageInfo = {
                    id,
                    fingerprint: fingerprint !== null && fingerprint !== void 0 ? fingerprint : artifactVersion,
                    fullPath: packagePath,
                    relativePath: repoRootDir ? path.relative(repoRootDir, packagePath) : '',
                    monorepoDependencies: {
                        direct: [],
                        all: [],
                    },
                };
                if (fs.existsSync(path.join(packagePath, 'pom.xml')) || description.targets[artifact_description_1.TargetKind.STATIC]) {
                    if (!description.key) {
                        throw new Error(`Package ${id} has a static target but no artifact id`);
                    }
                    packageInfo.artifact = {
                        cdnUrl: getCdnUrlInfo((_a = description.key) === null || _a === void 0 ? void 0 : _a.artifactId, artifactVersion),
                    };
                }
                return [id, packageInfo];
            })),
        };
        const buildInfo = {
            v1: versionedBuildInfo,
            v2: versionedBuildInfo,
        };
        const { name: tempFolder } = tmp_1.default.dirSync();
        createBuildInfoFile(buildInfo, tempFolder);
        return {
            env: { [exports.TESTKIT_BUILD_INFO_PATH_ENV_NAME]: tempFolder },
            buildInfo,
        };
    },
};
function fullFileName(buildInfoPath) {
    return `${buildInfoPath}/buildInfo.json`;
}
exports.fullFileName = fullFileName;
function createBuildInfoFile(buildInfo, buildInfoPath) {
    fs.writeFileSync(fullFileName(buildInfoPath), JSON.stringify(buildInfo));
}
exports.createBuildInfoFile = createBuildInfoFile;
function getBuildInfo() {
    // DANGER ZONE: This function is not covered by test. Do not change it.
    /*eslint no-process-env: "off"*/
    return getBuildInfoImpl(process.env, process.cwd());
}
exports.getBuildInfo = getBuildInfo;
function getBuildInfoForTesting(env, rootDir) {
    return getBuildInfoImpl(env, rootDir);
}
exports.getBuildInfoForTesting = getBuildInfoForTesting;
function getBuildInfoImpl(env, rootDir) {
    const testkitBuildInfoPath = env[exports.TESTKIT_BUILD_INFO_PATH_ENV_NAME];
    if (testkitBuildInfoPath) {
        const buildInfoRawJSON = fs.readFileSync(fullFileName(testkitBuildInfoPath));
        const buildInfo = (0, CiBuildInfo_1.parse)(JSON.parse(buildInfoRawJSON.toString()));
        return buildInfo;
    }
    const folderPath = env[exports.BUILD_INFO_PATH_ENV_NAME];
    if (folderPath) {
        return getFalconBuildInfo(folderPath);
    }
    return getLegacyBuildInfo(env, rootDir);
}
function getFalconBuildInfo(buildInfoFilefolderPath) {
    const buildInfoRawJSON = fs.readFileSync(fullFileName(buildInfoFilefolderPath));
    const buildInfo = (0, CiBuildInfo_1.parse)(JSON.parse(buildInfoRawJSON.toString()));
    return buildInfo;
}
function getLegacyBuildInfo(env, rootDir) {
    const artifactVersion = toNonEmptyString(env, 'ARTIFACT_VERSION', 'SRC_MD5').replace('-SNAPSHOT', '');
    const fingerprint = toNonEmptyString(env, 'SRC_MD5', 'ARTIFACT_VERSION').replace('-SNAPSHOT', '');
    const buildId = toNonEmptyString(env, 'BUILD_ID');
    const agentType = toNonEmptyString(env, 'agentType');
    const vcsUrl = toNonEmptyString(env, 'GIT_REMOTE_URL');
    const commitHash = toNonEmptyString(env, 'BUILD_VCS_NUMBER');
    const ciServerUrl = agentType === 'pullrequest' ? 'http://pullrequest-tc.dev.wixpress.com' : 'http://tc.dev.wixpress.com';
    let branch;
    try {
        branch = toNonEmptyString(env, 'VCS_BRANCH_NAME');
    }
    catch (err) {
        branch = 'refs/heads/master';
    }
    const artifactInfo = getArtifactInfo(rootDir, artifactVersion);
    function createLegacyPackageInfos({ packageLocations, preferFingerprint, artifactInfo, }) {
        const entries = packageLocations.map((location) => {
            const packageName = getPackageName(location);
            const packageInfo = {
                id: packageName,
                fingerprint: preferFingerprint ? fingerprint : artifactVersion,
                fullPath: location,
                relativePath: path.relative(rootDir, location),
                monorepoDependencies: {
                    direct: [],
                    all: [],
                },
            };
            if (artifactInfo) {
                packageInfo.artifact = artifactInfo;
            }
            return [packageName, packageInfo];
        });
        return entries.reduce((acc, [k, v]) => (Object.assign(Object.assign({}, acc), { [k]: v })), {});
    }
    const { repoName, repoOwner } = getGitRepoDetails(vcsUrl);
    function createInfo({ preferFingerprint }) {
        const packageInfos = createLegacyPackageInfos({
            packageLocations: [rootDir],
            preferFingerprint,
            artifactInfo,
        });
        return {
            isFalcon: false,
            falconBuildRunId: '',
            flakinessDetectionBuildRun: false,
            buildLogLink: `${ciServerUrl}/viewLog.html?buildId=${buildId}`,
            vcs: { repoName, repoOwner, url: vcsUrl, branch, commitHash },
            repoRootFullPath: rootDir,
            packages: packageInfos,
        };
    }
    const buildInfo = {
        v1: createInfo({ preferFingerprint: false }),
        v2: createInfo({ preferFingerprint: true }),
    };
    return buildInfo;
}
function getArtifactInfo(rootDir, artifactVersion) {
    var _a;
    // yoshi assumes that there's a static target if there's a pom.xml file.
    // This is not good enough, but we don't want to break existing behavior.
    // Using artifact-description is also not good, since it's not yet
    // backwards compatible - it only looks for an artifact schema in package.json
    const description = (0, artifact_description_1.extractDescription)(rootDir);
    if (fs.existsSync(path.join(rootDir, 'pom.xml'))) {
        if (!description.key) {
            const packageName = getPackageName(rootDir);
            throw new Error(`Package ${packageName} has a static target but no artifact id`);
        }
        return {
            cdnUrl: getCdnUrlInfo((_a = description.key) === null || _a === void 0 ? void 0 : _a.artifactId, artifactVersion),
        };
    }
}
function getPackageName(rootDir) {
    const packageJson = fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8');
    return JSON.parse(packageJson).name;
}
function toNonEmptyString(env, name, fallback) {
    const value = env[name];
    if (value == null || value.length === 0) {
        if (fallback) {
            const fallbackValue = env[fallback];
            if (fallbackValue == null || fallbackValue.length === 0) {
                throw new Error(`Env variable ${name} or ${fallback} must be a non empty string, received: ${value}, ${fallbackValue} accordingly`);
            }
            return fallbackValue;
        }
        throw new Error(`Env variable ${name} must be a non empty string, received: ${value}`);
    }
    return value;
}
function getCdnUrlInfo(artifactId, fingerprint) {
    const baseUrl = 'https://static.parastorage.com/services';
    return {
        versioned: `${baseUrl}/${artifactId}/${fingerprint}/`,
        unversioned: `${baseUrl}/${artifactId}/dist/`,
    };
}
//# sourceMappingURL=index.js.map