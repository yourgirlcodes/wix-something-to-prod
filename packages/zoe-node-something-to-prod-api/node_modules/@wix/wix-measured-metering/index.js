const assert = require('assert'),
  {promisify} = require('util'),
  {ErrorCode, isBusinessError, extractMetadata} = require('@wix/wix-errors');

const defaultErrorCode = ErrorCode.UNKNOWN;

class WixMeasuredMetering {

  constructor(measuredClient, now = () => Date.now()) {
    assert(measuredClient, 'measured client is mandatory');
    this._measuredClient = measuredClient;
    this._now = now;
  }

  callback(key, name) {
    return fn => this.promise(key, name)(promisify(fn))().catch(() => { /* swallow */ });
  }

  raw(key, name) {
    const {hist, meter, collectionForErrors, reportedErrors} = createMetrics(this._measuredClient, key, name);

    const reportSuccess = ({duration = undefined, count = 1} = {}) => {
      assert(Number.isInteger(count) && count >= 0, 'count if provided must be a non-negative integer');

      if (duration) {
        assert(typeof duration === 'undefined' || (Number.isInteger(duration) && duration >= 0), 'duration if provided must be a non-negative integer');
        hist(duration);
      }

      if (count > 0) {
        markExecuted(meter, count);
      }
    };

    const reportError = err => {
      assert(err, 'error parameter is required');
      markExecuted(getOrCreateNewErrorReporter(err, reportedErrors, collectionForErrors));
      markExecuted(meter);
    };

    return {
      reportError,
      reportSuccess
    };
  }

  promise(key, name) {
    const {hist, meter, collectionForErrors, reportedErrors} = createMetrics(this._measuredClient, key, name);

    return fnWithPromiseReturn => {
      return () => {
        const before = this._now();
        return fnWithPromiseReturn()
          .then(res => {
            captureDuration(hist, before, this._now());
            markExecuted(meter);
            return res;
          }).catch(e => {
            markExecuted(getOrCreateNewErrorReporter(e, reportedErrors, collectionForErrors));
            return Promise.reject(e);
          });
      };
    };
  }
}

function getOrCreateNewErrorReporter(error, reportedErrors, collectionForErrors) {
  const {errorName, errorCode} = errorNameAndCode(error);
  const errorKey = `${errorName}_${errorCode}`;
  if (!reportedErrors[errorKey]) {
    reportedErrors[errorKey] = collectionForErrors.collection('error', errorName).meter('code', `${errorTypeTag(error)}_${errorCode.toString()}`);
  }
  return reportedErrors[errorKey];
}

function errorTypeTag(error) {
  return error instanceof Error && isBusinessError(error) ? 'business' : 'system';
}

function markExecuted(meter, counter = 1) {
  meter(counter);
}

function captureDuration(hist, before, now) {
  hist(now - before);
}

function createMetrics(measuredClient, key, name) {
  const hist = measuredClient.hist(key, name);
  const meter = measuredClient.meter(key, name);
  const collectionForErrors = measuredClient.collection(key, name);
  const reportedErrors = {};

  return {hist, meter, collectionForErrors, reportedErrors};
}

function errorNameAndCode(maybeError) {
  if (maybeError instanceof Error) {
    const metadata = extractMetadata(maybeError);
    const errorName = metadata.name;
    const errorCode = metadata.details && metadata.details.applicationError && metadata.details.applicationError.code ||
      metadata.errorCode ||
      defaultErrorCode;
    return {errorName, errorCode};
  } else if (typeof maybeError === 'string') {
    return {errorName: 'string', errorCode: defaultErrorCode};
  } else {
    return {errorName: 'no-name', errorCode: defaultErrorCode};
  }
}

module.exports = WixMeasuredMetering;
module.exports.default = WixMeasuredMetering;
