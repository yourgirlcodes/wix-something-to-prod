const shell = require('shelljs'),
  fs = require('fs'),
  wixProtoCodegen = require('@wix/wix-proto-codegen'),
  {protoc} = require('@wix/wnp-protoc-wrapper'),
  {flynt} = require('@wix/flynt'),
  {util} = require('@wix/wix-proto-runtime-toolkit'),
  {join, relative, sep, dirname, basename} = require('path'),
  assert = require('assert');

async function validate({location, skipPomValidation = false, skipProtoc = false, skipLint = false}) {
  validateProtoInProtoFolder(location);
  validateNoMissLocatedProtos(location);
  validateWnpTypeProperty(location);
  if (!skipPomValidation) {
    validateNoPomFile(location);
  }
  validateDocumentation(location);
  const root = await validateCodeGenerationDoesNotFail(location);
  validateNoDefaultPackage(location, root);
  warnOnPackageMismatch(location, root);

  if (!skipLint) {
    await runFlynt(location);
  }

  if (!skipProtoc) {
    await validateProtocCompatibility(location);
  }
}

function validateDocumentation(location) {
  const documentationPath = join(protoFolder(location), 'documentation.yaml');
  if (!fs.existsSync(documentationPath)) {
    throw new Error(`Missing ${documentationPath}`);
  }
}

function warnOnPackageMismatch(location, root) {
  const base = protoFolder(location);
  const handled = new Set();
  const ignored = path => ['node_modules', 'wix-proto-codegen'].some(fragment => path.indexOf(fragment) >= 0);

  function traverse(reflectionObject) {
    if (reflectionObject.filename && !handled.has(reflectionObject.filename)) {
      const packageName = util.fqn(reflectionObject).split('.').slice(0, -1);
      const expected = packageName.join(sep);
      const actual = relative(base, dirname(reflectionObject.filename));
      if (actual !== expected && !ignored(reflectionObject.filename)) {
        console.error(`- WARNING: move file ${relative(location, reflectionObject.filename)} to ${join('src', 'main', 'proto', expected, basename(reflectionObject.filename))} to match the protobuf package name "${packageName.join('.')}".`);
      }
      handled.add(reflectionObject.filename);
    }
    if (reflectionObject.nestedArray) {
      reflectionObject.nestedArray.forEach(traverse);
    }
  }

  traverse(root);
}


function getAllRootFolders(modules) {
  const allFolders = modules.reduce((folders, module) => getAllRootFolders(module.children).concat(findProtoFolder(module.path), folders), []);
  return [...new Set(allFolders)];
}

async function runFlynt(location) {
  const {NodePlugin} = require('@wix/flynt-node-plugin');
  const module = wixProtoCodegen.tools.Module.fromDir(location);
  const moduleRoots = getAllRootFolders(module.children);

  const config = {
    moduleRootFolder: location,
    mainProtoFolder: protoFolder(location),
    includeProtoFolder: moduleRoots,
    plugins: [new NodePlugin()],
  };

  const res = await flynt(config);
  if (res.errors > 0) {
    console.error(res.formattedOutput);
    throw new Error(`Lint failed with ${res.errors} error(s)`);
  } else if (res.warnings > 0) {
    console.warn(res.formattedOutput);
  }
}

async function validateProtocCompatibility(location) {
  const module = wixProtoCodegen.tools.Module.fromDir(location);
  const moduleRoots = getAllRootFolders(module.children);
  const bundledRoots = wixProtoCodegen.tools.listBundledRoots();

  const config = {
    baseFolder: protoFolder(location),
    includeFolders: moduleRoots.concat(bundledRoots)
  };

  return protoc(config)
    .catch(error => {
      throw new Error(`Checking protoc compatibility failed: ${error.message}`);
    });
}

function validateNoDefaultPackage(location, root) {
  const illegal = new Set(Object.values(root.nested)
    .filter(obj => obj.constructor.name !== 'Namespace')
    .map(el => el.filename)
    .map(path => relative(location, path)));
  if (illegal.size > 0) {
    const msg = `The following files are missing a required 'package' specifier: ${Array.from(illegal).join(', ')}`;
    throw new Error(msg);
  }
}

async function validateCodeGenerationDoesNotFail(location) {
  const targetPath = join(location, 'target/codegen');
  const opts = {
    target: {
      dir: targetPath,
      name: 'proto-generated-filename'
    },
    moduleDir: location,
    strictMode: false,
  };

  try {
    return await wixProtoCodegen(opts);
  } catch (err) {
    throw new Error('failed to generate code from proto\n' + err.message);
  }
}

function validateNoPomFile(location) {
  const pomFilePath = `${location}/pom.xml`;
  if (fs.existsSync(pomFilePath)) {
    throw new Error(`Module must not have a pom.xml file but one found (${pomFilePath})`);
  }
}

function validateWnpTypeProperty(location) {
  const packageJsonPath = `${location}/package.json`;
  const packageJson = require(packageJsonPath);
  if (packageJson.wnp_type !== 'proto') {
    throw new Error(`package.json must have a "wnp_type=proto" property. (${packageJsonPath})`);
  }
}

function validateNoMissLocatedProtos(location) {
  const missLocatedProtos = shell.find(location).filter(file => isMissLocatedProtoFile(file, location));
  if (missLocatedProtos.length > 0) {
    throw new Error(`There are miss-located protos: ${missLocatedProtos.join(',')}`);
  }
}

function isMissLocatedProtoFile(file, location) {
  return file.endsWith('.proto') &&
    !(file.startsWith(protoFolder(location))) &&
    !fileInNodeModules(file, location);
}

function fileInNodeModules(file, location) {
  return file.startsWith(`${location}/node_modules/`);
}

function findProtoFolder(location) {
  const folder = join(location, 'proto');
  if (fs.existsSync(folder)) {
    return folder;
  }
  return protoFolder(location);
}

function validateProtoInProtoFolder(location) {
  if (isThereProtoFolder(location)) {
    const protoFolderContent = shell.find(protoFolder(location));
    const areProtosInProtoFolder = protoFolderContent && containProtoFiles(protoFolderContent);
    if (!areProtosInProtoFolder) {
      failNoProtosError(location);
    }
  } else {
    failNoProtosError(location);
  }
}

function failNoProtosError(location) {
  throw new Error(`No proto files under ${protoFolder(location)}`);
}

function isThereProtoFolder(location) {
  return shell.find(location).includes(protoFolder(location));
}

function protoFolder(location) {
  return join(location, 'src', 'main', 'proto');
}

function containProtoFiles(filesList) {
  return filesList.filter(file => file.includes('.proto')).length > 0;
}

module.exports = module => {
  assert(typeof module === 'object' && typeof module.location === 'string', 'module.location is required and must be a string');
  return validate(module);
};
