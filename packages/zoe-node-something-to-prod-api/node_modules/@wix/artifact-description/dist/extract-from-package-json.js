"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractFromPackageJson = void 0;
const artifact_description_error_1 = require("./artifact-description-error");
const artifact_description_1 = require("./artifact-description");
const extract_from_pom_xml_1 = require("./extract-from-pom-xml");
const z = __importStar(require("zod"));
const lodash_pickby_1 = __importDefault(require("lodash.pickby"));
function extractFromPackageJson(packageJson) {
    let parsedPackageJson;
    try {
        parsedPackageJson = JSON.parse(packageJson.content);
    }
    catch (_a) {
        throw new artifact_description_error_1.ArtifactDescriptionError(`Failed to parse package.json at ${packageJson.location}:\n<<${packageJson.content}>>`);
    }
    const keyAndTargets = extractKeyAndTargets(parsedPackageJson, packageJson);
    const contributors = extractContributors(parsedPackageJson);
    return Object.assign(Object.assign({}, contributors), keyAndTargets);
}
exports.extractFromPackageJson = extractFromPackageJson;
function extractKeyAndTargets(parsedPackageJson, packageJson) {
    var _a;
    const artifact = (_a = parsedPackageJson === null || parsedPackageJson === void 0 ? void 0 : parsedPackageJson.wix) === null || _a === void 0 ? void 0 : _a.artifact;
    if (!artifact) {
        return {
            targets: npmTarget(parsedPackageJson),
            previewUrls: [],
            platforms: [],
        };
    }
    const previewUrls = extractPreviewUrls(artifact.previewUrls);
    const platforms = extractPlatforms(artifact.platforms);
    const targets = Object.assign(Object.assign(Object.assign({}, npmTarget(parsedPackageJson)), protoTarget(parsedPackageJson)), parseTargets(artifact.targets || {}));
    const key = { groupId: artifact.groupId, artifactId: artifact.artifactId };
    if (!key.artifactId && !key.groupId) {
        return {
            targets,
            previewUrls,
            platforms,
        };
    }
    (0, extract_from_pom_xml_1.validate)(key, 'package.json', packageJson.dir);
    return {
        key,
        targets,
        previewUrls,
        platforms,
    };
}
function extractPreviewUrls(previewUrls) {
    const schema = z
        .array(z.union([z.string().url(), z.object({ title: z.string(), url: z.string().url() })]))
        .default([]);
    return schema.parse(previewUrls);
}
function extractPlatforms(platforms) {
    const schema = z.array(z.nativeEnum(artifact_description_1.Platforms)).default([]);
    return schema.parse(platforms);
}
function extractContributors(parsedPackageJson) {
    const contributorSchema = z.object({ name: z.string().optional(), email: z.string() });
    const contributorsSchema = z.array(contributorSchema).nonempty();
    const contributorsParseResult = contributorsSchema.safeParse(parsedPackageJson === null || parsedPackageJson === void 0 ? void 0 : parsedPackageJson.contributors);
    if (contributorsParseResult.success) {
        return {
            contributors: contributorsParseResult.data,
        };
    }
    const authorSchema = z.union([
        z.string().transform((val) => {
            const matches = /^([^<(]+?)?[ \t]*(?:<([^>(]+?)>)?[ \t]*(?:\(([^)]+?)\)|$)/gm.exec(val);
            if (matches && matches.length > 2) {
                if (matches[2]) {
                    return { name: matches[1], email: matches[2] };
                }
                if (matches[1]) {
                    return { email: matches[1] };
                }
            }
        }),
        contributorSchema,
    ]);
    const authorParseResult = authorSchema.safeParse(parsedPackageJson === null || parsedPackageJson === void 0 ? void 0 : parsedPackageJson.author);
    if (authorParseResult.success && authorParseResult.data !== undefined) {
        return {
            contributors: [authorParseResult.data],
        };
    }
    return {};
}
function npmTarget(packageJson) {
    var _a, _b, _c;
    /**
     * Npm has the same logic while trying to resolve the private field.
     * Meaning `private: "false"` will be considered as a private package.
     */
    if (!packageJson.private) {
        const npmTarget = {
            registryAddress: (_a = packageJson.publishConfig) === null || _a === void 0 ? void 0 : _a.registry,
            publishAccess: ((_b = packageJson.publishConfig) === null || _b === void 0 ? void 0 : _b.access) === 'public' ? 'public' : 'restricted',
            preserveSemverRange: ((_c = packageJson.publishConfig) === null || _c === void 0 ? void 0 : _c.preserveSemverRange) === true ? true : false,
        };
        return {
            npm: npmTarget,
        };
    }
    return {};
}
function protoTarget(packageJson) {
    if (String(packageJson.wnp_type) === 'proto') {
        return {
            proto: {},
        };
    }
    return {};
}
function parseTargets(obj) {
    const DEFAULT_FOLDER_TO_UPLOAD = 'dist/statics';
    const DEFAULT_DOCKERFILE_PATH = 'Dockerfile';
    const staticTargetObjectSchema = z
        .object({
        folderToUpload: z.string().nonempty().default(DEFAULT_FOLDER_TO_UPLOAD),
    })
        .strict();
    const dockerTargetObjectSchema = z
        .object({
        dockerfilePath: z.string().nonempty().default(DEFAULT_DOCKERFILE_PATH),
        customImageName: z.string().nonempty().optional(),
        customTags: z.array(z.string()).default([]),
        autogeneratedDockerfile: z.boolean().default(false),
    })
        .strict();
    const serverlessTargetObjectSchema = z.object({}).strict();
    const targetsObjectSchema = z
        .object({
        static: z
            .union([
            z.boolean().transform((val) => {
                return val ? staticTargetObjectSchema.parse({}) : undefined;
            }),
            staticTargetObjectSchema,
        ])
            .optional(),
        docker: z
            .union([
            z.boolean().transform((val) => {
                return val ? dockerTargetObjectSchema.parse({}) : undefined;
            }),
            dockerTargetObjectSchema,
        ])
            .optional(),
        serverless: z
            .union([
            z.boolean().transform((val) => {
                return val ? serverlessTargetObjectSchema.parse({}) : undefined;
            }),
            serverlessTargetObjectSchema,
        ])
            .optional(),
    })
        .passthrough()
        .transform((targetPayloads) => (0, lodash_pickby_1.default)(targetPayloads, (targetPayload) => targetPayload !== undefined));
    return targetsObjectSchema.parse(obj);
}
//# sourceMappingURL=extract-from-package-json.js.map