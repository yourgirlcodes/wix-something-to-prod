"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlyntPluginsHostImpl = void 0;
const assert_1 = __importDefault(require("assert"));
class FlyntPluginsHostImpl {
    constructor() {
        this.plugins = [];
        this.pluginByName = new Map();
    }
    async loadPluginModule(pluginModule) {
        const { createPlugin } = pluginModule;
        (0, assert_1.default)(createPlugin, 'no createPlugin function defined');
        const plugin = createPlugin();
        await this.loadPlugin(plugin);
    }
    async loadPlugin(plugin) {
        (0, assert_1.default)(plugin, 'createPlugin function did not return a plugin');
        const name = plugin.name;
        (0, assert_1.default)(name, 'a plugin must have a name');
        (0, assert_1.default)(!this.pluginByName.has(name), `A plugin named ${name} already exists`);
        this.plugins.push(plugin);
        this.pluginByName.set(name, plugin);
    }
    createPluginsRunner(ctx) {
        return new PluginsRunner(ctx, this.plugins);
    }
}
exports.FlyntPluginsHostImpl = FlyntPluginsHostImpl;
const noop = () => {
};
const aNoop = async () => {
};
class PluginsRunner {
    constructor(ctx, plugins) {
        this.flyntHostCtx = ctx;
        this.plugins = plugins.map(plugin => ({
            plugin,
            ctx: {
                opts: ctx.opts,
                debug: ctx.debug ?? noop,
                reportError: ctx.reportError ?? aNoop,
            }
        }));
    }
    async init() {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.init) {
                await pluginCtx.plugin.init(pluginCtx.ctx);
            }
        }
    }
    async beforeUnload(result) {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.beforeUnload) {
                await pluginCtx.plugin.beforeUnload(pluginCtx.ctx, result);
            }
        }
    }
    beforeValidateFlyntOptions() {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.beforeValidateFlyntOptions) {
                pluginCtx.plugin.beforeValidateFlyntOptions(pluginCtx.ctx);
            }
        }
        const opts = this.flyntHostCtx.opts;
        Object.freeze(opts);
        return opts;
    }
    async beforeWriteToOutputFile(output) {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.beforeWriteToOutputFile) {
                await pluginCtx.plugin.beforeWriteToOutputFile(pluginCtx.ctx, output);
            }
        }
    }
    async afterWriteToOutputFile(output) {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.afterWriteToOutputFile) {
                await pluginCtx.plugin.afterWriteToOutputFile(pluginCtx.ctx, output);
            }
        }
    }
    getResultsBaseFolder() {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.getResultsBaseFolder) {
                const result = pluginCtx.plugin.getResultsBaseFolder(pluginCtx.ctx);
                if (result) {
                    return result;
                }
            }
        }
    }
    getFormatSeverityFunction() {
        for (const pluginCtx of this.plugins) {
            if (pluginCtx.plugin.getFormatSeverityFunction) {
                return pluginCtx.plugin.getFormatSeverityFunction(pluginCtx.ctx);
            }
        }
    }
}
//# sourceMappingURL=host.js.map