import {FlyntHostCtx, FlyntPlugins, PluginsHost} from '../index';
import {FlyntCtx, FlyntOptions, FlyntOutput, FlyntPlugin, FlyntResults, FormatSeverity, PluginModule} from '@wix/flynt-plugin-types';
import assert from 'assert';

export class FlyntPluginsHostImpl implements PluginsHost {
  plugins: FlyntPlugin[] = [];
  pluginByName = new Map<string, FlyntPlugin>();

  async loadPluginModule(pluginModule: PluginModule) {
    const {createPlugin} = pluginModule;
    assert(createPlugin, 'no createPlugin function defined');
    const plugin = createPlugin();
    await this.loadPlugin(plugin);
  }

  async loadPlugin(plugin: FlyntPlugin) {
    assert(plugin, 'createPlugin function did not return a plugin');
    const name = plugin.name;
    assert(name, 'a plugin must have a name');
    assert(!this.pluginByName.has(name), `A plugin named ${name} already exists`);
    this.plugins.push(plugin);
    this.pluginByName.set(name, plugin);
  }

  createPluginsRunner(ctx: FlyntHostCtx): FlyntPlugins {
    return new PluginsRunner(ctx, this.plugins);
  }
}

const noop = () => {
};
const aNoop = async () => {
};

class PluginsRunner implements FlyntPlugins {
  flyntHostCtx: FlyntHostCtx;
  plugins: {plugin: FlyntPlugin; ctx: FlyntCtx}[];

  constructor(ctx: FlyntHostCtx, plugins: FlyntPlugin[]) {
    this.flyntHostCtx = ctx;
    this.plugins = plugins.map(plugin => ({
      plugin,
      ctx: {
        opts: ctx.opts,
        debug: ctx.debug ?? noop,
        reportError: ctx.reportError ?? aNoop,
      }
    }));
  }

  async init() {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.init) {
        await pluginCtx.plugin.init(pluginCtx.ctx);
      }
    }
  }

  async beforeUnload(result: FlyntResults) {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.beforeUnload) {
        await pluginCtx.plugin.beforeUnload(pluginCtx.ctx, result);
      }
    }
  }

  beforeValidateFlyntOptions(): FlyntOptions {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.beforeValidateFlyntOptions) {
        pluginCtx.plugin.beforeValidateFlyntOptions(pluginCtx.ctx);
      }
    }
    const opts = this.flyntHostCtx.opts;
    Object.freeze(opts);
    return opts;
  }

  async beforeWriteToOutputFile(output: FlyntOutput) {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.beforeWriteToOutputFile) {
        await pluginCtx.plugin.beforeWriteToOutputFile(pluginCtx.ctx, output);
      }
    }
  }

  async afterWriteToOutputFile(output: FlyntOutput) {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.afterWriteToOutputFile) {
        await pluginCtx.plugin.afterWriteToOutputFile(pluginCtx.ctx, output);
      }
    }
  }

  getResultsBaseFolder(): string | undefined {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.getResultsBaseFolder) {
        const result = pluginCtx.plugin.getResultsBaseFolder(pluginCtx.ctx);
        if (result) {
          return result;
        }
      }
    }
  }

  getFormatSeverityFunction(): FormatSeverity | undefined {
    for (const pluginCtx of this.plugins) {
      if (pluginCtx.plugin.getFormatSeverityFunction) {
        return pluginCtx.plugin.getFormatSeverityFunction(pluginCtx.ctx);
      }
    }
  }
}
