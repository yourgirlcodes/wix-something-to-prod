import path from 'path';
import {CliOption, FlyntOptions, FlyntOutput, Severity} from '@wix/flynt-plugin-types';
import {SamplePlugin} from './resources/plugins/sample-plugin';
import {FlyntPluginsCliHostImpl} from '../lib/cli-host';

describe('plugins host', () => {
  let pluginsHost: FlyntPluginsCliHostImpl;

  beforeEach(() => {
    pluginsHost = new FlyntPluginsCliHostImpl();
  });

  describe('host functionality', () => {
    describe('loadPluginsFromCli', () => {
      it('does not fail if no plugin is passed', async () => {
        await pluginsHost.loadPluginsFromCli([]);
        expect(pluginsHost.plugins).toEqual([]);
      });

      it('loads multiple plugins', async () => {
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/plugin',
          './test/resources/plugins/sample-plugin',
        ));
        expect(pluginsHost.plugins).toEqual([
          expect.objectContaining({
            name: 'plugin'
          }),
          expect.objectContaining({
            name: 'sample'
          })
        ]);
      });

      it('throws if plugin can not be loaded', async () => {
        await expect(pluginsHost.loadPluginsFromCli(['-p', '@wix/not-existing'])).rejects.toThrow(/module.*@wix\/not-existing/);
      });

      it('throws if plugin does not export an createPlugin function', async () => {
        await expect(pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/plugin-no-factory',
        ))).rejects.toThrow(/no createPlugin function defined/);
      });

      it('throws if plugin does not return a plugin', async () => {
        await expect(pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/plugin-factory-returns-undefined',
        ))).rejects.toThrow(/createPlugin function did not return a plugin/);
      });

    });

    describe('loadPlugin', () => {
      it('loads plugins directly', async () => {
        /* eslint-disable-next-line node/no-missing-require */
        await pluginsHost.loadPluginModule(require('./resources/plugins/plugin'));
        await pluginsHost.loadPlugin({name: 'cli2'});

        expect(pluginsHost.plugins).toEqual([
          expect.objectContaining({
            name: 'plugin'
          }),
          expect.objectContaining({
            name: 'cli2'
          })
        ]);
      });

      it('throws if loading two plugins with the same name', async () => {
        await pluginsHost.loadPlugin({name: 'cli2'});
        await expect(pluginsHost.loadPlugin({name: 'cli2'})).rejects.toThrow(/already exists/);
      });
    });

    describe('extend cli options', () => {
      beforeEach(async () => {
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/sample-plugin',
          './test/resources/plugins/plugin',
        ));
        await pluginsHost.loadPlugin({
          name: 'plg2',
          getCliOptions(): CliOption[] {
            return [{name: 'param2'}];
          }
        });
      });

      describe('getExtendedCliOptions', () => {
        it('get extended cli options from all plugins', async () => {
          const opts = pluginsHost.getExtendedCliOptions();
          expect(opts.sample).toEqual<CliOption[]>([{name: 'param'}]);
          expect(opts.plg2).toEqual<CliOption[]>([{name: 'param2'}]);
          expect(opts.plg3).toBeUndefined();
        });
      });

      describe('setPluginOptions', () => {
        it('set option values for a plugin', async () => {
          const opts = {param: 'some-value'};
          pluginsHost.setPluginOptions('sample', opts);
          const plg1 = pluginsHost.pluginByName.get('sample') as SamplePlugin;
          expect(plg1.opts).toEqual(opts);
        });
      });

      describe('bad plugin', () => {
        beforeEach(async () => {
          await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
            './test/resources/plugins/bad-plugin',
          ));
        });

        it('throws when a plugin returns invalid cli options', async () => {
          expect(() => pluginsHost.getExtendedCliOptions()).toThrow(/invalid.*getCliOptions.*\{\}/);
        });
      });
    });

  });

  describe('runner', () => {
    describe('beforeValidateFlyntOptions', () => {
      let opts: FlyntOptions;
      beforeEach(async () => {
        opts = {
          mainProtoFolder: 'main',
          moduleRootFolder: 'module',
        };

        await pluginsHost.loadPlugin({
          name: 'plg2',
          beforeValidateFlyntOptions(ctx) {
            ctx.opts.includeProtoFolder = ['some-folder'];
          }
        });
      });

      it('plugins can change opts', async () => {
        pluginsHost.createPluginsRunner({opts}).beforeValidateFlyntOptions();
        expect(opts.includeProtoFolder).toEqual(['some-folder']);
      });

      it('cant update options after update was called', async () => {
        expect(() => opts.mainProtoFolder = 'bar').not.toThrow();
        pluginsHost.createPluginsRunner({opts}).beforeValidateFlyntOptions();
        expect(() => opts.mainProtoFolder = 'foo').toThrow(/read only/);
      });
    });

    describe('beforeWriteToOutputFile', () => {
      const opts: FlyntOptions = {
        mainProtoFolder: 'main',
        moduleRootFolder: 'module',
      };
      beforeEach(async () => {
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/sample-plugin',
        ));
        await pluginsHost.loadPlugin({
          name: 'plg2',
          beforeWriteToOutputFile(ctx, output) {
            output.foo = 'bar';
          }
        });
      });

      it('multiple plugins can change output', async () => {
        const output: FlyntOutput = {lintResults: {results: [], disabled:[], executionErrors: []}, config: {rules: {}}};
        await pluginsHost.createPluginsRunner({opts}).beforeWriteToOutputFile(output);
        expect(output.opts).toEqual(opts);
        expect(output.foo).toEqual('bar');
      });
    });

    describe('getResultsBaseFolder', () => {
      const opts: FlyntOptions = {
        mainProtoFolder: 'main',
        moduleRootFolder: 'module',
      };

      it('returns undefined if no plugin returns a value', async () => {
        const baseFolder = pluginsHost.createPluginsRunner({opts}).getResultsBaseFolder();
        expect(baseFolder).toBeUndefined();
      });

      it('ignores plugins which return an empty value', async () => {
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/bad-plugin',
          './test/resources/plugins/sample-plugin',
        ));
        const baseFolder = pluginsHost.createPluginsRunner({opts}).getResultsBaseFolder();
        expect(baseFolder).toEqual(opts.mainProtoFolder + '1');
      });

      it('returns the value returned by the first plugin', async () => {
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/sample-plugin',
        ));
        await pluginsHost.loadPlugin({
          name: 'plg2',
          getResultsBaseFolder(ctx): string {
            return ctx.opts.mainProtoFolder + '2';
          }
        });
        const baseFolder = pluginsHost.createPluginsRunner({opts}).getResultsBaseFolder();
        expect(baseFolder).toEqual(opts.mainProtoFolder + '1');
      });
    });

    describe('getFormatSeverityFunction', () => {
      const opts: FlyntOptions = {
        mainProtoFolder: 'main',
        moduleRootFolder: 'module',
      };

      it('returns undefined if no plugin returns a value', async () => {
        const func = pluginsHost.createPluginsRunner({opts}).getFormatSeverityFunction();
        expect(func).toBeUndefined();
      });

      it('returns the value returned by the first plugin', async () => {
        await pluginsHost.loadPlugin({
          name: 'plg2',
          getFormatSeverityFunction() {
            return () => '2';
          }
        });
        await pluginsHost.loadPluginsFromCli(loadPluginsOpts(
          './test/resources/plugins/sample-plugin',
        ));

        const func = pluginsHost.createPluginsRunner({opts}).getFormatSeverityFunction();
        expect(func).toBeInstanceOf(Function);
        expect(func!(Severity.Error)).toEqual('2');
      });
    });

    describe('debug log', () => {
      let opts: FlyntOptions;
      beforeEach(async () => {
        opts = {
          mainProtoFolder: 'main',
          moduleRootFolder: 'module',
        };

        await pluginsHost.loadPlugin({
          name: 'plg1',
          init(ctx) {
            ctx.debug('plg1 initialized');
          }
        });

        await pluginsHost.loadPlugin({
          name: 'plg2',
          init(ctx) {
            ctx.debug('plg2 initialized');
          }
        });
      });

      it('plugins can log messages', async () => {
        await expect(pluginsHost.createPluginsRunner({opts}).init()).resolves.not.toThrow();
      });

    });
  });
});


function loadPluginsOpts(...plugins: string[]) {
  const opts = [];
  for (const plugin of plugins) {
    const pluginPath = path.resolve(plugin);
    opts.push('-p', `${pluginPath}`);
  }
  return opts;
}
