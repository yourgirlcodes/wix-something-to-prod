const debug = require('@wix/debug-no-namespace');
const resolve = require('./name-resolver');
const enableNamespace = require('./enable-namespace');
const assert = require('assert');
const jsonStringifySafe = require('json-stringify-safe');
const LRU = require('lru-cache');
const MAX_CACHE_SIZE = 10000;
const cachedNamespaces = new LRU(MAX_CACHE_SIZE);

class DebugLogger {
  constructor(name, requestData = {}, {skipEnablingErrors, customData} = {}) {
    assert(name, 'Name must be provided');
    this._requestData = requestData;
    this._customData = customData || {};
    this._name = name;
    const logKeys = resolve(name);

    const errorNamespace = logKeys['error'];
    if (!skipEnablingErrors && process.env.DEBUG_ENV_ONLY !== 'true' && !isNamespaceEnabled(errorNamespace)) {
      // We just cached the "enabled=false". We are going to enable this NS - let's clear the cache
      cachedNamespaces.del(errorNamespace);
      debug.enable(enableNamespace(process.env['DEBUG'], errorNamespace));
    }

    ['info', 'debug', 'error', 'trace', 'warn'].forEach(level => {
      const levelNamespace = logKeys[level];
      this[`_${level}`] = logWith(cachedLogger(levelNamespace), this._requestData, this._customData, levelNamespace, level);
    });
  }

  withRequest(req) {
    return this.withAspects(req.aspects);
  }

  withAspects(aspects) {
    const requestId = get(aspects, 'raw.inbound.x-wix-request-id');
    return new DebugLogger(this._name, {
      ...(requestId ? {requestId} : {requestId: undefined}),
      ...this._requestData
    }, {skipEnablingErrors: true, customData: this._customData});
  }

  withData(data) {
    return new DebugLogger(this._name,
      this._requestData,
      {skipEnablingErrors: true, customData: {...this._customData, ...data}});
  }

  trace(...args) {
    this._trace(args);
  }

  debug(...args) {
    this._debug(args);
  }

  info(...args) {
    this._info(args);
  }

  error(...args) {
    this._error(args);
  }

  warn(...args) {
    this._warn(args);
  }
}

function toKeyValueStringPairs(requestData) {
  return Object.keys(requestData).map(key => `[${key}: ${requestData[key]}]`);
}

function isJsonEnabled() {
  return process.env['JSON_STDOUT'] === 'enabled';
}

const LOGGERS = new Map();

function cachedLogger(key) {
  let logger = LOGGERS.get(key);
  if (!logger) {
    logger = debug(key);
    LOGGERS.set(key, logger);
  }
  return logger;
}

function logWith(logger, requestData, customData, namespace, level) {

  const argsToJson = argsArray => applyMultiArgsTransform(argsArray).map(el => toJson(el, namespace, requestData, customData, level));

  if (isJsonEnabled()) {
    return argsArray => {
      if (!isNamespaceEnabled(namespace)) {
        return;
      }

      argsArray = argsArray.map(applyErrorStackSuppression);
      const args = argsToJson(argsArray);
      return logger.apply(logger, args.map(arg => jsonStringifySafe(arg)));
    };
  }

  return argsArray => {
    if (!isNamespaceEnabled(namespace)) {
      return;
    }
    argsArray = argsArray.map(applyErrorStackSuppression);
    const errorDetailsData = getErrorArgAddedData(argsArray);
    const argsWithData = mergeDataItems(argsArray, {...errorDetailsData, ...customData});
    logger.apply(logger, toKeyValueStringPairs(requestData).concat(argsWithData).map(el => debug.coerce(el)));
  };
}

function getErrorArgAddedData(argsArray) {
  const errorArg = argsArray.find(arg => arg instanceof Error);
  return errorArg && errorArg.details && {'_errorDetails': buildErrorDetails(errorArg)};
}

function mergeDataItems(argsArray, customData) {
  if (Object.keys(customData).length === 0) {
    return argsArray;
  } else if (argsArray.length > 1 && typeof argsArray[1] === 'object') {
    //merge the logger data into the second arg
    const argsArrayCpy = [...argsArray];
    argsArrayCpy[1] = {...customData, ...argsArrayCpy[1]};
    return argsArrayCpy;
  } else {
    return argsArray.concat(customData);
  }
}

function isNamespaceEnabled(namespace) {
  let enabled = cachedNamespaces.get(namespace);
  if (enabled === undefined) {
    enabled = debug.enabled(namespace);
    cachedNamespaces.set(namespace, enabled);
  }
  return enabled;
}


function applyMultiArgsTransform(argsArray) {
  if (argsArray.length > 1) {
    argsArray = argsArray.map(arg => arg instanceof Error ? errorToObject(arg) : arg);
    if (argsArray.every(item => typeof item !== 'object')) {
      argsArray = [argsArray.join(',')];
    } else {
      argsArray = [jsonStringifySafe(argsArray)];
    }
  }
  return argsArray;
}

function toJson(param, namespace, requestData, customData, level) {
  const _appName = process.env['APP_NAME'] || 'APP_NAME_NOT_SET';
  const _hostName = process.env['HOSTNAME'] || 'HOSTNAME_NOT_SET';
  const _dc = process.env['DC_NAME'] || 'DC_NOT_SET';
  const _shortAppName = process.env['SHORT_APP_NAME'] || 'SHORT_APP_NAME_NOT_SET';

  const _requestData = toKeyValueStringPairs(requestData);

  const additionalParams = {
    _appName,
    _hostName,
    _dc,
    _shortAppName,
    _namespace: namespace,
    ...customData,
    _requestData,
    wnp_requestId: requestData.requestId,
    request_id: requestData.requestId,
    wnp_namespace: namespace,
    timestamp: new Date().toISOString(),
    level: level.toUpperCase(),
    lvl: level.toUpperCase(),
    infra: {
      appName: _appName,
      hostName: _hostName,
      dc: _dc,
      shortAppName: _shortAppName,
      namespace,
      requestData: _requestData
    }
  };

  if (param instanceof Object) {
    if (Array.isArray(param)) {
      return {
        ...additionalParams,
        text: jsonStringifySafe(param)
      };
    }

    if (param instanceof Error) {
      return {
        ...additionalParams,
        ...errorToObject(param)
      };
    }

    if (param._appName || param._hostName || param._dc || param._shortAppName || param._namespace || param._requestData || param.timestamp || param.infra || Object.keys(param).find(k => k.startsWith('wnp_'))) {
      return {
        ...additionalParams,
        data: param,
        error: {
          message: 'Please don\'t use \'_appName\', \'_hostName\', \'_dc\', \'_shortAppName\', \'_namespace\', \'_requestData\', \'timestamp\', \'infra\' and params starting with \'wnp_\' in your JSON payload!'
        }
      };
    }

    return {
      ...additionalParams,
      ...param
    };
  }

  return {
    ...additionalParams,
    text: param
  };
}

function buildErrorDetails(err) {
  const details = err.details && (typeof err.details === 'object' ? {...err.details} : {details: err.details});
  const causeDetails = err.cause && {_causeDetails: buildErrorDetails(err.cause)};
  if (details || causeDetails) {
    return {...details, ...causeDetails};
  }
}

function errorToObject(err) {
  return {
    errorData: {
      message: err.message,
      name: err.name,
      stack: err.stack,
      errorDetails: buildErrorDetails(err)
    },
    message: err.message
  };
}

function applyErrorStackSuppression(arg) {
  if (arg instanceof Error && arg._doNotLogStackTrace === true) {
    const copy = Object.create(arg);
    copy.stack = arg.toString();
    return copy;
  } else {
    return arg;
  }
}

function get(obj, path) {
  const parts = path.split('.');
  let result = obj;
  while (result !== undefined && parts.length > 0) {
    result = result[parts.shift()];
  }
  return result;
}

module.exports = DebugLogger;
