const HttpStatus = require('./lib/http-status-codes'),
  assert = require('assert');

const REMOTE_MARKER = Symbol('remote-error-marker');

const ErrorCode = {
  UNKNOWN: -100,
  INVALID_SESSION: -101,
  RPC_ERROR: -102,
  GATEKEEPER_ACCESS_DENIED: -103,
  HEALTH_TEST_FAILED: -104,
  SESSION_REQUIRED: -105,
  BAD_CSRF_TOKEN: -106,
  UNHANDLED_REJECTION: -107,
  THROTTLED: -108,
  GATEKEEPER_METASITE_NOT_FOUND: -109,
  GRPC_ERROR: -110,
  UNSUPPORTED_BROWSER: 407
};

class WixBaseError extends Error {
  constructor(msg, {cause, errorCode = ErrorCode.UNKNOWN, httpStatusCode = HttpStatus.INTERNAL_SERVER_ERROR, name} = {
    errorCode: ErrorCode.UNKNOWN, httpStatusCode: HttpStatus.INTERNAL_SERVER_ERROR
  }) {
    super(msg);
    assert(Number.isInteger(errorCode), 'errorCode must be provided and be a valid integer');
    assert.doesNotThrow(() => HttpStatus.getStatusText(httpStatusCode), 'HTTP status must be valid');
    assert(!msg || typeof (msg) === 'string', 'message is mandatory');
    this.name = name || this.constructor.name;
    this._errorCode = errorCode;
    this._httpStatus = httpStatusCode;
    addCauseIfValid(this, cause);
    generateStackTrace(this);
    addMarkerProperties(this);
  }

  static isInstance(instance) {
    return (instance && instance[markerPropertyName(this.prototype.constructor.name)]) === ERROR_INSTANCE_MARK;
  }

  get cause() {
    return this._cause;
  }

  get errorCode() {
    return this._errorCode;
  }

  get httpStatusCode() {
    return this._httpStatus;
  }
}

class WixError extends WixBaseError {
  constructor(msg, cause) {
    super(msg, {cause});
  }
}

class WixSystemError extends WixBaseError {
  constructor(msg, opts) {
    super(msg, opts);
  }
}

class WixBusinessError extends WixBaseError {
  constructor(msg, opts) {
    super(msg, opts);
    this._exposeMessage = true;
    this._escapeHtml = (opts || {}).escapeHtml !== false;
  }

  get escapeHtml() {
    return this._escapeHtml;
  }
}

class WixUnsupportedBrowserError extends WixBusinessError {
  constructor(data) {
    super('Unsupported Browser', {errorCode: ErrorCode.UNSUPPORTED_BROWSER, httpStatusCode: HttpStatus.OK});
    this.details = {errorCode: 'unsupportedBrowser', data};
  }
}

function makeErrorClass(additionalProperties) {

  return (errorCode = ErrorCode.UNKNOWN, httpStatusCode = HttpStatus.INTERNAL_SERVER_ERROR) => {

    return class extends WixBaseError {
      constructor(msg, cause) {
        super(msg, {cause, errorCode, httpStatusCode});
        Object.assign(this, additionalProperties);
      }
    };
  };
}

function addCauseIfValid(current, cause) {
  if (cause) {
    if (cause instanceof Error) {
      current._cause = cause;
    } else if (typeof cause === 'string') {
      current._cause = new Error(cause);
    }
  }
}

function generateStackTrace(current) {
  Error.captureStackTrace(current, current.constructor);
  if (current.cause) {
    current.stack = current.stack + '\nCaused By: ' + (current.cause.stack || current.cause.toString());
  }
}

const ERROR_INSTANCE_MARK = true;

function markerPropertyName(className) {
  return `__is_${className}__`;
}

function addMarkerProperties(obj) {
  let currentProto = obj.__proto__;
  while (currentProto && currentProto !== Error.prototype) {
    Object.defineProperty(obj, markerPropertyName(currentProto.constructor.name), {value: ERROR_INSTANCE_MARK});
    currentProto = currentProto.__proto__;
  }
}


function extractMetadata(error) {

  const meta = {
    name: error.name,
    errorCode: error.errorCode || ErrorCode.UNKNOWN,
    httpStatusCode: error.httpStatusCode || error.status || HttpStatus.INTERNAL_SERVER_ERROR,
    escapeHtml: error.escapeHtml === true
  };

  if (error._exposeMessage === true || error.expose === true) {
    meta.message = error.message;
  }

  if (typeof error.details !== 'undefined') {
    meta.details = error.details;
  }

  return meta;
}

function isBusinessError(error) {
  return error._exposeMessage !== undefined && error._exposeMessage === true;
}

const wixBusinessError = makeErrorClass({'_exposeMessage': true});

const wixSystemError = makeErrorClass({});

class ThrottledError extends wixBusinessError(ErrorCode.THROTTLED, HttpStatus.TOO_MANY_REQUESTS) {
  constructor(msg, cause) {
    super(msg, cause);
    this._doNotLogStackTrace = true;
  }
}

function isRemote(err) {
  return !!err[REMOTE_MARKER];
}

function markRemote(err) {
  err[REMOTE_MARKER] = true;
  return err;
}

function markLocal(err) {
  delete err[REMOTE_MARKER];
  return err;
}

function throwAsLocalError(err) {
  throw markLocal(err);
}

module.exports = {
  WixBaseError,
  WixError,
  wixBusinessError,
  WixBusinessError,
  wixSystemError,
  WixSystemError,
  WixUnsupportedBrowserError,
  HttpStatus,
  ErrorCode,
  extractMetadata,
  isBusinessError,
  ThrottledError,
  isRemote,
  markRemote,
  markLocal,
  throwAsLocalError,
};
